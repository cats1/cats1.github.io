(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{379:function(s,n,e){"use strict";e.r(n);var t=e(42),a=Object(t.a)({},(function(){var s=this,n=s.$createElement,e=s._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"鉴权"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#鉴权"}},[s._v("#")]),s._v(" 鉴权")]),s._v(" "),e("p",[s._v("前端的权限控制主要有三种：路由控制（路由的跳转）、视图控制（按钮级别）和请求控制（请求拦截器）。这几种方式之后再详谈，前端做完权限控制，后台还是需要验证每一个接口，这就是鉴权。现在前后端配合鉴权的方式主要有以下几种：")]),s._v(" "),e("ul",[e("li",[s._v("HTTP Basic Authentication (HTTP基本认证)")]),s._v(" "),e("li",[s._v("session-cookie")]),s._v(" "),e("li",[s._v("Token 验证(JWT/SSO)")]),s._v(" "),e("li",[s._v("OAuth(开放授权)")])]),s._v(" "),e("h2",{attrs:{id:"http-basic-authentication-使用较少"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-basic-authentication-使用较少"}},[s._v("#")]),s._v(" HTTP Basic Authentication(使用较少)")]),s._v(" "),e("p",[s._v("这种认证方式是浏览器遵守http协议实现的基本授权方式,HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。目前基本没有再使用这种认证方式的,一些老项目的内网认证可能还会有.")]),s._v(" "),e("h2",{attrs:{id:"session-cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#session-cookie"}},[s._v("#")]),s._v(" session-cookie")]),s._v(" "),e("p",[s._v("session-cookie认证这个方式是利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，"),e("strong",[s._v("由于http请求时是无状态的")]),s._v("，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(session),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建session，如果有则已经认证成功了，否则就没有认证。")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("服务器在接受客户端首次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在 内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在 响应头中种下这个唯一标识字符串。")]),s._v(" "),e("li",[s._v("签名。这一步通过秘钥对sid进行签名处理，避免客户端修改sid。(非必需步骤)")]),s._v(" "),e("li",[s._v("浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的 请求头中会带上该域名下的cookie信息。")]),s._v(" "),e("li",[s._v("服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客 户端的session，然后判断该请求是否合法。")])])]),s._v(" "),e("p",[e("strong",[s._v("弊端:")])]),s._v(" "),e("ul",[e("li",[s._v("服务器内存消耗大: 用户每做一次应用认证,应用就会在服务端做一次记录,以方便用户下次请求时使用,通常来讲session保存在内存中,随着认证用户的增加,服务器的消耗就会很大.")]),s._v(" "),e("li",[s._v("易受到CSRF攻击: 基于cookie的一种跨站伪造攻击, 基于cookie来进行识别用户的话,用户本身就携带了值,cookie被截获,用户就很容易被伪造.")])]),s._v(" "),e("h3",{attrs:{id:"cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[s._v("#")]),s._v(" cookie")]),s._v(" "),e("p",[s._v("Http协议是一个无状态的协议，服务器不会知道到底是哪一台浏览器访问了它，因此需要一个标识用来让服务器区分不同的浏览器。cookie就是这个管理服务器与客户端之间状态的标识。\n cookie的原理是，浏览器第一次向服务器发送请求时，服务器在response头部设置Set-Cookie字段，浏览器收到响应就会设置cookie并存储，在下一次该浏览器向服务器发送请求时，就会在request头部自动带上Cookie字段，服务器端收到该cookie用以区分不同的浏览器。当然，这个cookie与某个用户的对应关系应该在第一次访问时就存在服务器端，这时就需要session了。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const http = require('http')\nhttp.createServer((req, res) => {\n  if (req.url === '/favicon.ico') {\n    return\n  } else {\n    res.setHeader('Set-Cookie', 'name=zhunny')\n    res.end('Hello Cookie')\n  }\n}).listen(3000) \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("h3",{attrs:{id:"session"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[s._v("#")]),s._v(" session")]),s._v(" "),e("p",[s._v("session是会话的意思，浏览器第一次访问服务端，服务端就会创建一次会话，在会话中保存标识该浏览器的信息。它与cookie的区别就是session是缓存在服务端的，cookie 则是缓存在客户端，他们都由服务端生成，为了弥补Http协议无状态的缺陷。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const http = require('http')\n//此时session存在内存中\nconst session = {}\nhttp.createServer((req, res) => {\n  const sessionKey = 'sid'\n  if (req.url === '/favicon.ico') {\n   return\n  } else {\n    const cookie = req.headers.cookie\n    //再次访问，对sid请求进行认证\n    if (cookie && cookie.indexOf(sessionKey) > -1) {\n      res.end('Come Back')\n    }\n    //首次访问，生成sid，保存在服务器端\n    else {\n      const sid = (Math.random() * 9999999).toFixed()\n      res.setHeader('Set-Cookie', `${sessionKey}=${sid}`)\n      session[sid] = { name: 'zhunny' }\n      res.end('Hello Cookie')\n    }\n  }\n}).listen(3000)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br")])]),e("h3",{attrs:{id:"redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[s._v("#")]),s._v(" redis")]),s._v(" "),e("p",[s._v("redis是一个键值服务器，可以专门放session的键值对。如何在koa中使用session:")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const koa = require('koa')\nconst app = new koa()\nconst session = require('koa-session')\nconst redisStore = require('koa-redis')\nconst redis = require('redis')\nconst redisClient = redis.createClient(6379, 'localhost')\nconst wrapper = require('co-redis')\nconst client = wrapper(redisClient)\n//加密sessionid\napp.keys = ['session secret']\nconst SESS_CONFIG = {\n  key: 'kbb:sess',\n  //此时让session存储在redis中\n  store: redisStore({ client })\n}\napp.use(session(SESS_CONFIG, app))\napp.use(ctx => {\n  //查看redis中的内容\n  redisClient.keys('*', (errr, keys) => {\n    console.log('keys:', keys)\n    keys.forEach(key => {\n      redisClient.get(key, (err, val) => {\n        console.log(val)\n      })\n    })\n  })\n  if (ctx.path === '/favicon.ico') return\n  let n = ctx.session.count || 0\n  ctx.session.count = ++n\n  ctx.body = `第${n}次访问`\n})\napp.listen(3000)\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br")])]),e("h4",{attrs:{id:"用户登录认证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户登录认证"}},[s._v("#")]),s._v(" 用户登录认证")]),s._v(" "),e("p",[s._v("使用session-cookie做登录认证时，登录时存储session，退出登录时删除session，而其他的需要登录后才能操作的接口需要提前验证是否存在session，存在才能跳转页面，不存在则回到登录页面。\n  在koa中做一个验证的中间件，在需要验证的接口中使用该中间件。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("//中间件 auth.js\nmodule.exports = async (ctx, next) => {\n  if (!ctx.session.userinfo) {\n    ctx.body = {\n      ok: 0,\n      message: \"用户未登录\" };\n  } else {\n    await next();\n} };\n//需要验证的接口\nrouter.get('/getUser', require('auth'), async (ctx) => {\n  ctx.body = {\n      message: \"获取数据成功\",\n      userinfo: ctx.session.userinfo\n  }\n})\n//登录\nrouter.post('/login', async (ctx) => {\n  const {\n    body\n  } = ctx.request\n  console.log('body', body)\n  //设置session\n  ctx.session.userinfo = body.username;\n  ctx.body = {\n    message: \"登录成功\"\n  }\n})\n//登出\nrouter.post('/logout', async (ctx) => {\n  //设置session\n  delete ctx.session.userinfo\n  ctx.body = {\n    message: \"登出系统\"\n  }\n})\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br")])]),e("h2",{attrs:{id:"token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[s._v("#")]),s._v(" Token")]),s._v(" "),e("p",[s._v("token是用户身份的验证方式，我们通常叫它：令牌。浏览器第一次访问服务端时会签发一张令牌，之后浏览器每次携带这张令牌访问服务端就会认证该令牌是否有效，只要服务端可以解密该令牌，就说明请求是合法的，令牌中包含的用户信息还可以区分不同身份的用户。一般token由用户信息、时间戳和由hash算法加密的签名构成。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，"),e("strong",[s._v("无需再次带上用户名和密码。")])]),s._v(" "),e("h3",{attrs:{id:"token认证流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token认证流程"}},[s._v("#")]),s._v(" Token认证流程")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("客户端使用用户名跟密码请求登录")]),s._v(" "),e("li",[s._v("服务端收到请求，去验证用户名与密码")]),s._v(" "),e("li",[s._v("验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端")]),s._v(" "),e("li",[s._v("客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里")]),s._v(" "),e("li",[s._v("客户端每次向服务端请求资源的时候需要带着服务端签发的 Token")]),s._v(" "),e("li",[s._v("服务端收到请求，然后去验证客户端请求里面带着的 Token（request头部添加Authorization），如果验证成功，就向客户端返回请求的数据，如果不成功返回401错误码，鉴权失败。")])])]),s._v(" "),e("h3",{attrs:{id:"token优点与缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token优点与缺点"}},[s._v("#")]),s._v(" Token优点与缺点")]),s._v(" "),e("h4",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" "),e("strong",[s._v("优点:")])]),s._v(" "),e("ul",[e("li",[s._v("Token 完全由应用管理，所以它可以避开同源策略. (Cookie是不允许垮域访问的,token不存在)")]),s._v(" "),e("li",[s._v("Token 可以避免 CSRF 攻击(也是因为不需要cookie了)")]),s._v(" "),e("li",[s._v("Token 可以是无状态的，可以在多个服务间共享")]),s._v(" "),e("li",[s._v("Token 支持手机端访问(Cookie不支持手机端访问)")])]),s._v(" "),e("p",[s._v("服务器只需要对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证.所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，"),e("strong",[s._v("它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了")]),s._v("，这就为应用的扩展提供了便利，解决了session扩展性的弊端。")]),s._v(" "),e("h4",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" "),e("strong",[s._v("缺点:")])]),s._v(" "),e("ul",[e("li",[s._v("占带宽: 正常情况下token要比 session_id更大，需要消耗更多流量，挤占更多带宽.(不过几乎可以忽略)")]),s._v(" "),e("li",[s._v('性能问题: 相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证.其实Token相比于session-cookie来说就是一个"时间换空间"的方案.')])]),s._v(" "),e("h4",{attrs:{id:"token和session的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token和session的区别"}},[s._v("#")]),s._v(" Token和session的区别")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("session-cookie的缺点：")]),s._v(" "),e("p",[s._v("（1）认证方式局限于在浏览器中使用，cookie是浏览器端的机制，如果在app端就无法使用cookie。")]),s._v(" "),e("p",[s._v("（2）为了满足全局一致性，我们最好把session存储在redis中做持久化，而在分布式环境下，我们可能需要在每个服务器上都备份，占用了大量的存储空间。")]),s._v(" "),e("p",[s._v("（3）在不是Https协议下使用cookie，容易受到CSRF跨站点请求伪造攻击。")])]),s._v(" "),e("li",[e("p",[s._v("token的缺点：")]),s._v(" "),e("p",[s._v("（1）加密解密消耗使得token认证比session-cookie更消耗性能。")]),s._v(" "),e("p",[s._v("（2）token比sessionId大，更占带宽。")])]),s._v(" "),e("li",[e("p",[s._v("两者对比，它们的区别显而易见：")]),s._v(" "),e("p",[s._v("（1）token认证不局限于cookie，这样就使得这种认证方式可以支持多种客户端，而不仅是浏览器。且不受同源策略的影响。")]),s._v(" "),e("p",[s._v("（2）不使用cookie就可以规避CSRF攻击。")]),s._v(" "),e("p",[s._v("（3）token不需要存储，token中已包含了用户信息，服务器端变成无状态，服务器端只需要根据定义的规则校验这个token是否合法就行。这也使得token 的可扩展性更强。")]),s._v(" "),e("blockquote",[e("ol",[e("li",[e("strong",[s._v("使用Token,服务端不需要保存状态.")]),s._v(" 在session中sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的session，这里面才保存着用户的登陆状态。但是token本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个token是否合法就行。")]),s._v(" "),e("li",[s._v("**Token不需要借助cookie的.**session-cookie是需要cookie配合的，那么在http代理客户端的选择上就只有浏览器了，因为只有浏览器才会去解析请求响应头里面的cookie,然后每次请求再默认带上该域名下的cookie。但是我们知道http代理客户端不只有浏览器，还有原生APP等等，这个时候cookie是不起作用的，或者浏览器端是可以禁止cookie的(虽然可以，但是这基本上是属于吃饱没事干的人干的事)，但是token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的cookie,storage，或者内存中，然后再下一次请求的请求头重带上这个token就行了。简单点来说cookie-session机制他限制了客户端的类型，而token验证机制丰富了客户端类型。")]),s._v(" "),e("li",[s._v("时效性。session-cookie的sessionid实在登陆的时候生成的而且在登出事时一直不变的，在一定程度上安全就会低，而token是可以在一段时间内动态改变的。")]),s._v(" "),e("li",[s._v("可扩展性。token验证本身是比较灵活的，一是token的解决方案有许多，常用的是JWT,二来我们可以基于token验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。")])])])])]),s._v(" "),e("h3",{attrs:{id:"token过期与refresh-token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token过期与refresh-token"}},[s._v("#")]),s._v(" Token过期与Refresh Token")]),s._v(" "),e("p",[e("strong",[s._v("Token过期:")])]),s._v(" "),e("p",[s._v("token是访问特定资源的凭证，出于安全考虑,肯定是要有过期时间的。要不然一次登录便可能一直使用，那token认证还有什么意义? token可定是有过期时间的,一般不会很长,不会超高一个小时.")]),s._v(" "),e("p",[e("strong",[s._v("Refresh Token :")])]),s._v(" "),e("p",[s._v("为什么需要refresh token?如果token过期了，就要重新获取。继续重复第一次获取token的过程(比如登录，扫描授权等)，每一小时就必须获取一次! 这样做是非常不好的用户体验。为了解决这个问题,于是就有了refresh token."),e("strong",[s._v("通过refresh token去重新获取新的 token.")])]),s._v(" "),e("p",[s._v("refresh token，也是加密字符串，并且和token是相关联的。与获取资源的token不同，"),e("strong",[s._v("refresh token的作用仅仅是获取新的token")]),s._v("，因此其作用和安全性要求都较低，所以其过期时间也可以设置得长一些,可以以天为最小单位。当然如果refresh token过期了,还是需要重新登录验证的.")]),s._v(" "),e("h3",{attrs:{id:"jwt-json-web-token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jwt-json-web-token"}},[s._v("#")]),s._v(" JWT（JSON Web Token）")]),s._v(" "),e("p",[s._v("JWT 的原理是，服务器认证以后，生成一个 JSON 对象，这个JSON对象肯定不能裸传给用户，那谁都可以篡改这个对象发送请求。因此这个JSON对象会被服务器端签名加密后返回给用户，返回的内容就是一张令牌，以后用户每次访问服务器端就带着这张令牌。这个JSON对象可能包含的内容就是用户的信息，用户的身份以及令牌的过期时间。")]),s._v(" "),e("p",[s._v("JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户.之后用户与服务器通信的时候.服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，"),e("strong",[s._v("会加上签名")]),s._v("。")]),s._v(" "),e("p",[s._v("jwt最大的特点就是: "),e("strong",[s._v("服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。")])]),s._v(" "),e("h5",{attrs:{id:"jwt的组成部分-数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jwt的组成部分-数据结构"}},[s._v("#")]),s._v(" JWT的组成部分（数据结构）")]),s._v(" "),e("p",[s._v("它是一个很长的"),e("strong",[s._v("字符串")]),s._v("，中间用点（.）分隔成三个部分。它由三部分组成：Header（头部）、Payload（负载）、Signature（签名）。")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("Header部分是一个JSON对象，描述JWT的元数据。一般描述信息为该Token的加密算法以及Token的类型。"),e("code",[s._v('{"alg": "HS256","typ": "JWT"}')]),s._v("的意思就是，该token使用HS256加密，token类型是JWT。这个部分基本相当于明文，它将这个JSON对象做了一个Base64转码，变成一个字符串。Base64编码解码是有算法的，解码过程是可逆的。头部信息默认携带着两个字段。")]),s._v(" "),e("li",[s._v("Payload 部分也是一个 JSON  对象，用来存放实际需要传递的数据。有7个官方字段，还可以在这个部分定义私有字段。一般存放用户名、用户身份以及一些JWT的描述字段。它也只是做了一个Base64编码，因此肯定不能在其中存放秘密信息，比如说登录密码之类的。"),e("strong",[s._v("注意:")]),s._v(" "),e("strong",[s._v("JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。")])]),s._v(" "),e("li",[s._v("Signature是对前面两个部分的签名，防止数据篡改，如果前面两段信息被人修改了发送给服务器端，此时服务器端是可利用签名来验证信息的正确性的。签名需要密钥（"),e("strong",[s._v("只有服务器才知道，不能泄露给用户")]),s._v('），密钥是服务器端保存的，用户不知道。算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。')])])]),s._v(" "),e("h5",{attrs:{id:"jwt的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jwt的特点"}},[s._v("#")]),s._v(" JWT的特点")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。")]),s._v(" "),e("li",[s._v("JWT 不加密的情况下，不能将秘密数据写入 JWT。")]),s._v(" "),e("li",[s._v("JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。")]),s._v(" "),e("li",[s._v("JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。")]),s._v(" "),e("li",[s._v("JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。")]),s._v(" "),e("li",[s._v("为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。")])])]),s._v(" "),e("h5",{attrs:{id:"jwt验证用户登录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jwt验证用户登录"}},[s._v("#")]),s._v(" JWT验证用户登录")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('//前端代码\n//axios的请求拦截器，在每个request请求头上加JWT认证信息\naxios.interceptors.request.use(\n    config => {\n        const token = window.localStorage.getItem("token");\n        if (token) {\n        // 判断是否存在token，如果存在的话，则每个http header都加上token\n        // Bearer是JWT的认证头部信息\n            config.headers.common["Authorization"] = "Bearer " + token;\n        }\n        return config;\n    },\n    err => {\n        return Promise.reject(err);\n    }\n);\n//登录方法：在将后端返回的JWT存入localStorage\nasync login() {\n    const res = await axios.post("/login-token", {\n        username: this.username,\n        password: this.password\n    });\n    localStorage.setItem("token", res.data.token);\n},\n//登出方法：删除JWT\nasync logout() {\n    localStorage.removeItem("token");\n},\nasync getUser() {\n    await axios.get("/getUser-token");\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br")])]),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('//后端代码\nconst jwt = require("jsonwebtoken");\nconst jwtAuth = require("koa-jwt");\n//用来签名的密钥\nconst secret = "it\'s a secret";\nrouter.post("/login-token", async ctx => {\n  const { body } = ctx.request;\n  //登录逻辑，略，即查找数据库，若该用户和密码合法，即将其信息生成一个JWT令牌传给用户\n  const userinfo = body.username;\n  ctx.body = {\n    message: "登录成功",\n    user: userinfo,\n    // 生成 token 返回给客户端\n    token: jwt.sign(\n      {\n        data: userinfo,\n        // 设置 token 过期时间，一小时后，秒为单位\n        exp: Math.floor(Date.now() / 1000) + 60 * 60\n      },\n      secret\n    )\n  };\n});\n//jwtAuth这个中间件会拿着密钥解析JWT是否合法。\n//并且把JWT中的payload的信息解析后放到state中，ctx.state用于中间件的传值。\nrouter.get(\n  "/getUser-token",\n  jwtAuth({\n    secret\n  }),\n  async ctx => {\n    // 验证通过，state.user\n    console.log(ctx.state.user);\n    ctx.body = {\n      message: "获取数据成功",\n      userinfo: ctx.state.user.data \n    };\n  }\n)\n//这种密码学的方式使得token不需要存储，只要服务端能拿着密钥解析出用户信息，就说明该用户是合法的。\n//若要更进一步的权限验证，需要判断解析出的用户身份是管理员还是普通用户。\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br"),e("span",{staticClass:"line-number"},[s._v("25")]),e("br"),e("span",{staticClass:"line-number"},[s._v("26")]),e("br"),e("span",{staticClass:"line-number"},[s._v("27")]),e("br"),e("span",{staticClass:"line-number"},[s._v("28")]),e("br"),e("span",{staticClass:"line-number"},[s._v("29")]),e("br"),e("span",{staticClass:"line-number"},[s._v("30")]),e("br"),e("span",{staticClass:"line-number"},[s._v("31")]),e("br"),e("span",{staticClass:"line-number"},[s._v("32")]),e("br"),e("span",{staticClass:"line-number"},[s._v("33")]),e("br"),e("span",{staticClass:"line-number"},[s._v("34")]),e("br"),e("span",{staticClass:"line-number"},[s._v("35")]),e("br"),e("span",{staticClass:"line-number"},[s._v("36")]),e("br"),e("span",{staticClass:"line-number"},[s._v("37")]),e("br"),e("span",{staticClass:"line-number"},[s._v("38")]),e("br"),e("span",{staticClass:"line-number"},[s._v("39")]),e("br"),e("span",{staticClass:"line-number"},[s._v("40")]),e("br"),e("span",{staticClass:"line-number"},[s._v("41")]),e("br")])]),e("p",[s._v("首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间生成 token ，返回给前端； 前端拿到后端返回的 token ,存储在 localStroage 和 Vuex 里； 前端每次路由跳转，判断 localStroage 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态； 每次请求接口，在 Axios 请求头里携带 token; 后端接口判断请求头有无 token，没有或者 token 过期，返回401； 前端得到 401 状态码，重定向到登录页面。")]),s._v(" "),e("h5",{attrs:{id:"后端主动让jwt失效的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后端主动让jwt失效的方法"}},[s._v("#")]),s._v(" 后端主动让JWT失效的方法")]),s._v(" "),e("p",[s._v("前面说过JWT一旦签发了,就不再收服务端控制了.因为它在服务端没有记录,是无状态的,是它最大的优点也是最大的缺点.这样就会造成一种不可控性.")]),s._v(" "),e("p",[s._v("例如:如果用户修改了,那他之前未到期的token怎么废弃掉???此时服务端是没有记录的,它是不知道哪些未到期的token是被废弃了的.为了解决这个问题,其实是"),e("strong",[s._v("没有完美的方法的!")]),s._v(" 都需要后端添加状态,只是那种方法开销最小.")]),s._v(" "),e("p",[s._v("目前常见的处理方法有:")]),s._v(" "),e("blockquote",[e("ul",[e("li",[s._v("1,将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。")]),s._v(" "),e("li",[s._v("2,维护一个 token 黑名单，失效则加入黑名单中(用的比较多)。")]),s._v(" "),e("li",[s._v("3,在 JWT 中增加一个版本号字段，失效则改变该版本号。")]),s._v(" "),e("li",[s._v("4,在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。")])])]),s._v(" "),e("h6",{attrs:{id:"黑名单"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#黑名单"}},[s._v("#")]),s._v(" 黑名单")]),s._v(" "),e("blockquote",[e("ul",[e("li",[s._v("1,在签发的jwt中payload加入一个为随机字符的字段"),e("code",[s._v("token_id")]),s._v(".")]),s._v(" "),e("li",[s._v("2, 在服务端的分布式缓存上保存一份“groupId”黑名单。如果用户的jwt重置密码等需要作废已经签发但未过期的jwt时，就将该之前用户的“token__id”存入到黑名单中。并分配给他一个新的“token__id”到token中.")]),s._v(" "),e("li",[s._v("3,存入到黑名单中的“token__id”会设置一个过期时间.过期后“token_id”自动从黑名单中删除。")]),s._v(" "),e("li",[s._v("4,所有需要做JWT有效性校验的服务器,启动时访问分布式缓存. 将黑名单下载到本地内存。并且订阅分布式缓存的消息推送功能，在黑名单发生增删的时候，接收推送消息同步修改内存中的黑名单列表。")]),s._v(" "),e("li",[s._v("5,服务器做JWT校验的时候，除了校验过期时间，还要查询内存中的黑名单列表。若在黑名单中，则判定该JWT为失效。")])])]),s._v(" "),e("p",[s._v("虽然黑名单还是做了分布式存储,但黑名单本身的体积和使用频率却很低,所以开销很小.")]),s._v(" "),e("h3",{attrs:{id:"单点登录-sso"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单点登录-sso"}},[s._v("#")]),s._v(" 单点登录（sso）")]),s._v(" "),e("p",[s._v("单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，"),e("strong",[s._v("用户只需要登录一次就可以访问所有相互信任的应用系统。")])]),s._v(" "),e("p",[s._v("SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。")]),s._v(" "),e("p",[s._v("流程如图\n"),e("img",{attrs:{src:s.$withBase("/img/auth.png"),alt:"dock"}})]),s._v(" "),e("ul",[e("li",[s._v("用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数")]),s._v(" "),e("li",[s._v("sso认证中心发现用户未登录，将用户引导至登录页面")]),s._v(" "),e("li",[s._v("用户输入用户名密码提交登录申请")]),s._v(" "),e("li",[s._v("sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌")]),s._v(" "),e("li",[s._v("sso认证中心带着令牌跳转会最初的请求地址（系统1）")]),s._v(" "),e("li",[s._v("系统1拿到令牌，去sso认证中心校验令牌是否有效")]),s._v(" "),e("li",[s._v("sso认证中心校验令牌，返回有效，注册系统1")]),s._v(" "),e("li",[s._v("系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源")]),s._v(" "),e("li",[s._v("用户访问系统2的受保护资源")]),s._v(" "),e("li",[s._v("系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数")]),s._v(" "),e("li",[s._v("sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌")]),s._v(" "),e("li",[s._v("系统2拿到令牌，去sso认证中心校验令牌是否有效")]),s._v(" "),e("li",[s._v("sso认证中心校验令牌，返回有效，注册系统2")]),s._v(" "),e("li",[s._v("系统2使用该令牌创建与用户的局部会话，返回受保护资源")])]),s._v(" "),e("p",[s._v("用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系")]),s._v(" "),e("ul",[e("li",[s._v("局部会话存在，全局会话一定存在")]),s._v(" "),e("li",[s._v("全局会话存在，局部会话不一定存在")]),s._v(" "),e("li",[s._v("全局会话销毁，局部会话必须销毁")])]),s._v(" "),e("p",[s._v("注销如图\n"),e("img",{attrs:{src:s.$withBase("/img/auth1.png"),alt:"dock"}})]),s._v(" "),e("p",[s._v("sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。")]),s._v(" "),e("ul",[e("li",[s._v("用户向系统1发起注销请求")]),s._v(" "),e("li",[s._v("系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求")]),s._v(" "),e("li",[s._v("sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址")]),s._v(" "),e("li",[s._v("sso认证中心向所有注册系统发起注销请求")]),s._v(" "),e("li",[s._v("各注册系统接收sso认证中心的注销请求，销毁局部会话")]),s._v(" "),e("li",[s._v("sso认证中心引导用户至登录页面")])]),s._v(" "),e("h2",{attrs:{id:"oauth"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oauth"}},[s._v("#")]),s._v(" OAuth")]),s._v(" "),e("p",[s._v("三方登入主要基于OAuth 2.0。OAuth即开发授权,其实和SSO比较像.OAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标  准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息(如用户名与密码)，  即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAuth是安全的。我们常见的提供OAuth认证服务的厂商有支付宝、QQ、微信。这样的授权方式使得用户使用门槛低，可以更好的推广自己的应用。")]),s._v(" "),e("h4",{attrs:{id:"oauth认证流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oauth认证流程"}},[s._v("#")]),s._v(" OAuth认证流程")]),s._v(" "),e("p",[s._v("OAuth就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n OAuth有四种获取令牌的方式，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。\n  在前后端分离的情境下，我们常使用授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。")])])}),[],!1,null,null,null);n.default=a.exports}}]);