(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{408:function(s,a,e){"use strict";e.r(a);var t=e(42),r=Object(t.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"nodejs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs"}},[s._v("#")]),s._v(" nodejs")]),s._v(" "),e("h2",{attrs:{id:"nodejs的安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodejs的安装"}},[s._v("#")]),s._v(" nodejs的安装")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://nodejs.org/zh-cn/",target:"_blank",rel:"noopener noreferrer"}},[s._v("nodejs官网"),e("OutboundLink")],1)]),s._v(" "),e("p",[s._v("升级")]),s._v(" "),e("div",{staticClass:"language-powershell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-powershell"}},[e("code",[s._v("npm cache clean "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("f "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##清除npm cache")]),s._v("\nnpm install "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("g n "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##安装 n 模块 这个模块是专门用来管理node.js版本的")]),s._v("\nn stable "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("##安装最新的稳定版本")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h3",{attrs:{id:"nodemon"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nodemon"}},[s._v("#")]),s._v(" nodemon")]),s._v(" "),e("p",[s._v("每次修改js文件需要重新执行才会生效,安装nodemon 可以监视文件改动,自动重启")]),s._v(" "),e("p",[s._v("npm i -g nodemon")]),s._v(" "),e("h2",{attrs:{id:"回调函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[s._v("#")]),s._v(" 回调函数")]),s._v(" "),e("p",[s._v("Node.js 异步编程的直接体现就是回调。")]),s._v(" "),e("p",[s._v("异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。")]),s._v(" "),e("p",[s._v("回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。")]),s._v(" "),e("h3",{attrs:{id:"阻塞代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阻塞代码"}},[s._v("#")]),s._v(" 阻塞代码")]),s._v(" "),e("p",[s._v("在文件读取完后才执行完程序")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("// 阻塞式代码\nconst fs = require('fs');\nconst data = fs.readFileSync('01-runnode.js');\nconsole.log(data.toString());\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h3",{attrs:{id:"非阻塞代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞代码"}},[s._v("#")]),s._v(" 非阻塞代码")]),s._v(" "),e("p",[s._v("不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("const fs = require('fs');\nfs.readFile('01-runnode.j',function(err,data) {\n    if(err){\n        console.log(err.stack);\n        return;\n    }\n    console.log(data.toString());\n});\nconsole.log('继续执行');\n\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])]),e("h2",{attrs:{id:"事件循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[s._v("#")]),s._v(" 事件循环")]),s._v(" "),e("p",[s._v("Node.js 是单进程单线程应用程序，但是通过事件和回调支持并发，所以性能非常高。")]),s._v(" "),e("p",[s._v("Node.js 的每一个 API 都是异步的，并作为一个独立线程运行，使用异步函数调用，并处理并发。")]),s._v(" "),e("p",[s._v("Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js 单线程类似进入一个"),e("code",[s._v("while(true)")]),s._v("的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.")]),s._v(" "),e("h2",{attrs:{id:"事件驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[s._v("#")]),s._v(" 事件驱动")]),s._v(" "),e("p",[s._v("Node.js 使用事件驱动模型，当"),e("code",[s._v("web server")]),s._v("接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。")]),s._v(" "),e("p",[s._v("当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。")]),s._v(" "),e("p",[s._v("这个模型非常高效可扩展性非常强，因为"),e("code",[s._v("webserver")]),s._v("一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）")]),s._v(" "),e("p",[s._v("在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。")]),s._v(" "),e("h2",{attrs:{id:"buffer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#buffer"}},[s._v("#")]),s._v(" Buffer")]),s._v(" "),e("p",[s._v("JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。")]),s._v(" "),e("p",[s._v("但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 "),e("code",[s._v("Buffer")]),s._v(" 类，该类用来创建一个专门存放二进制数据的缓存区。")]),s._v(" "),e("h2",{attrs:{id:"stream流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stream流"}},[s._v("#")]),s._v(" Stream流")]),s._v(" "),e("h4",{attrs:{id:"管道流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#管道流"}},[s._v("#")]),s._v(" 管道流")]),s._v(" "),e("p",[s._v("管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。")]),s._v(" "),e("p",[e("strong",[s._v("链式流")])]),s._v(" "),e("p",[s._v("链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作")]),s._v(" "),e("h2",{attrs:{id:"模块系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块系统"}},[s._v("#")]),s._v(" 模块系统")]),s._v(" "),e("p",[s._v("为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。")]),s._v(" "),e("p",[s._v("模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。")]),s._v(" "),e("h4",{attrs:{id:"模块commonjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块commonjs"}},[s._v("#")]),s._v(" "),e("strong",[s._v("模块CommonJS")])]),s._v(" "),e("p",[s._v("Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象")]),s._v(" "),e("h2",{attrs:{id:"常用内置模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用内置模块"}},[s._v("#")]),s._v(" 常用内置模块")]),s._v(" "),e("h3",{attrs:{id:"fs模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#fs模块"}},[s._v("#")]),s._v(" fs模块")]),s._v(" "),e("h3",{attrs:{id:"os模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#os模块"}},[s._v("#")]),s._v(" os模块")]),s._v(" "),e("h3",{attrs:{id:"http模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http模块"}},[s._v("#")]),s._v(" http模块")])])}),[],!1,null,null,null);a.default=r.exports}}]);