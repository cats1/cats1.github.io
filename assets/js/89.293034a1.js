(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{452:function(s,e,a){"use strict";a.r(e);var t=a(42),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-进阶问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-进阶问题"}},[s._v("#")]),s._v(" JavaScript 进阶问题")]),s._v(" "),a("h2",{attrs:{id:"_1、-输出是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、-输出是什么"}},[s._v("#")]),s._v(" 1、 输出是什么？")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("sayHi")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("age"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Lydia'")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("21")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("sayHi")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("ul",[a("li",[s._v("A: "),a("code",[s._v("Lydia")]),s._v(" 和 "),a("code",[s._v("undefined")])]),s._v(" "),a("li",[s._v("B: "),a("code",[s._v("Lydia")]),s._v(" 和 "),a("code",[s._v("ReferenceError")])]),s._v(" "),a("li",[s._v("C: "),a("code",[s._v("ReferenceError")]),s._v(" 和 "),a("code",[s._v("21")])]),s._v(" "),a("li",[s._v("D: "),a("code",[s._v("undefined")]),s._v(" 和 "),a("code",[s._v("ReferenceError")])])]),s._v(" "),a("details",[a("summary",[s._v("答案")]),s._v("\n    答案: D\n    "),a("p",[s._v("\n        在函数内部，我们首先通过 var 关键字声明了 name 变量。这意味着变量被提升了（内存空间在创建阶段就被设置好了），直到程序运行到定义变量位置之前默认值都是 undefined。因为当我们打印 name 变量时还没有执行到定义变量的位置，因此变量的值保持为 undefined。\n    ")]),s._v(" "),a("p",[s._v("\n        通过 let 和 const 关键字声明的变量也会提升，但是和 var 不同，它们不会被初始化。在我们声明（初始化）之前是不能访问它们的。这个行为被称之为暂时性死区。当我们试图在声明之前访问它们时，JavaScript 将会抛出一个 ReferenceError 错误。\n    ")])]),s._v(" "),a("h2",{attrs:{id:"_2、输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、输出"}},[s._v("#")]),s._v(" 2、输出")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1)\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("ul",[a("li",[s._v("A: "),a("code",[s._v("0 1 2")]),s._v(" 和 "),a("code",[s._v("0 1 2")])]),s._v(" "),a("li",[s._v("B: "),a("code",[s._v("0 1 2")]),s._v(" 和 "),a("code",[s._v("3 3 3")])]),s._v(" "),a("li",[s._v("C: "),a("code",[s._v("3 3 3")]),s._v(" 和 "),a("code",[s._v("0 1 2")])])]),s._v(" "),a("details",[a("summary",[s._v("答案")]),s._v(" "),a("p",[s._v("\n        答案: C\n        由于 JavaScript 的事件循环，setTimeout 回调会在遍历结束后才执行。因为在第一个遍历中遍历 i 是通过 var 关键字声明的，所以这个值是全局作用域下的。在遍历过程中，我们通过一元操作符 ++ 来每次递增 i 的值。当 setTimeout 回调执行的时候，i 的值等于3。\n        在第二个遍历中，遍历 i 是通过 let 关键字声明的：通过 let 和 const 关键字声明的变量是拥有块级作用域（指的是任何在 {} 中的内容）。在每次的遍历过程中，i 都有一个新值，并且每个值都在循环内的作用域中。\n        ")])]),s._v(" "),a("h2",{attrs:{id:"_3、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、"}},[s._v("#")]),s._v(" 3、")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2\n  },\n  perimeter: () => 2 * Math.PI * this.radius\n}\n\nshape.diameter()\nshape.perimeter()\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("ul",[a("li",[s._v("A: "),a("code",[s._v("20")]),s._v(" and "),a("code",[s._v("62.83185307179586")])]),s._v(" "),a("li",[s._v("B: "),a("code",[s._v("20")]),s._v(" and "),a("code",[s._v("NaN")])]),s._v(" "),a("li",[s._v("C: "),a("code",[s._v("20")]),s._v(" and "),a("code",[s._v("63")])]),s._v(" "),a("li",[s._v("D: "),a("code",[s._v("NaN")]),s._v(" and "),a("code",[s._v("63")])])]),s._v(" "),a("h4",{attrs:{id:"答案-b"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#答案-b"}},[s._v("#")]),s._v(" 答案: B")]),s._v(" "),a("p",[s._v("注意 "),a("code",[s._v("diameter")]),s._v(" 的值是一个常规函数，但是 "),a("code",[s._v("perimeter")]),s._v(" 的值是一个箭头函数。")]),s._v(" "),a("p",[s._v("对于箭头函数，"),a("code",[s._v("this")]),s._v(" 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 "),a("code",[s._v("perimeter")]),s._v(" 时，"),a("code",[s._v("this")]),s._v(" 不是指向 "),a("code",[s._v("shape")]),s._v(" 对象，而是它的周围作用域（在例子中是 "),a("code",[s._v("window")]),s._v("）。")]),s._v(" "),a("p",[s._v("在 "),a("code",[s._v("window")]),s._v(" 中没有 "),a("code",[s._v("radius")]),s._v(" 这个属性，因此返回 "),a("code",[s._v("undefined")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"_4、"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、"}},[s._v("#")]),s._v(" 4、")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('+true;\n!"Lydia";\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("A: "),a("code",[s._v("1")]),s._v(" and "),a("code",[s._v("false")])]),s._v(" "),a("li",[s._v("B: "),a("code",[s._v("false")]),s._v(" and "),a("code",[s._v("NaN")])]),s._v(" "),a("li",[s._v("C: "),a("code",[s._v("false")]),s._v(" and "),a("code",[s._v("false")])])]),s._v(" "),a("details",{attrs:{open:""}},[a("summary",[a("b",[s._v("答案")])]),s._v(" "),a("p"),a("h4",[a("a",{staticClass:"anchor",attrs:{id:"user-content-答案-a","aria-hidden":"true",href:"https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md#答案-a"}},[a("svg",{staticClass:"octicon octicon-link",attrs:{viewBox:"0 0 16 16",version:"1.1",width:"16",height:"16","aria-hidden":"true"}})])])]),s._v(" "),a("h4",{attrs:{id:"答案-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#答案-a"}},[s._v("#")]),s._v(" 答案: A")]),s._v(" "),a("p",[s._v("一元操作符加号尝试将 bool 转为 number。"),a("code",[s._v("true")]),s._v(" 转换为 number 的话为 "),a("code",[s._v("1")]),s._v("，"),a("code",[s._v("false")]),s._v(" 为 "),a("code",[s._v("0")]),s._v("。")]),s._v(" "),a("p",[s._v("字符串 "),a("code",[s._v("'Lydia'")]),s._v(" 是一个真值，真值取反那么就返回 "),a("code",[s._v("false")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"_5、哪一个是正确的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、哪一个是正确的"}},[s._v("#")]),s._v(" 5、哪一个是正确的？")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const bird = {\n  size: 'small'\n}\n\nconst mouse = {\n  name: 'Mickey',\n  small: true\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("ul",[a("li",[s._v("A: "),a("code",[s._v("mouse.bird.size")]),s._v("是无效的")]),s._v(" "),a("li",[s._v("B: "),a("code",[s._v("mouse[bird.size]")]),s._v("是无效的")]),s._v(" "),a("li",[s._v("C: "),a("code",[s._v('mouse[bird["size"]]')]),s._v("是无效的")]),s._v(" "),a("li",[s._v("D: 以上三个选项都是有效的")])]),s._v(" "),a("details",{attrs:{open:""}},[a("summary",[a("b",[s._v("答案")])]),s._v(" "),a("p"),a("h4",[a("a",{staticClass:"anchor",attrs:{id:"user-content-答案-a-1","aria-hidden":"true",href:"https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md#答案-a-1"}},[a("svg",{staticClass:"octicon octicon-link",attrs:{viewBox:"0 0 16 16",version:"1.1",width:"16",height:"16","aria-hidden":"true"}})])])]),s._v(" "),a("h4",{attrs:{id:"答案-a-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#答案-a-2"}},[s._v("#")]),s._v(" 答案: A")]),s._v(" "),a("p",[s._v("在 JavaScript 中，所有对象的 keys 都是字符串（除非对象是 Symbol）。尽管我们可能不会定义它们为字符串，但它们在底层总会被转换为字符串。")]),s._v(" "),a("p",[s._v("当我们使用括号语法时（[]），JavaScript 会解释（或者 unboxes）语句。它首先看到第一个开始括号 "),a("code",[s._v("[")]),s._v(" 并继续前进直到找到结束括号 "),a("code",[s._v("]")]),s._v("。只有这样，它才会计算语句的值。")]),s._v(" "),a("p",[a("code",[s._v("mouse[bird.size]")]),s._v("：首先计算 "),a("code",[s._v("bird.size")]),s._v("，这会得到 "),a("code",[s._v("small")]),s._v("。"),a("code",[s._v('mouse["small"]')]),s._v(" 返回 "),a("code",[s._v("true")]),s._v("。")]),s._v(" "),a("p",[s._v("然后使用点语法的话，上面这一切都不会发生。"),a("code",[s._v("mouse")]),s._v(" 没有 "),a("code",[s._v("bird")]),s._v(" 这个 key，这也就意味着 "),a("code",[s._v("mouse.bird")]),s._v(" 是 "),a("code",[s._v("undefined")]),s._v("。然后当我们使用点语法 "),a("code",[s._v("mouse.bird.size")]),s._v(" 时，因为 "),a("code",[s._v("mouse.bird")]),s._v(" 是 "),a("code",[s._v("undefined")]),s._v("，这也就变成了 "),a("code",[s._v("undefined.size")]),s._v("。这个行为是无效的，并且会抛出一个错误类似 "),a("code",[s._v('Cannot read property "size" of undefined')]),s._v("。")]),s._v(" "),a("p",[s._v("6、")])])}),[],!1,null,null,null);e.default=n.exports}}]);