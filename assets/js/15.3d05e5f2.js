(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{378:function(a,s,t){"use strict";t.r(s);var e=t(42),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"koa2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#koa2"}},[a._v("#")]),a._v(" Koa2")]),a._v(" "),t("p",[a._v("Koa是基于Node.js 平台的下一代web开发框架。是一个中间件框架。")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.itying.com/koa/",target:"_blank",rel:"noopener noreferrer"}},[a._v("中文学习网站"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[a._v("#")]),a._v(" 安装")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("npm i koa --save\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("h2",{attrs:{id:"why"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[a._v("#")]),a._v(" why?")]),a._v(" "),t("p",[a._v("Node.js是一一个异步的世界，官方API支持的都是callback 形式的异步编程模型，这会带来许多问题例如:")]),a._v(" "),t("ul",[t("li",[a._v("callback 嵌套问题")]),a._v(" "),t("li",[a._v("异步函数中可能同步调用callback返回数据，带来不一致性。")])]),a._v(" "),t("div",{staticClass:"language-csharp line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-csharp"}},[t("code",[a._v("koa2利用ES7的"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("async")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v("特性，极大的解决了我们在做nodejs开发的时候异步给我们带来的烦恼。 \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[t("em",[a._v("Koa异步处理Async、Await 和Promise的使用(重点")]),a._v(")")]),a._v(" "),t("p",[t("strong",[a._v("async")]),a._v("是“"),t("strong",[a._v("异步")]),a._v("”的简写，而"),t("strong",[a._v("await")]),a._v(" 可以认为是"),t("strong",[a._v("async wait的简写")]),a._v("。所以应该很好理解async用于申明一个function 是异步的，而await 用于等待一个异步方法执行完成。")]),a._v(" "),t("blockquote",[t("h3",{attrs:{id:"简单理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单理解"}},[a._v("#")]),a._v(" 简单理解:")]),a._v(" "),t("ul",[t("li",[a._v("async是让方法变成异步。")]),a._v(" "),t("li",[a._v("await是等待异步方法执行完成。")])])]),a._v(" "),t("h3",{attrs:{id:"await在等待async方法执行完毕执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#await在等待async方法执行完毕执行"}},[a._v("#")]),a._v(" await在等待async方法执行完毕执行")]),a._v(" "),t("p",[t("strong",[a._v("async/await同时使用")])]),a._v(" "),t("p",[a._v("async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。")]),a._v(" "),t("h3",{attrs:{id:"await阻塞的功能-把异步改成一个同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#await阻塞的功能-把异步改成一个同步"}},[a._v("#")]),a._v(" await阻塞的功能  把异步改成一个同步")]),a._v(" "),t("p",[t("strong",[a._v("async/await语法特点：")])]),a._v(" "),t("ol",[t("li",[a._v("可以让异步逻辑用同步写法实现")]),a._v(" "),t("li",[a._v("最底层的await返回需要是Promise对象")]),a._v(" "),t("li",[a._v("可以通过多层async function的同步写法来代替传统的callback嵌套")])]),a._v(" "),t("h2",{attrs:{id:"koa2特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#koa2特点"}},[a._v("#")]),a._v(" koa2特点")]),a._v(" "),t("ul",[t("li",[a._v("支持async/await")]),a._v(" "),t("li",[a._v("洋葱模型的中间件")])]),a._v(" "),t("h2",{attrs:{id:"koa2使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#koa2使用"}},[a._v("#")]),a._v(" koa2使用")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('//创建koa对象\nconst Koa = require("koa");\nconst app = new Koa();\n//绑定端口号\napp.listen(3000)\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])])])}),[],!1,null,null,null);s.default=r.exports}}]);