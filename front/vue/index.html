<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | lana&#39;s home</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="vuepress 前端个人学习网站">
    
    <link rel="preload" href="/assets/css/0.styles.98530cad.css" as="style"><link rel="preload" href="/assets/js/app.a4743452.js" as="script"><link rel="preload" href="/assets/js/2.b72805e3.js" as="script"><link rel="preload" href="/assets/js/120.5f45ba33.js" as="script"><link rel="prefetch" href="/assets/js/10.97c6631e.js"><link rel="prefetch" href="/assets/js/100.ddd238ad.js"><link rel="prefetch" href="/assets/js/101.acf46de3.js"><link rel="prefetch" href="/assets/js/102.7ecc34c5.js"><link rel="prefetch" href="/assets/js/103.9abec0c7.js"><link rel="prefetch" href="/assets/js/104.99a0bd64.js"><link rel="prefetch" href="/assets/js/105.5bd4279e.js"><link rel="prefetch" href="/assets/js/106.4a1a1e6d.js"><link rel="prefetch" href="/assets/js/107.53190e25.js"><link rel="prefetch" href="/assets/js/108.afb416d9.js"><link rel="prefetch" href="/assets/js/109.9c89f8cf.js"><link rel="prefetch" href="/assets/js/11.efe147a8.js"><link rel="prefetch" href="/assets/js/110.77f01a7c.js"><link rel="prefetch" href="/assets/js/111.f8ccec3a.js"><link rel="prefetch" href="/assets/js/112.a1b70a36.js"><link rel="prefetch" href="/assets/js/113.f74d3176.js"><link rel="prefetch" href="/assets/js/114.9f4f70ac.js"><link rel="prefetch" href="/assets/js/115.3e915f82.js"><link rel="prefetch" href="/assets/js/116.21d4d9f8.js"><link rel="prefetch" href="/assets/js/117.ed1ac975.js"><link rel="prefetch" href="/assets/js/118.b60ec45f.js"><link rel="prefetch" href="/assets/js/119.a28f9722.js"><link rel="prefetch" href="/assets/js/12.f8166b62.js"><link rel="prefetch" href="/assets/js/121.e2c73c6e.js"><link rel="prefetch" href="/assets/js/122.bea0d35f.js"><link rel="prefetch" href="/assets/js/123.4918a056.js"><link rel="prefetch" href="/assets/js/124.e9d5fd6b.js"><link rel="prefetch" href="/assets/js/125.378cd9ad.js"><link rel="prefetch" href="/assets/js/126.785be7e4.js"><link rel="prefetch" href="/assets/js/127.2dfe1120.js"><link rel="prefetch" href="/assets/js/128.0eeadbcb.js"><link rel="prefetch" href="/assets/js/129.ffd3ffd2.js"><link rel="prefetch" href="/assets/js/13.669aa6cb.js"><link rel="prefetch" href="/assets/js/130.e3caaa90.js"><link rel="prefetch" href="/assets/js/131.8914dd22.js"><link rel="prefetch" href="/assets/js/132.0ae37932.js"><link rel="prefetch" href="/assets/js/133.e989899b.js"><link rel="prefetch" href="/assets/js/134.ea062f20.js"><link rel="prefetch" href="/assets/js/135.6c137b49.js"><link rel="prefetch" href="/assets/js/14.c9aa70a1.js"><link rel="prefetch" href="/assets/js/15.3d05e5f2.js"><link rel="prefetch" href="/assets/js/16.360281d8.js"><link rel="prefetch" href="/assets/js/17.ff7cabb3.js"><link rel="prefetch" href="/assets/js/18.be16eeed.js"><link rel="prefetch" href="/assets/js/19.81b3a31e.js"><link rel="prefetch" href="/assets/js/20.472bc449.js"><link rel="prefetch" href="/assets/js/21.86395f2b.js"><link rel="prefetch" href="/assets/js/22.6c69ed50.js"><link rel="prefetch" href="/assets/js/23.2f198631.js"><link rel="prefetch" href="/assets/js/24.748c9bc2.js"><link rel="prefetch" href="/assets/js/25.c5065323.js"><link rel="prefetch" href="/assets/js/26.61d441a1.js"><link rel="prefetch" href="/assets/js/27.bfd0a986.js"><link rel="prefetch" href="/assets/js/28.bafeb054.js"><link rel="prefetch" href="/assets/js/29.0d2a1bfd.js"><link rel="prefetch" href="/assets/js/3.7f8809fd.js"><link rel="prefetch" href="/assets/js/30.8bb40757.js"><link rel="prefetch" href="/assets/js/31.eac619f5.js"><link rel="prefetch" href="/assets/js/32.04c63c5c.js"><link rel="prefetch" href="/assets/js/33.ae09c55e.js"><link rel="prefetch" href="/assets/js/34.1145a6f4.js"><link rel="prefetch" href="/assets/js/35.feb9083f.js"><link rel="prefetch" href="/assets/js/36.a586ce8a.js"><link rel="prefetch" href="/assets/js/37.c61e20e9.js"><link rel="prefetch" href="/assets/js/38.991c3427.js"><link rel="prefetch" href="/assets/js/39.23356a49.js"><link rel="prefetch" href="/assets/js/4.6819ae80.js"><link rel="prefetch" href="/assets/js/40.a3ca9111.js"><link rel="prefetch" href="/assets/js/41.649b9d9b.js"><link rel="prefetch" href="/assets/js/42.fde8ad7b.js"><link rel="prefetch" href="/assets/js/43.2d876a7c.js"><link rel="prefetch" href="/assets/js/44.64c20de7.js"><link rel="prefetch" href="/assets/js/45.a901a632.js"><link rel="prefetch" href="/assets/js/46.4ac83b64.js"><link rel="prefetch" href="/assets/js/47.2b45c49a.js"><link rel="prefetch" href="/assets/js/48.2bc12623.js"><link rel="prefetch" href="/assets/js/49.52a95dcd.js"><link rel="prefetch" href="/assets/js/5.20de2bc4.js"><link rel="prefetch" href="/assets/js/50.f445c922.js"><link rel="prefetch" href="/assets/js/51.07570e18.js"><link rel="prefetch" href="/assets/js/52.cf21a2b8.js"><link rel="prefetch" href="/assets/js/53.77792ddd.js"><link rel="prefetch" href="/assets/js/54.f19c487a.js"><link rel="prefetch" href="/assets/js/55.7fb0d05b.js"><link rel="prefetch" href="/assets/js/56.62fd0b66.js"><link rel="prefetch" href="/assets/js/57.1d6b0809.js"><link rel="prefetch" href="/assets/js/58.1aed920b.js"><link rel="prefetch" href="/assets/js/59.c2ab9dbe.js"><link rel="prefetch" href="/assets/js/6.e9784f3e.js"><link rel="prefetch" href="/assets/js/60.f4e387a9.js"><link rel="prefetch" href="/assets/js/61.735cc066.js"><link rel="prefetch" href="/assets/js/62.312489f2.js"><link rel="prefetch" href="/assets/js/63.dd2a2d4e.js"><link rel="prefetch" href="/assets/js/64.67dfd073.js"><link rel="prefetch" href="/assets/js/65.c2c22de8.js"><link rel="prefetch" href="/assets/js/66.7ea30a4b.js"><link rel="prefetch" href="/assets/js/67.6913be8c.js"><link rel="prefetch" href="/assets/js/68.b743701c.js"><link rel="prefetch" href="/assets/js/69.088259eb.js"><link rel="prefetch" href="/assets/js/7.80ddef84.js"><link rel="prefetch" href="/assets/js/70.10e2101b.js"><link rel="prefetch" href="/assets/js/71.11121db3.js"><link rel="prefetch" href="/assets/js/72.38811b9b.js"><link rel="prefetch" href="/assets/js/73.b5030976.js"><link rel="prefetch" href="/assets/js/74.d218c8d5.js"><link rel="prefetch" href="/assets/js/75.89c8d415.js"><link rel="prefetch" href="/assets/js/76.998def7e.js"><link rel="prefetch" href="/assets/js/77.6cff4b72.js"><link rel="prefetch" href="/assets/js/78.45b13ba4.js"><link rel="prefetch" href="/assets/js/79.50d5b3d0.js"><link rel="prefetch" href="/assets/js/8.4ebeab97.js"><link rel="prefetch" href="/assets/js/80.e38925eb.js"><link rel="prefetch" href="/assets/js/81.c712e794.js"><link rel="prefetch" href="/assets/js/82.f4018c72.js"><link rel="prefetch" href="/assets/js/83.878fb392.js"><link rel="prefetch" href="/assets/js/84.7ddaa3ca.js"><link rel="prefetch" href="/assets/js/85.06c8fa8b.js"><link rel="prefetch" href="/assets/js/86.b889a2e3.js"><link rel="prefetch" href="/assets/js/87.2f3171f1.js"><link rel="prefetch" href="/assets/js/88.1b0c6839.js"><link rel="prefetch" href="/assets/js/89.293034a1.js"><link rel="prefetch" href="/assets/js/9.07e73bd0.js"><link rel="prefetch" href="/assets/js/90.cdd9df6a.js"><link rel="prefetch" href="/assets/js/91.e53063a5.js"><link rel="prefetch" href="/assets/js/92.0a41da3b.js"><link rel="prefetch" href="/assets/js/93.83c37c7e.js"><link rel="prefetch" href="/assets/js/94.14eea0cb.js"><link rel="prefetch" href="/assets/js/95.18279896.js"><link rel="prefetch" href="/assets/js/96.e06d8e4e.js"><link rel="prefetch" href="/assets/js/97.2b60994e.js"><link rel="prefetch" href="/assets/js/98.28ad17a5.js"><link rel="prefetch" href="/assets/js/99.2abf3996.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98530cad.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lana's home" class="logo"> <span class="site-name can-hide">lana's home</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" class="nav-link">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" class="nav-link">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Backend</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Front</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/" aria-current="page" class="sidebar-link">前端</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Echarts</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Html 5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Treejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vscode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/vue/" aria-current="page" class="active sidebar-link">vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#基础原理" class="sidebar-link">基础原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#mvvm" class="sidebar-link">MVVM</a></li><li class="sidebar-sub-header"><a href="/front/vue/#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/front/vue/#双向绑定" class="sidebar-link">双向绑定</a></li><li class="sidebar-sub-header"><a href="/front/vue/#vnode" class="sidebar-link">VNode</a></li><li class="sidebar-sub-header"><a href="/front/vue/#nexttick" class="sidebar-link">NextTick()</a></li><li class="sidebar-sub-header"><a href="/front/vue/#template" class="sidebar-link">template</a></li><li class="sidebar-sub-header"><a href="/front/vue/#api" class="sidebar-link">API</a></li><li class="sidebar-sub-header"><a href="/front/vue/#vue-nexttick-callback-context" class="sidebar-link">Vue.nextTick( [callback, context\] )</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/vue/#组件开发" class="sidebar-link">组件开发</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#组件注册" class="sidebar-link">组件注册</a></li><li class="sidebar-sub-header"><a href="/front/vue/#函数式组件" class="sidebar-link">函数式组件</a></li><li class="sidebar-sub-header"><a href="/front/vue/#组件间通信和传值" class="sidebar-link">组件间通信和传值</a></li><li class="sidebar-sub-header"><a href="/front/vue/#slot插槽" class="sidebar-link">slot插槽</a></li><li class="sidebar-sub-header"><a href="/front/vue/#动态组件" class="sidebar-link">动态组件</a></li><li class="sidebar-sub-header"><a href="/front/vue/#异步组件" class="sidebar-link">异步组件</a></li><li class="sidebar-sub-header"><a href="/front/vue/#处理边界情况" class="sidebar-link">处理边界情况</a></li><li class="sidebar-sub-header"><a href="/front/vue/#过渡" class="sidebar-link">过渡</a></li><li class="sidebar-sub-header"><a href="/front/vue/#mixin混入" class="sidebar-link">Mixin混入</a></li><li class="sidebar-sub-header"><a href="/front/vue/#高阶组件" class="sidebar-link">高阶组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/vue/#vuecss变量" class="sidebar-link">vuecss变量</a></li><li class="sidebar-sub-header"><a href="/front/vue/#修饰符-2" class="sidebar-link">修饰符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#表单修饰符" class="sidebar-link">表单修饰符</a></li><li class="sidebar-sub-header"><a href="/front/vue/#事件修饰符" class="sidebar-link">事件修饰符</a></li><li class="sidebar-sub-header"><a href="/front/vue/#鼠标按钮修饰符" class="sidebar-link">鼠标按钮修饰符</a></li><li class="sidebar-sub-header"><a href="/front/vue/#键值修饰符" class="sidebar-link">键值修饰符</a></li><li class="sidebar-sub-header"><a href="/front/vue/#v-bind修饰符" class="sidebar-link">v-bind修饰符</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/vue/#实用技巧" class="sidebar-link">实用技巧</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#动态指令参数" class="sidebar-link">动态指令参数</a></li><li class="sidebar-sub-header"><a href="/front/vue/#slots-新语法" class="sidebar-link">slots 新语法</a></li><li class="sidebar-sub-header"><a href="/front/vue/#hook那些事" class="sidebar-link">@hook那些事</a></li><li class="sidebar-sub-header"><a href="/front/vue/#vue中的-props、-attrs和-listeners-可用来二次封装组件" class="sidebar-link">vue中的$props、$attrs和$listeners(可用来二次封装组件)</a></li><li class="sidebar-sub-header"><a href="/front/vue/#响应式数据-2-6-0新增" class="sidebar-link">响应式数据(2.6.0新增)</a></li><li class="sidebar-sub-header"><a href="/front/vue/#jsx模板组件" class="sidebar-link">jsx模板组件</a></li><li class="sidebar-sub-header"><a href="/front/vue/#动态组件-2" class="sidebar-link">动态组件</a></li><li class="sidebar-sub-header"><a href="/front/vue/#vue-filter-2" class="sidebar-link">Vue.filter</a></li><li class="sidebar-sub-header"><a href="/front/vue/#sync-语法糖" class="sidebar-link">.sync 语法糖</a></li><li class="sidebar-sub-header"><a href="/front/vue/#利用-object-freeze-提升性能" class="sidebar-link">利用 object.freeze 提升性能</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/vue/#seo" class="sidebar-link">seo</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/vue/#预渲染" class="sidebar-link">预渲染</a></li></ul></li></ul></li><li><a href="/front/vue/ssr.html" class="sidebar-link">SSR</a></li><li><a href="/front/vue/untitled.html" class="sidebar-link">/front/vue/untitled.html</a></li><li><a href="/front/vue/axios.html" class="sidebar-link">axios</a></li><li><a href="/front/vue/mavoneditor.html" class="sidebar-link">mavonEditor</a></li><li><a href="/front/vue/que1.html" class="sidebar-link">Vue3有哪些不向下兼容的改变</a></li><li><a href="/front/vue/vue-cli.html" class="sidebar-link">vue-cli</a></li><li><a href="/front/vue/vue-router.html" class="sidebar-link">vue-router路由管理</a></li><li><a href="/front/vue/vue-rules.html" class="sidebar-link">风格指南</a></li><li><a href="/front/vue/vuex.html" class="sidebar-link">vuex状态管理</a></li><li><a href="/front/vue/xing-neng-you-hua.html" class="sidebar-link">Vue 性能优化</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>Vue 3</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Guide</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h1> <p>vue思维导图：</p> <img src="../../vue/vue.png"> <h2 id="基础原理"><a href="#基础原理" class="header-anchor">#</a> 基础原理</h2> <h3 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h3> <p>MVVM全称为：Model-View-View-Model，MVVM的核心是<code>数据驱动</code>即ViewModel，ViewModel是View和Model的<code>关系映射</code>。MVVM本质就是基于操作<code>数据</code>来操作<code>视图</code>进而操作<code>DOM</code>，借助于MVVM无需直接操作DOM，开发者只需编写ViewModel中有业务，使得View完全实现<code>自动化</code>。</p> <img src="https://user-gold-cdn.xitu.io/2020/7/29/1739a34c8305736d?imageView2/0/w/1280/h/960/ignore-error/1" alt="img" style="zoom:50%;"> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <p>Vue 实例从创建到销毁的过程，就是生命周期。<strong>初始化 (create)--- 组件挂载(mount)-----组件更新 (update)--- 销毁(destroy)</strong></p> <p>官方图片展示：</p> <img src="https://cn.vuejs.org/images/lifecycle.png" style="zoom:67%;"> <h4 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍：</h4> <ol><li><strong>beforeCreate</strong>是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法<code>都不能</code>被访问。</li> <li><strong>created</strong>在实例创建完成后发生，当前阶段已经完成了<code>数据观测</code>，也就是可以使用数据，更改数据，在这里更改数据不会触发<code>updated函数</code>。可以做一些初始数据的获取，在当前阶段<code>无法与Dom进行交互</code>，如果非要想，可以通过<code>vm.$nextTick</code>来访问Dom。</li> <li><strong>beforeMount</strong>发生在<code>挂载之前</code>，在这之前template模板已导入渲染函数编译。而当前阶段<code>虚拟Dom</code>已经创建完成，即将开始渲染。在此时也可以对数据进行更改，<code>不会触</code>发updated。</li> <li><strong>mounted</strong>在<code>挂载完成后</code>发生，在当前阶段，真实的Dom<code>挂载完毕</code>，数据完成双向绑定，可以访问到<code>Dom节点</code>，使用$refs属性对Dom进行操作。</li> <li><strong>beforeUpdate</strong>发生在<code>更新之前</code>，也就是响应式数据发生更新，虚拟dom<code>重新渲染之前</code>被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</li> <li><strong>updated</strong>发生在<code>更新完成之后</code>，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致<code>无限循环</code>的更新。</li> <li><strong>beforeDestroy</strong>发生在<code>实例销毁之前</code>，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器，销毁父组件对子组件的重复监听。beforeDestroy(){Bus.$off(&quot;saveTheme&quot;)}</li> <li><strong>destroyed</strong>发生在<code>实例销毁之后</code>，这个时候只剩下了<code>dom空壳</code>。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</li> <li><strong>activited</strong> keep-alive 专属 , 组件被激活时调用</li> <li><strong>deactivated</strong> keep-alive 专属 , 组件被销毁时调用</li></ol> <h4 id="生命周期调用顺序"><a href="#生命周期调用顺序" class="header-anchor">#</a> 生命周期调用顺序：</h4> <ul><li>组件的<code>调用</code>顺序都是先父后子</li> <li><code>渲染完成的</code>顺序是先子后父</li> <li>组件的<code>销毁</code>操作是先父后子</li> <li><code>销毁完成</code>的顺序是先子后父</li></ul> <blockquote><p><strong>加载渲染过程</strong> 父beforeCreate-&gt;父created-&gt;<code>父beforeMount</code>-&gt;<code>子beforeCreate</code>-&gt;子created-&gt;子beforeMount- &gt;子mounted-&gt;父mounted</p> <p><strong>子组件更新过程</strong> 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p> <p><strong>父组件更新过程</strong> 父 beforeUpdate -&gt; 父 updated</p> <p><strong>销毁过程</strong> 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p></blockquote> <h4 id="生命周期的作用"><a href="#生命周期的作用" class="header-anchor">#</a> 生命周期的作用：</h4> <p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会，使构建更加清晰。</p> <p>第一次加载触发钩子：beforeCreate, created, beforeMount, mounted</p> <h4 id="每个周期具体适合哪些场景"><a href="#每个周期具体适合哪些场景" class="header-anchor">#</a> 每个周期具体适合哪些场景</h4> <ul><li><code>beforecreate</code> : 可以在这加个loading事件，在加载实例时触发</li> <li><code>created</code> : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</li> <li><code>mounted</code> : 挂载元素，获取到DOM节点</li> <li><code>updated</code> : 如果对数据统一处理，在这里写上相应函数</li> <li><code>beforeDestroy</code> : 可以清除定时器</li> <li><code>nextTick</code> : 更新数据后立即操作dom</li></ul> <h4 id="初次渲染就会触发的生命周期"><a href="#初次渲染就会触发的生命周期" class="header-anchor">#</a> 初次渲染就会触发的生命周期</h4> <ul><li>beforeCreate() , created()</li> <li>beforeMount() , mounted()</li></ul> <h3 id="双向绑定"><a href="#双向绑定" class="header-anchor">#</a> 双向绑定</h3> <p>Vue 数据双向绑定主要是指：<strong>数据变化更新视图，视图变化更新数据</strong>。Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。通过数据劫持结合设计模式中的发布者-订阅者模式，主要包括以下步骤：</p> <ol><li>实现<em>监听器 Observer</em>（将数据data变成可观察（observable））： 通过 <code>Object.defineProperty()</code>设置属性的setter和getter来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者。</li> <li>添加订阅者Watcher：Watcher 订阅者是 <code>Observer 和 Compile 之间通信的桥梁</code> ，主要的任务是订阅 Observer 中的<code>属性值变化</code>的消息，当收到属性值变化的消息时，<code>触发解析器</code> Compile 中对应的更新函数。</li> <li>添加消息订阅器Dep（ 如果数据变化，通知所有订阅者）：订阅器采用 <code>发布-订阅 设计模式</code>，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li> <li>实现Compile：解析 Vue 模板指令，将模板中的<code>变量</code>都替换成<code>数据</code>，然后初始化渲染页面视图，并将每个<code>指令</code>对应的<code>节点</code>绑定<code>更新函数</code>，添加监听数据的订阅者，一旦数据有变动，收到通知，调用<code>更新函数进行数据更新</code>。</li></ol> <h3 id="vnode"><a href="#vnode" class="header-anchor">#</a> VNode</h3> <p>虚拟 DOM。Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。</p> <p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul> <p>虚拟dom的优缺点：</p> <p><strong>优点：</strong></p> <ul><li><em>保证性能下限：</em> 框架的虚拟 DOM 需要<code>适配任何上层 API</code> 可能产生的操作，它的一些 DOM 操作的实现必须<code>是普适的</code>，所以它的性能<code>并不是最优的</code>；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li><em>无需手动操作 DOM：</em> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据<code>虚拟 DOM 和 数据双向绑定</code>，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li><em>跨平台：</em> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul> <p><strong>缺点:</strong></p> <p><em>无法进行极致优化</em>： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p> <h3 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> NextTick()</h3> <p>nextTick目的是将回调函数的调用延迟到下一次dom更新数据后，换句话说就是修改数据后并不会立即更新dom ，因为dom的更新是异步的，无法通过同步代码获取，需要使用nextTick，在下一次事件循环中获取（Vue中Dom的更新是异步的）</p> <h3 id="template"><a href="#template" class="header-anchor">#</a> template</h3> <p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p> <p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p> <h4 id="插值"><a href="#插值" class="header-anchor">#</a> 插值</h4> <h5 id="文本"><a href="#文本" class="header-anchor">#</a> 文本</h5> <p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span>Message: {{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> property 的值。无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p> <p>通过使用 <a href="https://cn.vuejs.org/v2/api/#v-once" target="_blank" rel="noopener noreferrer">v-once 指令<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-once</span><span class="token punctuation">&gt;</span></span>这个将不会改变: {{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="原始html"><a href="#原始html" class="header-anchor">#</a> 原始Html</h5> <p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 <a href="https://cn.vuejs.org/v2/api/#v-html" target="_blank" rel="noopener noreferrer"><code>v-html</code> 指令<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Using mustaches: {{ rawHtml }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Using v-html directive: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">v-html</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>rawHtml<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h5 id="attribute"><a href="#attribute" class="header-anchor">#</a> Attribute</h5> <p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <a href="https://cn.vuejs.org/v2/api/#v-bind" target="_blank" rel="noopener noreferrer"><code>v-bind</code> 指令<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dynamicId<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同，在这个例子中：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>disabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>isButtonDisabled<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> attribute 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p> <h5 id="使用js表达式"><a href="#使用js表达式" class="header-anchor">#</a> 使用js表达式</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
&lt;div v-bind:id=&quot;'list-' + id&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="指令"><a href="#指令" class="header-anchor">#</a> 指令</h4> <p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在介绍中看到的例子：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>seen<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>现在你看到我了<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h5> <p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p> <p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="动态参数"><a href="#动态参数" class="header-anchor">#</a> 动态参数</h5> <blockquote><p>2.6.0 新增</p></blockquote> <p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--
注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。
--&gt;
&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p> <h6 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="header-anchor">#</a> 对动态参数的值的约束</h6> <p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p> <h6 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="header-anchor">#</a> 对动态参数表达式的约束</h6> <p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 这会触发一个编译警告 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>['foo'</span> <span class="token attr-name">+</span> <span class="token attr-name">bar]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p> <p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!--
在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。
除非在实例中有一个名为“someattr”的 property，否则代码不会工作。
--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>[someAttr]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h5> <p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name"><span class="token namespace">v-on:</span>submit.prevent</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onSubmit<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>事件修饰符</strong></p> <ol><li>.stop阻止事件冒泡，相当于调用了event.stopPropagation()方法</li> <li>.prevent阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件</li> <li>.self只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡。</li> <li>.once事件只能用一次，无论点击几次，执行一次之后都不会再执行。</li> <li>.keyCode监听按键的指令，具体可以查看vue的键码对应表</li> <li>.sync对prop进行双向绑定</li></ol> <p><strong>v-model修饰符</strong></p> <ol><li>.lazy输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据</li> <li>.trim输入框过滤首尾的空格</li> <li>.number先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是这个数据是数字</li></ol> <h4 id="缩写"><a href="#缩写" class="header-anchor">#</a> 缩写</h4> <h5 id="v-bind缩写"><a href="#v-bind缩写" class="header-anchor">#</a> v-bind缩写</h5> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 缩写 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">:[key]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>url<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="v-on缩写"><a href="#v-on缩写" class="header-anchor">#</a> v-on缩写</h5> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 完整语法 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 缩写 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">@[event]</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="class与style"><a href="#class与style" class="header-anchor">#</a> class与style</h4> <h5 id="绑定class"><a href="#绑定class" class="header-anchor">#</a> 绑定class</h5> <h6 id="对象语法"><a href="#对象语法" class="header-anchor">#</a> 对象语法</h6> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>{ active: isActive }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="数组语法"><a href="#数组语法" class="header-anchor">#</a> 数组语法</h6> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>[activeClass, errorClass]<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-js line-numbers-mode"><pre class="language-js"><code>data<span class="token operator">:</span> <span class="token punctuation">{</span>
  activeClass<span class="token operator">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span>
  errorClass<span class="token operator">:</span> <span class="token string">'text-danger'</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>三元表达式：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>[isActive ? activeClass : <span class="token punctuation">'</span><span class="token punctuation">'</span>, errorClass]<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>[{ active: isActive }, errorClass]<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="绑定内联样式"><a href="#绑定内联样式" class="header-anchor">#</a> 绑定内联样式</h5> <h6 id="对象语法-2"><a href="#对象语法-2" class="header-anchor">#</a> 对象语法</h6> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span></span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> activeColor<span class="token punctuation">,</span> <span class="token property">fontSize</span><span class="token punctuation">:</span> fontSize + <span class="token string">'px'</span> <span class="token punctuation">}</span></span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="数组语法-2"><a href="#数组语法-2" class="header-anchor">#</a> 数组语法</h6> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">v-bind:</span></span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value">[baseStyles<span class="token punctuation">,</span> overridingStyles]</span><span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h6 id="多重值"><a href="#多重值" class="header-anchor">#</a> 多重值</h6> <p>从 2.3.0 起你可以为 <code>style</code> 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div :style=&quot;{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 <code>display: flex</code>。</p> <h3 id="api"><a href="#api" class="header-anchor">#</a> API</h3> <h4 id="全局配置"><a href="#全局配置" class="header-anchor">#</a> 全局配置</h4> <h5 id="slient"><a href="#slient" class="header-anchor">#</a> slient</h5> <ul><li><p><strong>类型</strong>：<code>boolean</code></p></li> <li><p><strong>默认值</strong>：<code>false</code></p></li> <li><p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.silent = true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>取消 Vue 所有的日志与警告。</p></li></ul> <h5 id="optionmergestrategies"><a href="#optionmergestrategies" class="header-anchor">#</a> optionMergeStrategies</h5> <p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p> <p><strong>默认值</strong>：<code>{}</code></p> <p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
  return child + 1
}

const Profile = Vue.extend({
  _my_option: 1
})

// Profile.options._my_option = 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>自定义合并策略的选项。</p> <p>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。</p> <h5 id="devtools"><a href="#devtools" class="header-anchor">#</a> devtools</h5> <ul><li><p><strong>类型</strong>：<code>boolean</code></p></li> <li><p><strong>默认值</strong>：<code>true</code> (生产版为 <code>false</code>)</p></li> <li><p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 务必在加载 Vue 之后，立即同步设置以下内容
Vue.config.devtools = true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>配置是否允许 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener noreferrer">vue-devtools<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p></li></ul> <h5 id="errorhandler"><a href="#errorhandler" class="header-anchor">#</a> errorHandler</h5> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>默认值</strong>：<code>undefined</code></p> <p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.errorHandler = function (err, vm, info) {
  // handle error
  // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  // 只在 2.2.0+ 可用
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p> <blockquote><p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p></blockquote> <blockquote><p>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote> <blockquote><p>从 2.6.0 起，这个钩子也会捕获 <code>v-on</code> DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p></blockquote> <h5 id="warnhandler"><a href="#warnhandler" class="header-anchor">#</a> warnHandler</h5> <blockquote><p>2.4.0 新增</p></blockquote> <ul><li><p><strong>类型</strong>：<code>Function</code></p></li> <li><p><strong>默认值</strong>：<code>undefined</code></p></li> <li><p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.warnHandler = function (msg, vm, trace) {
  // `trace` 是组件的继承关系追踪
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。</p></li></ul> <h5 id="ignoredelements"><a href="#ignoredelements" class="header-anchor">#</a> ignoredElements</h5> <ul><li><p><strong>类型</strong>：<code>Array&lt;string | RegExp&gt;</code></p></li> <li><p><strong>默认值</strong>：<code>[]</code></p></li> <li><p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.ignoredElements = [
  'my-custom-web-component',
  'another-web-component',
  // 用一个 `RegExp` 忽略所有“ion-”开头的元素
  // 仅在 2.5+ 支持
  /^ion-/
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p></li></ul> <h5 id="keycodes"><a href="#keycodes" class="header-anchor">#</a> keyCodes</h5> <ul><li><p><strong>类型</strong>：<code>{ [key: string]: number | Array&lt;number&gt; }</code></p></li> <li><p><strong>默认值</strong>：<code>{}</code></p></li> <li><p><strong>用法</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.config.keyCodes = {
  v: 86,
  f1: 112,
  // camelCase 不可用
  mediaPlayPause: 179,
  // 取而代之的是 kebab-case 且用双引号括起来
  &quot;media-play-pause&quot;: 179,
  up: [38, 87]
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>给 <code>v-on</code> 自定义键位别名。</p></li></ul> <h5 id="performance"><a href="#performance" class="header-anchor">#</a> performance</h5> <blockquote><p>2.2.0 新增</p></blockquote> <ul><li><p><strong>类型</strong>：<code>boolean</code></p></li> <li><p><strong>默认值</strong>：<code>false (自 2.2.3 起)</code></p></li> <li><p><strong>用法</strong>：</p> <p>设置为 <code>true</code> 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark" target="_blank" rel="noopener noreferrer"><code>performance.mark</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> API 的浏览器上。</p></li></ul> <h5 id="productiontip"><a href="#productiontip" class="header-anchor">#</a> productionTip</h5> <blockquote><p>2.2.0 新增</p></blockquote> <ul><li><p><strong>类型</strong>：<code>boolean</code></p></li> <li><p><strong>默认值</strong>：<code>true</code></p></li> <li><p><strong>用法</strong>：</p> <p>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</p></li></ul> <h4 id="全局api"><a href="#全局api" class="header-anchor">#</a> 全局API</h4> <h5 id="vue-extend"><a href="#vue-extend" class="header-anchor">#</a> Vue.extend()</h5> <p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 创建构造器</span>
<span class="token keyword">var</span> Profile <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token string">'&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;'</span><span class="token punctuation">,</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      firstName<span class="token operator">:</span> <span class="token string">'Walter'</span><span class="token punctuation">,</span>
      lastName<span class="token operator">:</span> <span class="token string">'White'</span><span class="token punctuation">,</span>
      alias<span class="token operator">:</span> <span class="token string">'Heisenberg'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 创建 Profile 实例，并挂载到一个元素上。</span>
<span class="token keyword">new</span> <span class="token class-name">Profile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#mount-point'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h5 id="vue-nexttick"><a href="#vue-nexttick" class="header-anchor">#</a> Vue.nextTick()</h5> <blockquote><h3 id="vue-nexttick-callback-context"><a href="#vue-nexttick-callback-context" class="header-anchor">#</a> [Vue.nextTick( <a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener noreferrer">callback, context] )<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3></blockquote> <p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})
// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
  .then(function () {
    // DOM 更新了
  })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h5 id="vue-set"><a href="#vue-set" class="header-anchor">#</a> Vue.set()</h5> <ul><li><p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li> <li><code>{any} value</code></li></ul></li> <li><p><strong>返回值</strong>：设置的值。</p></li> <li><p><strong>用法</strong>：</p> <p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>this.myObject.newProperty = 'hi'</code>)</p> <p>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p></li></ul> <h5 id="vue-delete"><a href="#vue-delete" class="header-anchor">#</a> Vue.delete()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul> <blockquote><p>仅在 2.2.0+ 版本中支持 Array + index 用法。</p></blockquote> <p><strong>用法</strong>：</p> <p>删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。</p> <blockquote><p>在 2.2.0+ 中同样支持在数组上工作。</p></blockquote> <p>目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p> <h5 id="vue-directive"><a href="#vue-directive" class="header-anchor">#</a> Vue.directive</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul> <p><strong>用法</strong>：</p> <p>注册或获取全局指令。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册
Vue.directive('my-directive', {
  bind: function () {},
  inserted: function () {},
  update: function () {},
  componentUpdated: function () {},
  unbind: function () {}
})
// 注册 (指令函数)
Vue.directive('my-directive', function () {
  // 这里将会被 `bind` 和 `update` 调用
})
// getter，返回已注册的指令
var myDirective = Vue.directive('my-directive')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h5 id="vue-filter"><a href="#vue-filter" class="header-anchor">#</a> Vue.filter()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string} id</code></li> <li><code>{Function} [definition]</code></li></ul> <p><strong>用法</strong>：</p> <p>注册或获取全局过滤器。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册
Vue.filter('my-filter', function (value) {
  // 返回处理后的值
})
// getter，返回已注册的过滤器
var myFilter = Vue.filter('my-filter')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="vue-component"><a href="#vue-component" class="header-anchor">#</a> Vue.component()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string} id</code></li> <li><code>{Function | Object} [definition]</code></li></ul> <p><strong>用法</strong>：</p> <p>注册或获取全局组件。注册还会自动使用给定的 <code>id</code> 设置组件的名称。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 注册组件，传入一个扩展过的构造器
Vue.component('my-component', Vue.extend({ /* ... */ }))
// 注册组件，传入一个选项对象 (自动调用 Vue.extend)
Vue.component('my-component', { /* ... */ })
// 获取注册的组件 (始终返回构造器)
var MyComponent = Vue.component('my-component')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="vue-use"><a href="#vue-use" class="header-anchor">#</a> Vue.use()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Object | Function} plugin</code></li></ul> <p><strong>用法</strong>：</p> <p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p> <p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p> <p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p> <h5 id="vue-mixin"><a href="#vue-mixin" class="header-anchor">#</a> Vue.mixin()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Object} mixin</code></li></ul> <p><strong>用法</strong>：</p> <p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混入，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p> <h5 id="vue-compile"><a href="#vue-compile" class="header-anchor">#</a> Vue.compile()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string} template</code></li></ul> <p><strong>用法</strong>：</p> <p>将一个模板字符串编译成 render 函数。<strong>只在完整版时可用</strong>。</p> <h5 id="vue-observable"><a href="#vue-observable" class="header-anchor">#</a> Vue.observable()</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Object} object</code></li></ul> <p><strong>用法</strong>：</p> <p>让一个对象可响应。Vue 内部会用它来处理 <code>data</code> 函数返回的对象。</p> <p>返回的对象可以直接用于<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener noreferrer">渲染函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://cn.vuejs.org/v2/guide/computed.html" target="_blank" rel="noopener noreferrer">计算属性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> Demo <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      on<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function-variable function">click</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> state<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="vue-version"><a href="#vue-version" class="header-anchor">#</a> Vue.version</h5> <p><strong>细节</strong>：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。</p> <p><strong>用法:</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> version <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>Vue<span class="token punctuation">.</span>version<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>version <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vue v2.x.x</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>version <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Vue v1.x.x</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// Unsupported versions of Vue</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="选项"><a href="#选项" class="header-anchor">#</a> 选项</h4> <h5 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h5> <h6 id="data"><a href="#data" class="header-anchor">#</a> data</h6> <p><strong>类型</strong>：<code>Object | Function</code></p> <p><strong>限制</strong>：组件的定义只接受 <code>function</code>。</p> <p><strong>详细</strong>：Vue 实例的数据对象。Vue 将会递归将 data 的 property 转换为 getter/setter，从而让 data 的 property 能够响应数据变化。<strong>对象必须是纯粹的对象 (含有零个或多个的 key/value 对)</strong>：浏览器 API 创建的原生对象，原型上的 property 会被忽略。当一个<strong>组件</strong>被定义，<code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。</p> <h6 id="props"><a href="#props" class="header-anchor">#</a> props</h6> <p><strong>类型</strong>：<code>Array&lt;string&gt; | Object</code></p> <p><strong>详细</strong>：</p> <p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p> <p>基于对象的语法使用以下选项：</p> <ul><li><code>type</code>：可以是下列原生构造函数中的一种：<code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code>、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">更多信息在此<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</li> <li><code>default</code>：<code>any</code>
为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。</li> <li><code>required</code>：<code>Boolean</code>
定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。</li> <li><code>validator</code>：<code>Function</code></li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 简单语法</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'props-demo-simple'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'size'</span><span class="token punctuation">,</span> <span class="token string">'myMessage'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 对象语法，提供验证</span>
Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'props-demo-advanced'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 检测类型</span>
    height<span class="token operator">:</span> Number<span class="token punctuation">,</span>
    <span class="token comment">// 检测类型 + 其他验证</span>
    age<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      required<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token function-variable function">validator</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">&gt;=</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h6 id="propsdata"><a href="#propsdata" class="header-anchor">#</a> propsData</h6> <h6 id="computed"><a href="#computed" class="header-anchor">#</a> computed</h6> <p><strong>类型</strong>：<code>{ [key: string]: Function | { get: Function, set: Function } }</code></p> <p><strong>详细</strong>：</p> <p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>注意如果你为一个计算属性使用了箭头函数，则 <code>this</code> 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。</p></div> <div class="language- line-numbers-mode"><pre class="language-text"><code>computed: {
  aDouble: vm =&gt; vm.a * 2
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>计算属性的结果会被缓存，除非依赖的响应式 property 变化才会重新计算。注意，如果某个依赖 (比如非响应式 property) 在该实例范畴之外，则计算属性是<strong>不会</strong>被更新的。</p> <p><strong>示例</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仅读取</span>
    <span class="token function-variable function">aDouble</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 读取和设置</span>
    aPlus<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> v <span class="token operator">-</span> <span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
vm<span class="token punctuation">.</span>aPlus   <span class="token comment">// =&gt; 2</span>
vm<span class="token punctuation">.</span>aPlus <span class="token operator">=</span> <span class="token number">3</span>
vm<span class="token punctuation">.</span>a       <span class="token comment">// =&gt; 2</span>
vm<span class="token punctuation">.</span>aDouble <span class="token comment">// =&gt; 4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h6 id="methods"><a href="#methods" class="header-anchor">#</a> methods</h6> <p><strong>类型</strong>：<code>{ [key: string]: Function }</code></p> <p><strong>详细</strong>：</p> <p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p> <p>注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var vm = new Vue({
  data: { a: 1 },
  methods: {
    plus: function () {//或plus(){}
      this.a++
    }
  }
})
vm.plus()
vm.a // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h6 id="watch"><a href="#watch" class="header-anchor">#</a> watch</h6> <p><strong>类型</strong>：<code>{ [key: string]: string | Function | Object | Array }</code></p> <p><strong>详细</strong>：</p> <p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个 property。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var vm = new Vue({
  data: {
    a: 1,
    b: 2,
    c: 3,
    d: 4,
    e: {
      f: {
        g: 5
      }
    }
  },
  watch: {
    a: function (val, oldVal) {
      console.log('new: %s, old: %s', val, oldVal)
    },
    // 方法名
    b: 'someMethod',
    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深
    c: {
      handler: function (val, oldVal) { /* ... */ },
      deep: true
    },
    // 该回调将会在侦听开始之后被立即调用
    d: {
      handler: 'someMethod',
      immediate: true
    },
    // 你可以传入回调数组，它们会被逐一调用
    e: [
      'handle1',
      function handle2 (val, oldVal) { /* ... */ },
      {
        handler: function handle3 (val, oldVal) { /* ... */ },
        /* ... */
      }
    ],
    // watch vm.e.f's value: {g: 5}
    'e.f': function (val, oldVal) { /* ... */ }
  }
})
vm.a = 2 // =&gt; new: 2, old: 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p> <h5 id="dom"><a href="#dom" class="header-anchor">#</a> DOM</h5> <h6 id="el"><a href="#el" class="header-anchor">#</a> el</h6> <p><strong>类型</strong>：<code>string | Element</code></p> <p><strong>限制</strong>：只在用 <code>new</code> 创建实例时生效。</p> <p><strong>详细</strong>：</p> <p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p> <p>在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。</p> <p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p> <h6 id="template-2"><a href="#template-2" class="header-anchor">#</a> template</h6> <p><strong>类型</strong>：<code>string</code></p> <p><strong>详细</strong>：</p> <p>一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p> <p>如果值以 <code>#</code> 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p> <h6 id="render"><a href="#render" class="header-anchor">#</a> render</h6> <p><strong>类型</strong>：<code>(createElement: () =&gt; VNode) =&gt; VNode</code></p> <p><strong>详细</strong>：</p> <p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p> <p>如果组件是一个函数组件，渲染函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p> <h6 id="rendererror"><a href="#rendererror" class="header-anchor">#</a> renderError</h6> <p>2.2.0 新增</p> <p><strong>类型</strong>：<code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p> <p><strong>详细</strong>：</p> <p><strong>只在开发者环境下工作。</strong></p> <p>当 <code>render</code> 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 <code>renderError</code>。这个功能配合 hot-reload 非常实用。</p> <p><strong>示例</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span><span class="token parameter">h</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'oops'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">renderError</span> <span class="token punctuation">(</span><span class="token parameter">h<span class="token punctuation">,</span> err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'pre'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> style<span class="token operator">:</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span>stack<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="生命周期钩子"><a href="#生命周期钩子" class="header-anchor">#</a> 生命周期钩子</h5> <h6 id="beforecreate"><a href="#beforecreate" class="header-anchor">#</a> beforeCreate</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p> <h6 id="create"><a href="#create" class="header-anchor">#</a> create</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> property 目前尚不可用。</p> <h6 id="beforemount"><a href="#beforemount" class="header-anchor">#</a> beforeMount</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p> <p><strong>该钩子在服务器端渲染期间不被调用。</strong></p> <h6 id="mounted"><a href="#mounted" class="header-anchor">#</a> mounted</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>实例被挂载后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换了。如果根实例挂载到了一个文档内的元素上，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。<strong>该钩子在服务器端渲染期间不被调用。</strong></p> <p>注意 <code>mounted</code> <strong>不会</strong>保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 <code>mounted</code> 内部使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener noreferrer">vm.$nextTick<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="beforeupdate"><a href="#beforeupdate" class="header-anchor">#</a> beforeUpdate</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p> <p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p> <h6 id="updated"><a href="#updated" class="header-anchor">#</a> updated</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p> <p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用<a href="https://cn.vuejs.org/v2/api/#computed" target="_blank" rel="noopener noreferrer">计算属性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>或 <a href="https://cn.vuejs.org/v2/api/#watch" target="_blank" rel="noopener noreferrer">watcher<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 取而代之。<strong>该钩子在服务器端渲染期间不被调用。</strong></p> <p>注意 <code>updated</code> <strong>不会</strong>保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 <code>updated</code> 里使用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener noreferrer">vm.$nextTick<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>updated: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been re-rendered
  })
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="activated"><a href="#activated" class="header-anchor">#</a> activated</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>被 keep-alive 缓存的组件激活时调用。</p> <p><strong>该钩子在服务器端渲染期间不被调用。</strong></p> <h6 id="deactivated"><a href="#deactivated" class="header-anchor">#</a> deactivated</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>被 keep-alive 缓存的组件停用时调用。</p> <p><strong>该钩子在服务器端渲染期间不被调用。</strong></p> <h6 id="beforedestroy"><a href="#beforedestroy" class="header-anchor">#</a> beforeDestroy</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>实例销毁之前调用。在这一步，实例仍然完全可用。</p> <p><strong>该钩子在服务器端渲染期间不被调用。</strong></p> <h6 id="destroyed"><a href="#destroyed" class="header-anchor">#</a> destroyed</h6> <p><strong>类型</strong>：<code>Function</code></p> <p><strong>详细</strong>：</p> <p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p> <p><strong>该钩子在服务器端渲染期间不被调用。</strong></p> <h6 id="errorcaptured"><a href="#errorcaptured" class="header-anchor">#</a> errorCaptured</h6> <p>2.5.0+ 新增</p> <p><strong>类型</strong>：<code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p> <p><strong>详细</strong>：</p> <p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 <code>false</code> 以阻止该错误继续向上传播。</p> <h5 id="资源"><a href="#资源" class="header-anchor">#</a> 资源</h5> <h6 id="directives"><a href="#directives" class="header-anchor">#</a> directives</h6> <ul><li><strong>类型</strong>：<code>Object</code></li> <li><strong>详细</strong>：</li></ul> <p>包含 Vue 实例可用指令的哈希表。</p> <h6 id="filters"><a href="#filters" class="header-anchor">#</a> filters</h6> <ul><li><strong>类型</strong>：<code>Object</code></li> <li><strong>详细</strong>：</li></ul> <p>包含 Vue 实例可用过滤器的哈希表。</p> <h6 id="components"><a href="#components" class="header-anchor">#</a> components</h6> <ul><li><strong>类型</strong>：<code>Object</code></li> <li><strong>详细</strong>：</li></ul> <p>包含 Vue 实例可用组件的哈希表。</p> <h5 id="组合"><a href="#组合" class="header-anchor">#</a> 组合</h5> <h6 id="parent"><a href="#parent" class="header-anchor">#</a> parent</h6> <p><strong>类型</strong>：<code>Vue instance</code></p> <p><strong>详细</strong>：</p> <p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p> <h6 id="mixins"><a href="#mixins" class="header-anchor">#</a> mixins</h6> <p><strong>类型</strong>：<code>Array&lt;Object&gt;</code></p> <p><strong>详细</strong>：</p> <p><code>mixins</code> 选项接收一个混入对象的数组。这些混入对象可以像正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中，使用的是和 <code>Vue.extend()</code> 一样的选项合并逻辑。也就是说，如果你的混入包含一个 created 钩子，而创建组件本身也有一个，那么两个函数都会被调用。</p> <p>Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</p> <p><strong>示例</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">created</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; 1</span>
<span class="token comment">// =&gt; 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h6 id="extends"><a href="#extends" class="header-anchor">#</a> extends</h6> <p><strong>类型</strong>：<code>Object | Function</code></p> <p><strong>详细</strong>：</p> <p>允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p> <p>这和 <code>mixins</code> 类似。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var CompA = { ... }
// 在没有调用 `Vue.extend` 时候继承 CompA
var CompB = {
  extends: CompA,
  ...
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h6 id="provide-inject"><a href="#provide-inject" class="header-anchor">#</a> provide / inject</h6> <p>2.2.0 新增</p> <p><strong>类型</strong>：</p> <ul><li><strong>provide</strong>：<code>Object | () =&gt; Object</code></li> <li><strong>inject</strong>：<code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li></ul> <p><strong>详细</strong>：<code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p> <h5 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h5> <h6 id="name"><a href="#name" class="header-anchor">#</a> name</h6> <ul><li><p><strong>类型</strong>：<code>string</code></p></li> <li><p><strong>限制</strong>：只有作为组件选项时起作用。</p></li> <li><p><strong>详细</strong>：</p> <p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p> <p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="noopener noreferrer">vue-devtools<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>，这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p></li></ul> <h6 id="delimiters"><a href="#delimiters" class="header-anchor">#</a> delimiters</h6> <ul><li><p><strong>类型</strong>：<code>Array&lt;string&gt;</code></p></li> <li><p><strong>默认值</strong>：<code>[&quot;, &quot;]</code></p></li> <li><p><strong>限制</strong>：这个选项只在完整构建版本中的浏览器内编译时可用。</p></li> <li><p><strong>详细</strong>：</p> <p>改变纯文本插入分隔符。</p></li> <li><p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
  delimiters: ['${', '}']
})
// 分隔符变成了 ES6 模板字符串的风格
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <h6 id="functional"><a href="#functional" class="header-anchor">#</a> functional</h6> <p><strong>类型</strong>：<code>boolean</code></p> <p><strong>详细</strong>：</p> <p>使组件无状态 (没有 <code>data</code>) 和无实例 (没有 <code>this</code> 上下文)。他们用一个简单的 <code>render</code> 函数返回虚拟节点使它们渲染的代价更小。</p> <h6 id="model"><a href="#model" class="header-anchor">#</a> model</h6> <p>2.2.0 新增</p> <p><strong>类型</strong>：<code>{ prop?: string, event?: string }</code></p> <p><strong>详细</strong>：</p> <p>允许一个自定义组件在使用 <code>v-model</code> 时定制 prop 和 event。默认情况下，一个组件上的 <code>v-model</code> 会把 <code>value</code> 用作 prop 且把 <code>input</code> 用作 event，但是一些输入类型比如单选框和复选框按钮可能想使用 <code>value</code> prop 来达到不同的目的。使用 <code>model</code> 选项可以回避这些情况产生的冲突。</p> <p><strong>Example</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-checkbox'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">'checked'</span><span class="token punctuation">,</span>
    event<span class="token operator">:</span> <span class="token string">'change'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// this allows using the `value` prop for a different purpose</span>
    value<span class="token operator">:</span> String<span class="token punctuation">,</span>
    <span class="token comment">// use `checked` as the prop which take the place of `value`</span>
    checked<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-checkbox</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>some value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-checkbox</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>上述代码相当于：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-checkbox</span>
  <span class="token attr-name">:checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>val =&gt; { foo = val }<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>some value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-checkbox</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h6 id="inheritattrs"><a href="#inheritattrs" class="header-anchor">#</a> inheritAttrs</h6> <h6 id="comments"><a href="#comments" class="header-anchor">#</a> comments</h6> <p>设置comments属性，官网默认为舍弃注释。注释必须位于要保留的根元素内。comments设为true，默认false，设为true之后将会保留且渲染模块中的HTML注释，
comments: true 属性不适于单文件属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template comments&gt;
&lt;!--我是注释内容--&gt;
&lt;/template&gt;
&lt;template comments&gt;
	&lt;div&gt;
		&lt;!--我是注释内容--&gt;
	&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
    comments: true;
}
&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="实例property"><a href="#实例property" class="header-anchor">#</a> 实例Property</h4> <h5 id="vm-data"><a href="#vm-data" class="header-anchor">#</a> vm.$data</h5> <ul><li><p><strong>类型</strong>：<code>Object</code></p></li> <li></li> <li><p><strong>详细</strong>：</p> <p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。</p></li> <li><p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/api/#data" target="_blank" rel="noopener noreferrer">选项 / 数据 - data<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h5 id="vm-props"><a href="#vm-props" class="header-anchor">#</a> vm.$props</h5> <p>2.2.0 新增</p> <ul><li><p><strong>类型</strong>：<code>Object</code></p></li> <li><p><strong>详细</strong>：</p> <p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。</p></li></ul> <h5 id="vm-el"><a href="#vm-el" class="header-anchor">#</a> vm.$el</h5> <h5 id="vm-options"><a href="#vm-options" class="header-anchor">#</a> vm.$options</h5> <h5 id="vm-parent"><a href="#vm-parent" class="header-anchor">#</a> vm.$parent</h5> <h5 id="vm-root"><a href="#vm-root" class="header-anchor">#</a> vm.$root</h5> <h5 id="vm-children"><a href="#vm-children" class="header-anchor">#</a> vm.$children</h5> <h5 id="vm-slots"><a href="#vm-slots" class="header-anchor">#</a> vm.$slots</h5> <h5 id="vm-scopedslots"><a href="#vm-scopedslots" class="header-anchor">#</a> vm.$scopedSlots</h5> <h5 id="vm-refs"><a href="#vm-refs" class="header-anchor">#</a> vm.$refs</h5> <p><strong>类型</strong>：<code>Object</code></p> <p><strong>只读</strong></p> <p><strong>详细</strong>：</p> <p>一个对象，持有注册过 <a href="https://cn.vuejs.org/v2/api/#ref" target="_blank" rel="noopener noreferrer"><code>ref</code> attribute<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的所有 DOM 元素和组件实例。</p> <h5 id="vm-isserver"><a href="#vm-isserver" class="header-anchor">#</a> vm.$isServer</h5> <h5 id="vm-attrs"><a href="#vm-attrs" class="header-anchor">#</a> vm.$attrs</h5> <h5 id="vm-listeners"><a href="#vm-listeners" class="header-anchor">#</a> vm.$listeners</h5> <h4 id="实例方法-数据"><a href="#实例方法-数据" class="header-anchor">#</a> 实例方法/数据</h4> <h5 id="vm-watch"><a href="#vm-watch" class="header-anchor">#</a> vm.$watch</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string | Function} expOrFn</code></li> <li><code>{Function | Object} callback</code></li> <li>{Object} [options]
<ul><li><code>{boolean} deep</code></li> <li><code>{boolean} immediate</code></li></ul></li></ul> <p><strong>返回值</strong>：<code>{Function} unwatch</code></p> <p><strong>用法</strong>：</p> <p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。表达式只接受简单的键路径。对于更复杂的表达式，用一个函数取代。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 键路径
vm.$watch('a.b.c', function (newVal, oldVal) {
  // 做点什么
})
// 函数
vm.$watch(
  function () {
    // 表达式 `this.a + this.b` 每次得出一个不同的结果时
    // 处理函数都会被调用。
    // 这就像监听一个未被定义的计算属性
    return this.a + this.b
  },
  function (newVal, oldVal) {
    // 做点什么
  }
)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var unwatch = vm.$watch('a', cb)
// 之后取消观察
unwatch()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>选项：deep</strong></p> <p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code>。注意监听数组的变更不需要这么做。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch('someObject', callback, {
  deep: true
})
vm.someObject.nestedValue = 123
// callback is fired
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>选项：immediate</strong></p> <p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>vm.$watch('a', callback, {
  immediate: true
})
// 立即以 `a` 的当前值触发回调
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h5 id="vm-set"><a href="#vm-set" class="header-anchor">#</a> vm.$set</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li> <li><code>{any} value</code></li></ul> <p><strong>返回值</strong>：设置的值。</p> <p><strong>用法</strong>：</p> <p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p> <h5 id="vm-delete"><a href="#vm-delete" class="header-anchor">#</a> vm.$delete</h5> <p><strong>数</strong>：</p> <ul><li><code>{Object | Array} target</code></li> <li><code>{string | number} propertyName/index</code></li></ul> <p><strong>用法</strong>：</p> <p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p> <p><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/api/#Vue-delete" target="_blank" rel="noopener noreferrer">Vue.delete<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="实例方法-事件"><a href="#实例方法-事件" class="header-anchor">#</a> 实例方法/事件</h4> <h5 id="vm-on"><a href="#vm-on" class="header-anchor">#</a> vm.$on</h5> <ul><li><p><strong>参数</strong>：</p> <ul><li><code>{string | Array&lt;string&gt;} event</code> (数组只在 2.2.0+ 中支持)</li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>用法</strong>：</p> <p>监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p></li> <li><p><strong>示例</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>vm<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
vm<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'hi'</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; &quot;hi&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ul> <h5 id="vm-once"><a href="#vm-once" class="header-anchor">#</a> vm.$once</h5> <ul><li><p><strong>参数</strong>：</p> <ul><li><code>{string} event</code></li> <li><code>{Function} callback</code></li></ul></li> <li><p><strong>用法</strong>：</p> <p>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p></li></ul> <h5 id="vm-off"><a href="#vm-off" class="header-anchor">#</a> vm.$off</h5> <ul><li><p><strong>参数</strong>：</p> <ul><li><code>{string | Array&lt;string&gt;} event</code> (只在 2.2.2+ 支持数组)</li> <li><code>{Function} [callback]</code></li></ul></li> <li><p><strong>用法</strong>：</p> <p>移除自定义事件监听器。</p> <ul><li>如果没有提供参数，则移除所有的事件监听器；</li> <li>如果只提供了事件，则移除该事件所有的监听器；</li> <li>如果同时提供了事件与回调，则只移除这个回调的监听器。</li></ul></li></ul> <h5 id="vm-emit"><a href="#vm-emit" class="header-anchor">#</a> vm.$emit</h5> <p><strong>参数</strong>：</p> <ul><li><code>{string} eventName</code></li> <li><code>[...args]</code></li></ul> <p>触发当前实例上的事件。附加参数都会传给监听器回调。</p> <p><strong>示例：</strong></p> <p>只配合一个事件名使用 <code>$emit</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component('welcome-button', {
  template: `
    &lt;button v-on:click=&quot;$emit('welcome')&quot;&gt;
      Click me to be welcomed
    &lt;/button&gt;
  `
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;emit-example-simple&quot;&gt;
  &lt;welcome-button v-on:welcome=&quot;sayHi&quot;&gt;&lt;/welcome-button&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
  el: '#emit-example-simple',
  methods: {
    sayHi: function () {
      alert('Hi!')
    }
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>配合额外的参数使用 <code>$emit</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component('magic-eight-ball', {
  data: function () {
    return {
      possibleAdvice: ['Yes', 'No', 'Maybe']
    }
  },
  methods: {
    giveAdvice: function () {
      var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)
      this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])
    }
  },
  template: `
    &lt;button v-on:click=&quot;giveAdvice&quot;&gt;
      Click me for advice
    &lt;/button&gt;
  `
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div id=&quot;emit-example-argument&quot;&gt;
  &lt;magic-eight-ball v-on:give-advice=&quot;showAdvice&quot;&gt;&lt;/magic-eight-ball&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
  el: '#emit-example-argument',
  methods: {
    showAdvice: function (advice) {
      alert(advice)
    }
  }
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="实例方法-生命周期"><a href="#实例方法-生命周期" class="header-anchor">#</a> 实例方法/生命周期</h4> <h5 id="vm-mount"><a href="#vm-mount" class="header-anchor">#</a> vm.$mount</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Element | string} [elementOrSelector]</code></li> <li><code>{boolean} [hydrating]</code></li></ul> <p><strong>返回值</strong>：<code>vm</code> - 实例自身</p> <p><strong>用法</strong>：</p> <p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p> <p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生 DOM API 把它插入文档中。</p> <p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var MyComponent = Vue.extend({
  template: '&lt;div&gt;Hello!&lt;/div&gt;'
})
// 创建并挂载到 #app (会替换 #app)
new MyComponent().$mount('#app')
// 同上
new MyComponent({ el: '#app' })
// 或者，在文档之外渲染并且随后挂载
var component = new MyComponent().$mount()
document.getElementById('app').appendChild(component.$el)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="vm-forceupdate"><a href="#vm-forceupdate" class="header-anchor">#</a> vm.$forceUpdate</h5> <h5 id="vm-nexttick"><a href="#vm-nexttick" class="header-anchor">#</a> vm.$nextTick</h5> <p><strong>参数</strong>：</p> <ul><li><code>{Function} [callback]</code></li></ul> <p><strong>用法</strong>：</p> <p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 <code>Vue.nextTick</code> 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p> <blockquote><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不是原生支持 Promise (IE：你们都看我干嘛)，你得自行 polyfill。</p></blockquote> <p><strong>示例</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function-variable function">example</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 修改数据</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'changed'</span>
      <span class="token comment">// DOM 还没有更新</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// DOM 现在更新了</span>
        <span class="token comment">// `this` 绑定到当前实例</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h5 id="vm-destroy"><a href="#vm-destroy" class="header-anchor">#</a> vm.$destroy</h5> <p><strong>用法</strong>：</p> <p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p> <p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p> <p>在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p> <h4 id="指令-2"><a href="#指令-2" class="header-anchor">#</a> 指令</h4> <h5 id="v-text"><a href="#v-text" class="header-anchor">#</a> v-text</h5> <p><strong>预期</strong>：<code>string</code></p> <p><strong>详细</strong>：</p> <p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code>，需要使用 <code></code> 插值。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;
&lt;!-- 和下面的一样 --&gt;
&lt;span&gt;{{msg}}&lt;/span&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="v-html"><a href="#v-html" class="header-anchor">#</a> v-html</h5> <p><strong>预期</strong>：<code>string</code></p> <p><strong>详细</strong>：</p> <p>更新元素的 <code>innerHTML</code>。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong>。如果试图使用 <code>v-html</code> 组合模板，可以重新考虑是否通过使用组件来替代。</p> <p>在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">XSS 攻击<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p> <h5 id="v-show"><a href="#v-show" class="header-anchor">#</a> v-show</h5> <p><strong>预期</strong>：<code>any</code></p> <p><strong>用法</strong>：</p> <p>根据表达式之真假值，切换元素的 <code>display</code> CSS property。</p> <p>当条件变化时该指令触发过渡效果。</p> <h5 id="v-if"><a href="#v-if" class="header-anchor">#</a> v-if</h5> <p><strong>预期</strong>：<code>any</code></p> <p><strong>用法</strong>：</p> <p>根据表达式的值的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener noreferrer">truthiness<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code>，将提出它的内容作为条件块。</p> <p>当条件变化时该指令触发过渡效果。</p> <h5 id="v-else"><a href="#v-else" class="header-anchor">#</a> v-else</h5> <p><strong>不需要表达式</strong></p> <p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p> <p><strong>用法</strong>：</p> <p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加“else 块”。</p> <h5 id="v-else-if"><a href="#v-else-if" class="header-anchor">#</a> v-else-if</h5> <blockquote><p>2.1.0 新增</p></blockquote> <ul><li><p><strong>类型</strong>：<code>any</code></p></li> <li><p><strong>限制</strong>：前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p></li> <li><p><strong>用法</strong>：</p> <p>表示 <code>v-if</code> 的“else if 块”。可以链式调用。</p></li></ul> <h5 id="v-for"><a href="#v-for" class="header-anchor">#</a> v-for</h5> <p><strong>预期</strong>：<code>Array | Object | number | string | Iterable (2.6 新增)</code></p> <p><strong>用法</strong>：</p> <p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code>，为当前遍历的元素提供别名：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;item in items&quot;&gt;
  {{ item.text }}
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>另外也可以为数组索引指定别名 (或者用于对象的键)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;(item, index) in items&quot;&gt;&lt;/div&gt;
&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;
&lt;div v-for=&quot;(val, name, index) in object&quot;&gt;&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>v-for</code> 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute <code>key</code> 来提供一个排序提示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
  {{ item.text }}
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>从 2.6 起，<code>v-for</code> 也可以在实现了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">可迭代协议<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的值上使用，包括原生的 <code>Map</code> 和 <code>Set</code>。不过应该注意的是 Vue 2.x 目前并不支持可响应的 <code>Map</code> 和 <code>Set</code> 值，所以无法自动探测变更。当和 <code>v-if</code> 一起使用时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高。</p> <h5 id="v-on"><a href="#v-on" class="header-anchor">#</a> v-on</h5> <p><strong>缩写</strong>：<code>@</code></p> <p><strong>预期</strong>：<code>Function | Inline Statement | Object</code></p> <p><strong>参数</strong>：<code>event</code></p> <p><strong>修饰符</strong>：</p> <ul><li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。阻止事件冒泡，相当于调用了event.stopPropagation()方法：</li> <li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。阻止默认行为，相当于调用了event.preventDefault()方法，比如表单的提交、a标签的跳转就是默认事件：</li> <li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li> <li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算是阻止冒泡：</li> <li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li> <li><code>.native</code> - 监听组件根元素的原生事件。</li> <li><code>.once</code> - 只触发一次回调。事件只能用一次，无论点击几次，执行一次之后都不会再执行。</li> <li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li> <li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li> <li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li> <li><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</li></ul> <p><strong>用法</strong>：</p> <p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p> <p>用在普通元素上时，只能监听<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" target="_blank" rel="noopener noreferrer"><strong>原生 DOM 事件</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p> <p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> property：<code>v-on:click=&quot;handle('ok', $event)&quot;</code>。</p> <p>从 <code>2.4.0</code> 开始，<code>v-on</code> 同样支持不带参数绑定一个事件/监听器键值对的对象。注意当使用对象语法时，是不支持任何修饰器的。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 方法处理器 --&gt;
&lt;button v-on:click=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 动态事件 (2.6.0+) --&gt;
&lt;button v-on:[event]=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 内联语句 --&gt;
&lt;button v-on:click=&quot;doThat('hello', $event)&quot;&gt;&lt;/button&gt;
&lt;!-- 缩写 --&gt;
&lt;button @click=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 动态事件缩写 (2.6.0+) --&gt;
&lt;button @[event]=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 停止冒泡 --&gt;
&lt;button @click.stop=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 阻止默认行为 --&gt;
&lt;button @click.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 阻止默认行为，没有表达式 --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;
&lt;!--  串联修饰符 --&gt;
&lt;button @click.stop.prevent=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 键修饰符，键别名 --&gt;
&lt;input @keyup.enter=&quot;onEnter&quot;&gt;
&lt;!-- 键修饰符，键代码 --&gt;
&lt;input @keyup.13=&quot;onEnter&quot;&gt;
&lt;!-- 点击回调只会触发一次 --&gt;
&lt;button v-on:click.once=&quot;doThis&quot;&gt;&lt;/button&gt;
&lt;!-- 对象语法 (2.4.0+) --&gt;
&lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在子组件上监听自定义事件 (当子组件触发“my-event”时将调用事件处理器)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;my-component @my-event=&quot;handleThis&quot;&gt;&lt;/my-component&gt;
&lt;!-- 内联语句 --&gt;
&lt;my-component @my-event=&quot;handleThis(123, $event)&quot;&gt;&lt;/my-component&gt;
&lt;!-- 组件中的原生事件 --&gt;
&lt;my-component @click.native=&quot;onClick&quot;&gt;&lt;/my-component&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="v-bind"><a href="#v-bind" class="header-anchor">#</a> v-bind</h5> <p><strong>缩写</strong>：<code>:</code></p> <p><strong>预期</strong>：<code>any (with argument) | Object (without argument)</code></p> <p><strong>参数</strong>：<code>attrOrProp (optional)</code></p> <p><strong>修饰符</strong>：</p> <ul><li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。</li> <li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li> <li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</li></ul> <p><strong>用法</strong>：</p> <p>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p> <p>在绑定 <code>class</code> 或 <code>style</code> attribute 时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p> <p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p> <p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 绑定一个 attribute --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot;&gt;
&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;
&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;
&lt;!-- 缩写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;
&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;
&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;
&lt;!-- 内联字符串拼接 --&gt;
&lt;img :src=&quot;'/path/to/images/' + fileName&quot;&gt;
&lt;!-- class 绑定 --&gt;
&lt;div :class=&quot;{ red: isRed }&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;
&lt;div :class=&quot;[classA, { classB: isB, classC: isC }]&quot;&gt;
&lt;!-- style 绑定 --&gt;
&lt;div :style=&quot;{ fontSize: size + 'px' }&quot;&gt;&lt;/div&gt;
&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;
&lt;!-- 绑定一个全是 attribute 的对象 --&gt;
&lt;div v-bind=&quot;{ id: someProp, 'other-attr': otherProp }&quot;&gt;&lt;/div&gt;
&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;
&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;
&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;
&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;
&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;
&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;
&lt;!-- XLink --&gt;
&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>.camel</code> 修饰符允许在使用 DOM 模板时将 <code>v-bind</code> property 名称驼峰化，例如 SVG 的 <code>viewBox</code> property：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;svg :view-box.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在使用字符串模板或通过 <code>vue-loader</code>/<code>vueify</code> 编译时，无需使用 <code>.camel</code>。</p> <h5 id="v-model"><a href="#v-model" class="header-anchor">#</a> v-model</h5> <p><strong>预期</strong>：随表单控件类型不同而不同。</p> <p><strong>限制</strong>：</p> <ul><li><code>&lt;input&gt;</code></li> <li><code>&lt;select&gt;</code></li> <li><code>&lt;textarea&gt;</code></li> <li>components</li></ul> <p><strong>修饰符</strong>：</p> <ul><li><a href="https://cn.vuejs.org/v2/guide/forms.html#lazy" target="_blank" rel="noopener noreferrer"><code>.lazy</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li> <li><a href="https://cn.vuejs.org/v2/guide/forms.html#number" target="_blank" rel="noopener noreferrer"><code>.number</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> - 输入字符串转为有效的数字</li> <li><a href="https://cn.vuejs.org/v2/guide/forms.html#trim" target="_blank" rel="noopener noreferrer"><code>.trim</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> - 输入首尾空格过滤</li></ul> <p><strong>用法</strong>：</p> <p>在表单控件或者组件上创建双向绑定。细节请看下面的教程链接。</p> <h5 id="v-slot"><a href="#v-slot" class="header-anchor">#</a> v-slot</h5> <p><strong>缩写</strong>：<code>#</code></p> <p><strong>预期</strong>：可放置在函数参数位置的 JavaScript 表达式 (在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E8%A7%A3%E6%9E%84%E6%8F%92%E6%A7%BD-Props" target="_blank" rel="noopener noreferrer">支持的环境下<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>可使用解构)。可选，即只需要在为插槽传入 prop 的时候使用。</p> <p><strong>参数</strong>：插槽名 (可选，默认值是 <code>default</code>)</p> <p><strong>限用于</strong></p> <ul><li><code>&lt;template&gt;</code></li> <li><a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">组件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (对于一个单独的带 prop 的默认插槽)</li></ul> <p><strong>用法</strong>：</p> <p>提供具名插槽或需要接收 prop 的插槽。</p> <h5 id="v-pre"><a href="#v-pre" class="header-anchor">#</a> v-pre</h5> <ul><li><p><strong>不需要表达式</strong></p></li> <li><p><strong>用法</strong>：</p> <p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></li> <li><p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h5 id="v-cloak"><a href="#v-cloak" class="header-anchor">#</a> v-cloak</h5> <p><strong>不需要表达式</strong></p> <p><strong>用法</strong>：</p> <p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p> <p><strong>示例</strong>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>[v-cloak] {
  display: none;
}
&lt;div v-cloak&gt;
  {{ message }}
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>不会显示，直到编译结束。</p> <h5 id="v-once"><a href="#v-once" class="header-anchor">#</a> v-once</h5> <p><strong>不需要表达式</strong></p> <p><strong>详细</strong>：</p> <p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p> <h4 id="特殊属性-attribute"><a href="#特殊属性-attribute" class="header-anchor">#</a> 特殊属性（attribute）</h4> <h5 id="key"><a href="#key" class="header-anchor">#</a> key</h5> <p><strong>预期</strong>：<code>number | string | boolean (2.4.2 新增) | symbol (2.5.12 新增)</code></p> <p><code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识  VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key  时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p> <p>最常见的用例是结合 <code>v-for</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;ul&gt;
  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;
&lt;/ul&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p> <ul><li>完整地触发组件的生命周期钩子</li> <li>触发过渡</li></ul> <p>例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡。</p> <h5 id="ref"><a href="#ref" class="header-anchor">#</a> ref</h5> <p><strong>预期</strong>：<code>string</code></p> <p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- `vm.$refs.p` will be the DOM node --&gt;
&lt;p ref=&quot;p&quot;&gt;hello&lt;/p&gt;
&lt;!-- `vm.$refs.child` will be the child component instance --&gt;
&lt;child-component ref=&quot;child&quot;&gt;&lt;/child-component&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p> <p>关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</p> <h5 id="is"><a href="#is" class="header-anchor">#</a> is</h5> <p><strong>预期</strong>：<code>string | Object (组件的选项对象)</code></p> <p>用于<a href="https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">动态组件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>且基于 <a href="https://cn.vuejs.org/v2/guide/components.html#%E8%A7%A3%E6%9E%90-DOM-%E6%A8%A1%E6%9D%BF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener noreferrer">DOM 内模板的限制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>来工作。</p> <p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 当 `currentView` 改变时，组件也跟着改变 --&gt;
&lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;
&lt;!-- 这样做是有必要的，因为 `&lt;my-row&gt;` 放在一个 --&gt;
&lt;!-- `&lt;table&gt;` 内可能无效且被放置到外面 --&gt;
&lt;table&gt;
  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h5 id="slot废弃"><a href="#slot废弃" class="header-anchor">#</a> <s>slot废弃</s></h5> <h5 id="slot-scope废弃"><a href="#slot-scope废弃" class="header-anchor">#</a> <s>slot-scope废弃</s></h5> <h5 id="scope移除"><a href="#scope移除" class="header-anchor">#</a> scope移除</h5> <h4 id="内置组件"><a href="#内置组件" class="header-anchor">#</a> 内置组件</h4> <h5 id="component"><a href="#component" class="header-anchor">#</a> component</h5> <h5 id="transition"><a href="#transition" class="header-anchor">#</a> transition</h5> <p><strong>Props</strong>：</p> <ul><li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: 'fade'</code> 将自动拓展为 <code>.fade-enter</code>，<code>.fade-enter-active</code> 等。默认类名为 <code>&quot;v&quot;</code></li> <li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li> <li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li> <li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li> <li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li> <li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li> <li><code>enter-class</code> - string</li> <li><code>leave-class</code> - string</li> <li><code>appear-class</code> - string</li> <li><code>enter-to-class</code> - string</li> <li><code>leave-to-class</code> - string</li> <li><code>appear-to-class</code> - string</li> <li><code>enter-active-class</code> - string</li> <li><code>leave-active-class</code> - string</li> <li><code>appear-active-class</code> - string</li></ul> <p><strong>事件</strong>：</p> <ul><li><code>before-enter</code></li> <li><code>before-leave</code></li> <li><code>before-appear</code></li> <li><code>enter</code></li> <li><code>leave</code></li> <li><code>appear</code></li> <li><code>after-enter</code></li> <li><code>after-leave</code></li> <li><code>after-appear</code></li> <li><code>enter-cancelled</code></li> <li><code>leave-cancelled</code> (<code>v-show</code> only)</li> <li><code>appear-cancelled</code></li></ul> <p><strong>用法</strong>：</p> <p><code>&lt;transition&gt;</code> 元素作为<strong>单个</strong>元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 简单元素 --&gt;
&lt;transition&gt;
  &lt;div v-if=&quot;ok&quot;&gt;toggled content&lt;/div&gt;
&lt;/transition&gt;
&lt;!-- 动态组件 --&gt;
&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/transition&gt;
&lt;!-- 事件钩子 --&gt;
&lt;div id=&quot;transition-demo&quot;&gt;
  &lt;transition @after-enter=&quot;transitionComplete&quot;&gt;
    &lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt;
  &lt;/transition&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h5 id="transition-group"><a href="#transition-group" class="header-anchor">#</a> transition-group</h5> <p><strong>Props</strong>：</p> <ul><li><code>tag</code> - string，默认为 <code>span</code></li> <li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li> <li>除了 <code>mode</code>，其他 attribute 和 <code>&lt;transition&gt;</code> 相同。</li></ul> <p><strong>事件</strong>：</p> <ul><li>事件和 <code>&lt;transition&gt;</code> 相同。</li></ul> <p><strong>用法</strong>：</p> <p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> attribute 配置哪个元素应该被渲染。</p> <p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有<strong>独立的 key</strong>，动画才能正常工作</p> <p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它会被应用一个移动中的 CSS 类 (通过 <code>name</code> attribute 或配置 <code>move-class</code> attribute 自动生成)。如果 CSS <code>transform</code> property 是“可过渡”property，当应用移动类时，将会使用 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="noopener noreferrer">FLIP 技术<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>使元素流畅地到达动画终点。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;transition-group tag=&quot;ul&quot; name=&quot;slide&quot;&gt;
  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;
    {{ item.text }}
  &lt;/li&gt;
&lt;/transition-group&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="keep-alive"><a href="#keep-alive" class="header-anchor">#</a> keep-alive</h5> <p><strong>Props</strong>：</p> <ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li> <li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li> <li><code>max</code> - 数字。最多可以缓存多少组件实例。</li></ul> <p><strong>用法</strong>：</p> <p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p> <p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p> <p><strong>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 <code>&lt;keep-alive&gt;</code> 树内的所有嵌套组件中触发。</strong></p> <p>主要用于保留组件状态或避免重新渲染。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 基本 --&gt;
&lt;keep-alive&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
&lt;!-- 多个条件判断的子组件 --&gt;
&lt;keep-alive&gt;
  &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;
  &lt;comp-b v-else&gt;&lt;/comp-b&gt;
&lt;/keep-alive&gt;
&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;
&lt;transition&gt;
  &lt;keep-alive&gt;
    &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
&lt;/transition&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>注意，<code>&lt;keep-alive&gt;</code> 是用在其一个直属的子组件被开关的情形。如果你在其中有 <code>v-for</code> 则不会工作。如果有上述的多个条件性的子元素，<code>&lt;keep-alive&gt;</code> 要求同时只有一个子元素被渲染。</p> <p><strong><code>include</code> and <code>exclude</code></strong></p> <blockquote><p>2.1.0 新增</p></blockquote> <p><code>include</code> 和 <code>exclude</code> prop 允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- 逗号分隔字符串 --&gt;
&lt;keep-alive include=&quot;a,b&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;/a|b/&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
&lt;!-- 数组 (使用 `v-bind`) --&gt;
&lt;keep-alive :include=&quot;['a', 'b']&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>匹配首先检查组件自身的 <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的局部注册名称 (父组件 <code>components</code> 选项的键值)。匿名组件不能被匹配。</p> <p><strong><code>max</code></strong></p> <blockquote><p>2.5.0 新增</p></blockquote> <p>最多可以缓存多少组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;keep-alive :max=&quot;10&quot;&gt;
  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p> <h5 id="slot"><a href="#slot" class="header-anchor">#</a> slot</h5> <p><strong>Props</strong>：</p> <ul><li><code>name</code> - string，用于命名插槽。</li></ul> <p><strong>Usage</strong>：</p> <p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。<code>&lt;slot&gt;</code> 元素自身将被替换。</p> <h2 id="组件开发"><a href="#组件开发" class="header-anchor">#</a> 组件开发</h2> <h3 id="组件注册"><a href="#组件注册" class="header-anchor">#</a> 组件注册</h3> <p>全局注册：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component-name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>局部注册：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>组件名的方式有两种：</p> <ul><li><p>使用 kebab-case</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component('my-component-name', { /* ... */ })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>使用 PascalCase</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component('MyComponentName', { /* ... */ })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</p> <p>全局注册</p> <h3 id="函数式组件"><a href="#函数式组件" class="header-anchor">#</a> 函数式组件</h3> <p>函数式组件是指用一个Function来渲染一个vue组件，这个组件只接受一些 prop，我们可以将这类组件标记为 functional，这意味着它无状态 (没有响应式数据)，也没有实例 (没有this上下文)。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  functional<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
  props<span class="token operator">:</span> <span class="token punctuation">{</span> 
    <span class="token comment">// Props 是可选的</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 为了弥补缺少的实例, 提供第二个参数作为上下文</span>
  <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">createElement<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> vNode
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>render函数的第二个参数context用来代替上下文this他是一个包含如下字段的对象：</p> <ul><li>props：提供所有 prop 的对象</li> <li>children: VNode 子节点的数组</li> <li>slots: 一个函数，返回了包含所有插槽的对象</li> <li>scopedSlots: (2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</li> <li>data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</li> <li>parent：对父组件的引用</li> <li>listeners: (2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。</li> <li>injections: (2.3.0+) 如果使用了 inject 选项，则该对象包含了应当被注入的属性。</li></ul> <h3 id="组件间通信和传值"><a href="#组件间通信和传值" class="header-anchor">#</a> 组件间通信和传值</h3> <p>Vue组件的通信可以是：子父关系，也可以是子祖关系、兄弟关系。不同的的关系也就意味方式不同，主要包括以下几种方式：</p> <ul><li><code>$parent与$children</code></li> <li><code>$emit</code></li> <li><code>$eventBus</code>: 事件总线，通过emit和on来完成传递接收</li> <li><code>provide与inject</code></li> <li><code>props 与 $refs</code></li></ul> <h4 id="prop"><a href="#prop" class="header-anchor">#</a> prop</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span>
    propA<span class="token operator">:</span> Number<span class="token punctuation">,</span>
    <span class="token comment">// 多个可能的类型</span>
    propB<span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 必填的字符串</span>
    propC<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> String<span class="token punctuation">,</span>
      required<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 带有默认值的数字</span>
    propD<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Number<span class="token punctuation">,</span>
      <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">100</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 带有默认值的对象</span>
    propE<span class="token operator">:</span> <span class="token punctuation">{</span>
      type<span class="token operator">:</span> Object<span class="token punctuation">,</span>
      <span class="token comment">// 对象或数组默认值必须从一个工厂函数获取</span>
      <span class="token function-variable function">default</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> message<span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 自定义验证函数</span>
    propF<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">validator</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这个值必须匹配下列字符串中的一个</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'success'</span><span class="token punctuation">,</span> <span class="token string">'warning'</span><span class="token punctuation">,</span> <span class="token string">'danger'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p><code>type</code> 可以是下列原生构造函数中的一个：</p> <ul><li><code>String</code></li> <li><code>Number</code></li> <li><code>Boolean</code></li> <li><code>Array</code></li> <li><code>Object</code></li> <li><code>Date</code></li> <li><code>Function</code></li> <li><code>Symbol</code></li></ul> <p><code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。例如，给定下列现成的构造函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。</p> <p>注意 <code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。</p> <h4 id="自定义事件"><a href="#自定义事件" class="header-anchor">#</a> 自定义事件</h4> <p>1、事件名：</p> <p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。举个例子，如果触发一个 camelCase 名字的事件：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'myEvent'</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>则监听这个名字的 kebab-case 版本是不会有任何效果的：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 没有效果 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-component</span> <span class="token attr-name"><span class="token namespace">v-on:</span>my-event</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>doSomething<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-component</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p> <p>因此，我们推荐你<strong>始终使用 kebab-case 的事件名</strong>。</p> <p>2、自定义组件的v-model</p> <p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value" target="_blank" rel="noopener noreferrer">不同的目的<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。<code>model</code> 选项可以用来避免这样的冲突：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    &lt;input
      type=&quot;checkbox&quot;
      v-bind:checked=&quot;checked&quot;
      v-on:change=&quot;$emit('change', $event.target.checked)&quot;
    &gt;
  `
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>现在在这个组件上使用 <code>v-model</code> 的时候：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p> <p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p> <p>3、将原生事件绑定到组件</p> <p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-input</span> <span class="token attr-name"><span class="token namespace">v-on:</span>focus.native</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onFocus<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>base-input</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在有的时候这是很有用的，不过在你尝试监听一个类似 <code>&lt;input&gt;</code> 的非常特定的元素时，这并不是个好主意。比如上述 <code>&lt;base-input&gt;</code> 组件可能做了如下重构，所以根元素实际上是一个 <code>&lt;label&gt;</code> 元素：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">&gt;</span></span>
  {{ label }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
    <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$attrs<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span>
    <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$emit(<span class="token punctuation">'</span>input<span class="token punctuation">'</span>, $event.target.value)<span class="token punctuation">&quot;</span></span>
  <span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这时，父级的 <code>.native</code> 监听器将静默失败。它不会产生任何报错，但是 <code>onFocus</code> 处理函数不会如你预期地被调用。</p> <p>为了解决这个问题，Vue 提供了一个 <code>$listeners</code> property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
  <span class="token function-variable function">input</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>有了这个 <code>$listeners</code> property，你就可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p> <div class="language-vue line-numbers-mode"><pre class="language-vue"><code>Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">&gt;</span></span>
      {{ label }}
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
        <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$attrs<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span>
        <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>inputListeners<span class="token punctuation">&quot;</span></span>
      <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>
  `
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 <code>.native</code> 监听器。</p> <p>4、.sync修饰符</p> <p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p> <p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.$emit('update:title', newTitle)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;text-document
  v-bind:title=&quot;doc.title&quot;
  v-on:update:title=&quot;doc.title = $event&quot;
&gt;&lt;/text-document&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p></div> <p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;text-document v-bind.sync=&quot;doc&quot;&gt;&lt;/text-document&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p> <p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。​</p> <h3 id="slot插槽"><a href="#slot插槽" class="header-anchor">#</a> slot插槽</h3> <p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">文档中<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 attribute。新语法的由来可查阅这份 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" target="_blank" rel="noopener noreferrer">RFC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h4 id="具名插槽"><a href="#具名插槽" class="header-anchor">#</a> 具名插槽</h4> <p><code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p> <p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>base-layout</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>header</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Here might be a page title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>A paragraph for the main content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>And another one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  //或者
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>default</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>A paragraph for the main content.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>And another one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>footer</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Here's some contact info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>base-layout</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong></p> <h4 id="作用域插槽"><a href="#作用域插槽" class="header-anchor">#</a> 作用域插槽</h4> <p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>slot v<span class="token operator">-</span>bind<span class="token operator">:</span>user<span class="token operator">=</span><span class="token string">&quot;user&quot;</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span> user<span class="token punctuation">.</span>lastName <span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>slot<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code> 直接用在组件上：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;current-user v-slot:default=&quot;slotProps&quot;&gt;
  {{ slotProps.user.firstName }}
&lt;/current-user&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;current-user v-slot=&quot;slotProps&quot;&gt;
  {{ slotProps.user.firstName }}
&lt;/current-user&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 无效，会导致警告 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>current-user</span> <span class="token attr-name">v-slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>slotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  {{ slotProps.user.firstName }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span> <span class="token attr-name"><span class="token namespace">v-slot:</span>other</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>otherSlotProps<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    slotProps is NOT available here
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>current-user</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;current-user&gt;
  &lt;template v-slot:default=&quot;slotProps&quot;&gt;
    {{ slotProps.user.firstName }}
  &lt;/template&gt;

  &lt;template v-slot:other=&quot;otherSlotProps&quot;&gt;
    ...
  &lt;/template&gt;
&lt;/current-user&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="动态插槽名"><a href="#动态插槽名" class="header-anchor">#</a> 动态插槽名</h4> <h4 id="具名插槽名缩写"><a href="#具名插槽名缩写" class="header-anchor">#</a> 具名插槽名缩写</h4> <p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;base-layout&gt;
  &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
  &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here's some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="动态组件"><a href="#动态组件" class="header-anchor">#</a> 动态组件</h3> <p>is属性</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
 <span class="token operator">&lt;</span>component v<span class="token operator">-</span>bind<span class="token operator">:</span>is<span class="token operator">=</span><span class="token string">&quot;currentTabComponent&quot;</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;tab&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="异步组件"><a href="#异步组件" class="header-anchor">#</a> 异步组件</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//局部注册</span>
components<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token string">'my-component'</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-async-component'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>异步组件工厂函数也可以返回一个如下格式的对象：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">AsyncComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span>
  component<span class="token operator">:</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./MyComponent.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// 异步组件加载时使用的组件</span>
  loading<span class="token operator">:</span> LoadingComponent<span class="token punctuation">,</span>
  <span class="token comment">// 加载失败时使用的组件</span>
  error<span class="token operator">:</span> ErrorComponent<span class="token punctuation">,</span>
  <span class="token comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span>
  delay<span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token comment">// 如果提供了超时时间且组件加载也超时了，</span>
  <span class="token comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span>
  timeout<span class="token operator">:</span> <span class="token number">3000</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="处理边界情况"><a href="#处理边界情况" class="header-anchor">#</a> 处理边界情况</h3> <h4 id="访问根实例"><a href="#访问根实例" class="header-anchor">#</a> 访问根实例</h4> <p><code>$root</code></p> <h4 id="访问父级组件实例"><a href="#访问父级组件实例" class="header-anchor">#</a> 访问父级组件实例</h4> <p><code>$parent</code> property 可以用来从一个子组件访问父组件的实例。</p> <h4 id="访问子组件实例或子元素"><a href="#访问子组件实例或子元素" class="header-anchor">#</a> 访问子组件实例或子元素</h4> <p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p> <p>甚至可以通过其父级组件定义方法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>methods<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用来从父级组件聚焦输入框</span>
  <span class="token function-variable function">focus</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>input<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>this.$refs.usernameInput.focus()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="过渡"><a href="#过渡" class="header-anchor">#</a> 过渡</h3> <p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p> <ul><li>条件渲染 (使用 <code>v-if</code>)</li> <li>条件展示 (使用 <code>v-show</code>)</li> <li>动态组件</li> <li>组件根节点</li></ul> <p>过渡的类名</p> <p>在进入/离开的过渡中，会有 6 个 class 切换。</p> <ol><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li> <li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li> <li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li> <li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li> <li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li> <li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li></ol> <p><img src="https://cn.vuejs.org/images/transition.png" alt="Transition Diagram"></p> <p>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p> <p><code>v-enter-active</code> 和 <code>v-leave-active</code> 可以控制进入/离开过渡的不同的缓和曲线，</p> <p>通过以下 attribute 来自定义过渡类名：</p> <ul><li><code>enter-class</code></li> <li><code>enter-active-class</code></li> <li><code>enter-to-class</code> (2.1.8+)</li> <li><code>leave-class</code></li> <li><code>leave-active-class</code></li> <li><code>leave-to-class</code> (2.1.8+)</li></ul> <p>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener noreferrer">Animate.css<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 结合使用十分有用。</p> <p>示例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;link href=&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;

&lt;div id=&quot;example-3&quot;&gt;
  &lt;button @click=&quot;show = !show&quot;&gt;
    Toggle render
  &lt;/button&gt;
  &lt;transition
    name=&quot;custom-classes-transition&quot;
    enter-active-class=&quot;animated tada&quot;
    leave-active-class=&quot;animated bounceOutRight&quot;
  &gt;
    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;
  &lt;/transition&gt;
&lt;/div&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>用 <code>&lt;transition&gt;</code> 组件上的 <code>duration</code> prop 定制一个显性的过渡持续时间 (以毫秒计)：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也可以定制进入和移出的持续时间：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;transition :duration=&quot;{ enter: 500, leave: 800 }&quot;&gt;...&lt;/transition&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="列表过度"><a href="#列表过度" class="header-anchor">#</a> 列表过度</h4> <h3 id="mixin混入"><a href="#mixin混入" class="header-anchor">#</a> Mixin混入</h3> <p>mixin提供了一种非常灵活的方式，可以用来分发Vue组件中的可复用功能，借助Mixin多个组件可以共享数据和方法。同时引入mixin的组件，mixin中的方法和属性也就并入到该组件中，可以直接使用。钩子函数也将会在两个都被调用（Mixin中的钩子会先执行）。</p> <h3 id="高阶组件"><a href="#高阶组件" class="header-anchor">#</a> 高阶组件</h3> <p>高阶组件也称为HOC，它被描述为一种在组件之间共享公共功能而不需要重复代码的方法。作用在于增强组件的功能，简单定义就是：你向一个方法传入组件，然后返回一个新的组件，这就是一个HOC。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  strict<span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="vuecss变量"><a href="#vuecss变量" class="header-anchor">#</a> vuecss变量</h2> <h2 id="修饰符-2"><a href="#修饰符-2" class="header-anchor">#</a> 修饰符</h2> <h3 id="表单修饰符"><a href="#表单修饰符" class="header-anchor">#</a> 表单修饰符</h3> <p><strong>.lazy</strong></p> <p>只有当我们光标离开输入框的时候，它才会更新视图，相当于在onchange事件触发更新。</p> <p><strong>.trim</strong></p> <p><strong>过滤首尾的空格</strong>！首尾，中间的是不会过滤的</p> <p><strong>.number</strong></p> <p>如果你先输入数字，那它就会限制你输入的只能是数字。
如果你先输入字符串，那它就相当于没有加.number</p> <h3 id="事件修饰符"><a href="#事件修饰符" class="header-anchor">#</a> 事件修饰符</h3> <p><strong>.stop</strong></p> <p>由于事件冒泡的机制，我们给元素绑定点击事件的时候，也会触发父级的点击事件。</p> <p>一键阻止事件冒泡，相当于调用了event.stopPropagation()方法。</p> <p><strong>.prevent</strong></p> <p>用于阻止事件的默认行为，例如，当点击提交按钮时阻止对表单的提交。相当于调用了event.preventDefault()方法。</p> <p>**注意：**修饰符可以同时使用多个,但是可能会因为顺序而有所不同。</p> <p>用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p> <p><strong>.self</strong></p> <p>只当事件是从事件绑定的元素本身触发时才触发回调。</p> <p><strong>.once</strong></p> <p>只能用一次，绑定了事件以后只能触发一次，第二次就不会触发。</p> <p><strong>.capture</strong></p> <p>事件的冒泡，其实完整的事件机制是：捕获阶段--目标阶段--冒泡阶段。</p> <p>默认的呢，是事件触发是从目标开始往上冒泡。</p> <p>当我们加了这个.capture以后呢，我们就反过来了，事件触发从包含这个元素的顶层开始往下触发。</p> <p><strong>.passive</strong></p> <p>当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符</p> <p><strong>.native</strong></p> <p>我们经常会写很多的小组件，有些小组件可能会绑定一些事件，但是，像下面这样绑定事件是不会触发的</p> <blockquote><div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;My-component @click=&quot;shout(3)&quot;&gt;&lt;/My-component&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></blockquote> <p>必须使用.native来修饰这个click事件（即），可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，
注意：<strong>使用.native修饰符来操作普通HTML标签是会令事件失效的</strong></p> <h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="header-anchor">#</a> 鼠标按钮修饰符</h3> <p>刚刚我们讲到这个click事件，我们一般是会用左键触发，有时候我们需要更改右键菜单啥的，就需要用到右键点击或者中间键点击，这个时候就要用到鼠标按钮修饰符</p> <ul><li>.left 左键点击</li> <li>.right 右键点击</li> <li>.middle 中键点击</li></ul> <h3 id="键值修饰符"><a href="#键值修饰符" class="header-anchor">#</a> 键值修饰符</h3> <p><strong>.keyCode</strong></p> <p>如果不用keyCode修饰符，那我们每次按下键盘都会触发shout，当我们想指定按下某一个键才触发这个shout的时候，这个修饰符就有用了，</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout(4)&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>为了方便我们使用，vue给一些常用的键提供了别名</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//普通键
.enter.tab.delete 
//(捕获“删除”和“退格”键)
.space.esc.up.down.left.right
//系统修饰键
.ctrl.alt.meta.shift
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以通过全局 config.keyCodes 对象自定义按键修饰符别名：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 可以使用`v-on:keyup.f1`
Vue.config.keyCodes.f1 = 112
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><strong>.exact</strong> <strong>(2.5新增)</strong></li></ul> <h3 id="v-bind修饰符"><a href="#v-bind修饰符" class="header-anchor">#</a> v-bind修饰符</h3> <p><strong>.sync</strong></p> <p><strong>.prop</strong></p> <p><strong>.camel</strong></p> <h2 id="实用技巧"><a href="#实用技巧" class="header-anchor">#</a> 实用技巧</h2> <h3 id="动态指令参数"><a href="#动态指令参数" class="header-anchor">#</a> 动态指令参数</h3> <p>指令参数现在可以接受动态JavaScript表达式动态参数值应该是字符串，但允许<code>null</code>作为一个明确指示应该删除绑定的特殊值，那将会很方便。任何其他非字符串值都可能出错，并会触发警告。（仅适用于<code>v-bind和v-on</code>）</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;div v-bind:[attr]=&quot;attributeName&quot;&gt;&lt;/div&gt;
//简写
&lt;div :[attr]=&quot;attributeName&quot;&gt;&lt;/div&gt;
&lt;button v-on:[eventName]=&quot;handler&quot;&gt;&lt;/button&gt;
//简写
&lt;button @[eventName]=&quot;handler&quot;&gt;&lt;/button&gt;
&lt;my-component&gt;
&lt;template v-slot:[slotName]&gt;
Dynamic slot name
&lt;/template&gt;
&lt;/my-component&gt;
//简写
&lt;foo&gt;
&lt;template #[name]&gt;
Default slot
&lt;/template&gt;
&lt;/foo&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="slots-新语法"><a href="#slots-新语法" class="header-anchor">#</a> slots 新语法</h3> <p>使用带有“＃”的新命名插槽缩写语法,在Vue 2.6.0+中可用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
  &lt;article-layout&gt;

    &lt;template #articleHeader&gt;
      &lt;h1&gt;I am the header&lt;/h1&gt;
    &lt;/template&gt;

    &lt;template #articleContent&gt;
      &lt;p&gt;I am the content&lt;/p&gt;
    &lt;/template&gt;

    &lt;template #articleFooter&gt;
      &lt;footer&gt;I am the footer&lt;/footer&gt;
    &lt;/template&gt;

    &lt;template #side&gt;
      &lt;aside&gt;I am the side stuff&lt;/aside&gt;
    &lt;/template&gt;

    &lt;template #banner&gt;
      &lt;div&gt;I am the banner&lt;/div&gt;
    &lt;/template&gt;

  &lt;/article-layout&gt;
&lt;template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="hook那些事"><a href="#hook那些事" class="header-anchor">#</a> @hook那些事</h3> <p>处理组件内定时器的步骤。通常我们一般都是这样操作的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;script&gt;
  export default {
    mounted() {
      this.timer = setInterval(() =&gt; { ... }, 1000);
    },
    beforeDestroy() {
      clearInterval(this.timer);
    }
  };
&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>更好的做法是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;script&gt;
  export default {
    mounted() {
      const timer = setInterval(() =&gt; { ... }, 1000);
      this.$once('hook:beforeDestroy', () =&gt; clearInterval(timer);)
    }
  };
&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>设想一个场景如果我们需要在数据渲染到页面的之前让页面 <code>loading</code>。<code>mounted</code> 之后停止 <code>loading</code>。<code>beforeUpdata</code> 时开始 <code>loading</code>。<code>updatad</code> 之后停止 <code>loading</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;v-chart
    @hook:mounted=&quot;loading = false&quot;
    @hook:beforeUpdated=&quot;loading = true&quot;
    @hook:updated=&quot;loading = false&quot;
    :data=&quot;data&quot;
/&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>实现了对子组件生命周期的监听。对任意的组件都有效果，包括引入的第三方组件。</p> <h3 id="vue中的-props、-attrs和-listeners-可用来二次封装组件"><a href="#vue中的-props、-attrs和-listeners-可用来二次封装组件" class="header-anchor">#</a> vue中的<code>$props</code>、<code>$attrs</code>和<code>$listeners</code>(可用来二次封装组件)</h3> <p>$props：当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象属性的访问。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//good
&lt;input v-bind=&quot;$props&quot;&gt;
 
//bad
//而不是下面这样，如果很多的属性就特别繁琐
&lt;input :name=&quot;name&quot; :placeholder=&quot;placeholder&quot; :disabled=&quot;disabled&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>$attrs</code> 将原生属性直接传递给子组件,这是Vue在2.4.0新增的属性,包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop  时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot;  传入内部组件——在创建高级别的组件时非常有用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;input
   v-bind=&quot;$attrs&quot;
   :value=&quot;value&quot;
   @focus=$emit('focus', $event)&quot;
   @input=&quot;$emit('input', $event.target.value)&quot;
&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>$listeners</code>：包含了父作用域中的 (不含 <code>.native</code>修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p> <p>如果子组件不在父组件的根目录下，则可以将所有事件侦听器从父组件传递到子组件，如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;template&gt;
&lt;div&gt;
  ...
&lt;childComponent v-on=&quot;$listeners&quot; /&gt;...
&lt;/div&gt;
&lt;/template&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="响应式数据-2-6-0新增"><a href="#响应式数据-2-6-0新增" class="header-anchor">#</a> 响应式数据(2.6.0新增)</h3> <p>习惯于用Vuex去解决状态的共享问题,但是在小项目中使用就会有增大代码体积和将代码复杂化的烦恼,所以在后来的版本中Vue新增<code>Vue.observable( object )</code>让一个对象可响应,Vue 内部会用它来处理 data 函数返回的对象。</p> <p>返回的对象可以直接用于渲染函数和 计算属性 内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const state = Vue.observable({ count: 0 })

const Demo = {
  render(h) {
    return h('button', {
      on: { click: () =&gt; { state.count++ }}
    }, `count is: ${state.count}`)
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="jsx模板组件"><a href="#jsx模板组件" class="header-anchor">#</a> jsx模板组件</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;button v-if=&quot;status === 1&quot; class=&quot;btn1&quot; :class=&quot;status === 1&quot; @click=&quot;&quot;&gt;未开始&lt;/button&gt;
&lt;button v-if=&quot;status === 2&quot; class=&quot;btn2&quot; :class=&quot;status === 2&quot; @click=&quot;&quot;&gt;进行中&lt;/button&gt;
&lt;button v-if=&quot;status === 3&quot; class=&quot;btn3&quot; :class=&quot;status === 3&quot; @click=&quot;&quot;&gt;可领取&lt;/button&gt;
&lt;button v-if=&quot;status === 4&quot; class=&quot;btn4&quot; :class=&quot;status === 4&quot; @click=&quot;&quot;&gt;已领取&lt;/button&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>将所有的逻辑封装进渲染函数内,外部只需要传递一个状态参数即可改变</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;child :status=&quot;status&quot;&gt;&lt;/child&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="动态组件-2"><a href="#动态组件-2" class="header-anchor">#</a> 动态组件</h3> <p>通过 Vue 的  元素加一个特殊的 is attribute 可以实现动态组件的效果</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;component v-for=&quot;(item,index) in componentList&quot; :key=&quot;index&quot; :is=&quot;item&quot;&gt;&lt;/component&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="vue-filter-2"><a href="#vue-filter-2" class="header-anchor">#</a> Vue.filter</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 使用
// 在双花括号中
{{ message | capitalize }}

// 在 `v-bind` 中
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;

// 全局注册
Vue.filter('stampToYYMMDD', (value) =&gt;{
  // 处理逻辑
})

// 局部注册
filters: {
  stampToYYMMDD: (value)=&gt; {
    // 处理逻辑
  }
}

// 多个过滤器全局注册
// /src/common/filters.js
let dateServer = value =&gt; value.replace(/(\d{4})(\d{2})(\d{2})/g, '$1-$2-$3')
export { dateServer }
// /src/main.js
import * as custom from './common/filters/custom'
Object.keys(custom).forEach(key =&gt; Vue.filter(key, custom[key]))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="sync-语法糖"><a href="#sync-语法糖" class="header-anchor">#</a> .sync 语法糖</h3> <p>sync 就是为了实现prop 进行“双向绑定”仅此而已（父对子，子对父，来回传）</p> <p>需要在子组件修改父组件值的时候这个方法很好用，它的实现机制和v-model是一样的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;comp .foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;
等同于
&lt;comp .bar=&quot;foo&quot; @update:bar=&quot;e=&gt; foo = e&quot;&gt;&lt;/comp&gt;
更新方式
this.$emit('update:bar',value)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="利用-object-freeze-提升性能"><a href="#利用-object-freeze-提升性能" class="header-anchor">#</a> 利用 object.freeze 提升性能</h3> <p><code>Object.freeze()</code> 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。<code>freeze()</code> 返回和传入的参数相同的对象。</p> <p>比方我们需要渲染一个非常大的数组对象，例如用户列表，对象列表，文章列表等等。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default {
  data: () =&gt; ({
    users: {}
  }),
  async created() {
    const users = await axios.get(&quot;/api/users&quot;);
    this.users = users;
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>vue 会将 data 对象中的所有的属性加入到 vue 的响应式系统中，当这些属性的值发生改变时，视图将会产生 响应，若对象的体积比较大，会消耗很多浏览器解析时间。</p> <p>所以我们可以通过减少数据的响应式转换来提供前端的性能。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default {
  data: () =&gt; ({
    users: {}
  }),
  async created() {
    const users = await axios.get(&quot;/api/users&quot;);
    this.users = Object.freeze(users);
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="seo"><a href="#seo" class="header-anchor">#</a> seo</h2> <p>搜索引擎优化，更容易搜索到该页面。</p> <p>像vue这种前后端分离的开发，我们还是能够通过其他技术优化的。常用的解决方案有三种：</p> <ol><li>页面预渲染</li> <li>服务端渲染</li> <li>路由采用h5 history模式</li></ol> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <ol><li>prerender-spa-plugin这个插件是一个webpack插件，此方式会在项目构建（npm run build）时将项目按路由打包成相对应的html静态文件。因此，仅有如下项目类型适用。</li></ol> <ul><li>路由是静态的，且非海量路由</li> <li>页面内容不需要使用ajax获取并展示内容</li></ul> <ol start="2"><li>prerender此服务在页面渲染的时，将会直接取代网站后端对爬虫请求进行响应，将提前渲染后静态页面直接返回给爬虫，因为此服务作用在页面渲染时，所以不再受<code>方式1</code>那些路由限制。</li></ol> <h4 id="利用插件prerender-spa-plugin"><a href="#利用插件prerender-spa-plugin" class="header-anchor">#</a> 利用插件<code>prerender-spa-plugin</code></h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm i prerender-spa-plugin -D
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h5 id="vue-config-js配置"><a href="#vue-config-js配置" class="header-anchor">#</a> <code>vue.config.js</code>配置</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>//prerender-spa-plugin
const PrerenderSPAPlugin = require('prerender-spa-plugin')
const Renderer = PrerenderSPAPlugin.PuppeteerRenderer
module.exports = {
    if (process.env.NODE_ENV === 'production') {
        return {
          plugins: [
            new PrerenderSPAPlugin({
              // 生成文件的路径，也可以与webpakc打包的一致。
              // 下面这句话非常重要！！！
              // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。
              staticDir: path.join(__dirname,'dist'),
              // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。
              routes: ['/', '/home', '/page1'],
              // 这个很重要，如果没有配置这段，也不会进行预编译
              renderer: new Renderer({
                inject: {
                  foo: 'bar'
                },
                //headless: false,
                // 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。
                renderAfterDocumentEvent: 'render-event'
              })
            }),
          ]
        }
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h5 id="main-js配置"><a href="#main-js配置" class="header-anchor">#</a> <code>main.js</code>配置</h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>new Vue({
  mounted () {
    document.dispatchEvent(new Event('render-event'))
  }
}).$mount('#app')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h5 id="路由配置"><a href="#路由配置" class="header-anchor">#</a> 路由配置</h5> <p>这里需要用<code>history</code>模式，必须！</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const home = () =&gt; import('@/views/home/home.vue')
const page1 = () =&gt; import('@/views/home/page1.vue')
const routes = [
  {
    path: '/home',
    name: 'home',
    mode: 'history',
    component: home
  },
  {
    path: '/page1',
    name: 'page1',
    mode: 'history',
    component: page1
  }
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h5 id="配置每个路由的meta"><a href="#配置每个路由的meta" class="header-anchor">#</a> 配置每个路由的<code>meta</code></h5> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm i vue-meta -D
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在<code>main.js</code>中配置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import VueMeta from 'vue-meta'

Vue.use(VueMeta, {
  // optional pluginOptions
  refreshOnceOnNavigation: true
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>路由内的使用<code>home.vue</code></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>export default {
    name: 'home',
    components: {},
    metaInfo: {
      title: 'xxxx，代理进口公司-专注进口清关代理、国际海运、仓储物流服务',
      meta: [
        { charset: 'utf-8' },
        { name: 'keywords', content: '代理进口公司,进口清关代理,国际海运,仓储物流,xxxx'},
        { name: 'description', content: 'xxxx是全球领先的进口清关跨境贸易综合服务平台'}
      ]
    },
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>最后页面会生成keywords、description等meta标签</p> <h4 id="prerender-的使用"><a href="#prerender-的使用" class="header-anchor">#</a> prerender 的使用</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install prerender
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/cats1/vuepresshome/edit/main/docs/front/vue/README.md" target="_blank" rel="noopener noreferrer">有问题需改善此页面!</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front/vscode/eslint.html" class="prev">
        eslint
      </a></span> <span class="next"><a href="/front/vue/ssr.html">
        SSR
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4743452.js" defer></script><script src="/assets/js/2.b72805e3.js" defer></script><script src="/assets/js/120.5f45ba33.js" defer></script>
  </body>
</html>
