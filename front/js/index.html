<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js | lana&#39;s home</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="vuepress 前端个人学习网站">
    
    <link rel="preload" href="/assets/css/0.styles.98530cad.css" as="style"><link rel="preload" href="/assets/js/app.a4743452.js" as="script"><link rel="preload" href="/assets/js/2.b72805e3.js" as="script"><link rel="preload" href="/assets/js/82.f4018c72.js" as="script"><link rel="prefetch" href="/assets/js/10.97c6631e.js"><link rel="prefetch" href="/assets/js/100.ddd238ad.js"><link rel="prefetch" href="/assets/js/101.acf46de3.js"><link rel="prefetch" href="/assets/js/102.7ecc34c5.js"><link rel="prefetch" href="/assets/js/103.9abec0c7.js"><link rel="prefetch" href="/assets/js/104.99a0bd64.js"><link rel="prefetch" href="/assets/js/105.5bd4279e.js"><link rel="prefetch" href="/assets/js/106.4a1a1e6d.js"><link rel="prefetch" href="/assets/js/107.53190e25.js"><link rel="prefetch" href="/assets/js/108.afb416d9.js"><link rel="prefetch" href="/assets/js/109.9c89f8cf.js"><link rel="prefetch" href="/assets/js/11.efe147a8.js"><link rel="prefetch" href="/assets/js/110.77f01a7c.js"><link rel="prefetch" href="/assets/js/111.f8ccec3a.js"><link rel="prefetch" href="/assets/js/112.a1b70a36.js"><link rel="prefetch" href="/assets/js/113.f74d3176.js"><link rel="prefetch" href="/assets/js/114.9f4f70ac.js"><link rel="prefetch" href="/assets/js/115.3e915f82.js"><link rel="prefetch" href="/assets/js/116.21d4d9f8.js"><link rel="prefetch" href="/assets/js/117.ed1ac975.js"><link rel="prefetch" href="/assets/js/118.b60ec45f.js"><link rel="prefetch" href="/assets/js/119.a28f9722.js"><link rel="prefetch" href="/assets/js/12.f8166b62.js"><link rel="prefetch" href="/assets/js/120.5f45ba33.js"><link rel="prefetch" href="/assets/js/121.e2c73c6e.js"><link rel="prefetch" href="/assets/js/122.bea0d35f.js"><link rel="prefetch" href="/assets/js/123.4918a056.js"><link rel="prefetch" href="/assets/js/124.e9d5fd6b.js"><link rel="prefetch" href="/assets/js/125.378cd9ad.js"><link rel="prefetch" href="/assets/js/126.785be7e4.js"><link rel="prefetch" href="/assets/js/127.2dfe1120.js"><link rel="prefetch" href="/assets/js/128.0eeadbcb.js"><link rel="prefetch" href="/assets/js/129.ffd3ffd2.js"><link rel="prefetch" href="/assets/js/13.669aa6cb.js"><link rel="prefetch" href="/assets/js/130.e3caaa90.js"><link rel="prefetch" href="/assets/js/131.8914dd22.js"><link rel="prefetch" href="/assets/js/132.0ae37932.js"><link rel="prefetch" href="/assets/js/133.e989899b.js"><link rel="prefetch" href="/assets/js/134.ea062f20.js"><link rel="prefetch" href="/assets/js/135.6c137b49.js"><link rel="prefetch" href="/assets/js/14.c9aa70a1.js"><link rel="prefetch" href="/assets/js/15.3d05e5f2.js"><link rel="prefetch" href="/assets/js/16.360281d8.js"><link rel="prefetch" href="/assets/js/17.ff7cabb3.js"><link rel="prefetch" href="/assets/js/18.be16eeed.js"><link rel="prefetch" href="/assets/js/19.81b3a31e.js"><link rel="prefetch" href="/assets/js/20.472bc449.js"><link rel="prefetch" href="/assets/js/21.86395f2b.js"><link rel="prefetch" href="/assets/js/22.6c69ed50.js"><link rel="prefetch" href="/assets/js/23.2f198631.js"><link rel="prefetch" href="/assets/js/24.748c9bc2.js"><link rel="prefetch" href="/assets/js/25.c5065323.js"><link rel="prefetch" href="/assets/js/26.61d441a1.js"><link rel="prefetch" href="/assets/js/27.bfd0a986.js"><link rel="prefetch" href="/assets/js/28.bafeb054.js"><link rel="prefetch" href="/assets/js/29.0d2a1bfd.js"><link rel="prefetch" href="/assets/js/3.7f8809fd.js"><link rel="prefetch" href="/assets/js/30.8bb40757.js"><link rel="prefetch" href="/assets/js/31.eac619f5.js"><link rel="prefetch" href="/assets/js/32.04c63c5c.js"><link rel="prefetch" href="/assets/js/33.ae09c55e.js"><link rel="prefetch" href="/assets/js/34.1145a6f4.js"><link rel="prefetch" href="/assets/js/35.feb9083f.js"><link rel="prefetch" href="/assets/js/36.a586ce8a.js"><link rel="prefetch" href="/assets/js/37.c61e20e9.js"><link rel="prefetch" href="/assets/js/38.991c3427.js"><link rel="prefetch" href="/assets/js/39.23356a49.js"><link rel="prefetch" href="/assets/js/4.6819ae80.js"><link rel="prefetch" href="/assets/js/40.a3ca9111.js"><link rel="prefetch" href="/assets/js/41.649b9d9b.js"><link rel="prefetch" href="/assets/js/42.fde8ad7b.js"><link rel="prefetch" href="/assets/js/43.2d876a7c.js"><link rel="prefetch" href="/assets/js/44.64c20de7.js"><link rel="prefetch" href="/assets/js/45.a901a632.js"><link rel="prefetch" href="/assets/js/46.4ac83b64.js"><link rel="prefetch" href="/assets/js/47.2b45c49a.js"><link rel="prefetch" href="/assets/js/48.2bc12623.js"><link rel="prefetch" href="/assets/js/49.52a95dcd.js"><link rel="prefetch" href="/assets/js/5.20de2bc4.js"><link rel="prefetch" href="/assets/js/50.f445c922.js"><link rel="prefetch" href="/assets/js/51.07570e18.js"><link rel="prefetch" href="/assets/js/52.cf21a2b8.js"><link rel="prefetch" href="/assets/js/53.77792ddd.js"><link rel="prefetch" href="/assets/js/54.f19c487a.js"><link rel="prefetch" href="/assets/js/55.7fb0d05b.js"><link rel="prefetch" href="/assets/js/56.62fd0b66.js"><link rel="prefetch" href="/assets/js/57.1d6b0809.js"><link rel="prefetch" href="/assets/js/58.1aed920b.js"><link rel="prefetch" href="/assets/js/59.c2ab9dbe.js"><link rel="prefetch" href="/assets/js/6.e9784f3e.js"><link rel="prefetch" href="/assets/js/60.f4e387a9.js"><link rel="prefetch" href="/assets/js/61.735cc066.js"><link rel="prefetch" href="/assets/js/62.312489f2.js"><link rel="prefetch" href="/assets/js/63.dd2a2d4e.js"><link rel="prefetch" href="/assets/js/64.67dfd073.js"><link rel="prefetch" href="/assets/js/65.c2c22de8.js"><link rel="prefetch" href="/assets/js/66.7ea30a4b.js"><link rel="prefetch" href="/assets/js/67.6913be8c.js"><link rel="prefetch" href="/assets/js/68.b743701c.js"><link rel="prefetch" href="/assets/js/69.088259eb.js"><link rel="prefetch" href="/assets/js/7.80ddef84.js"><link rel="prefetch" href="/assets/js/70.10e2101b.js"><link rel="prefetch" href="/assets/js/71.11121db3.js"><link rel="prefetch" href="/assets/js/72.38811b9b.js"><link rel="prefetch" href="/assets/js/73.b5030976.js"><link rel="prefetch" href="/assets/js/74.d218c8d5.js"><link rel="prefetch" href="/assets/js/75.89c8d415.js"><link rel="prefetch" href="/assets/js/76.998def7e.js"><link rel="prefetch" href="/assets/js/77.6cff4b72.js"><link rel="prefetch" href="/assets/js/78.45b13ba4.js"><link rel="prefetch" href="/assets/js/79.50d5b3d0.js"><link rel="prefetch" href="/assets/js/8.4ebeab97.js"><link rel="prefetch" href="/assets/js/80.e38925eb.js"><link rel="prefetch" href="/assets/js/81.c712e794.js"><link rel="prefetch" href="/assets/js/83.878fb392.js"><link rel="prefetch" href="/assets/js/84.7ddaa3ca.js"><link rel="prefetch" href="/assets/js/85.06c8fa8b.js"><link rel="prefetch" href="/assets/js/86.b889a2e3.js"><link rel="prefetch" href="/assets/js/87.2f3171f1.js"><link rel="prefetch" href="/assets/js/88.1b0c6839.js"><link rel="prefetch" href="/assets/js/89.293034a1.js"><link rel="prefetch" href="/assets/js/9.07e73bd0.js"><link rel="prefetch" href="/assets/js/90.cdd9df6a.js"><link rel="prefetch" href="/assets/js/91.e53063a5.js"><link rel="prefetch" href="/assets/js/92.0a41da3b.js"><link rel="prefetch" href="/assets/js/93.83c37c7e.js"><link rel="prefetch" href="/assets/js/94.14eea0cb.js"><link rel="prefetch" href="/assets/js/95.18279896.js"><link rel="prefetch" href="/assets/js/96.e06d8e4e.js"><link rel="prefetch" href="/assets/js/97.2b60994e.js"><link rel="prefetch" href="/assets/js/98.28ad17a5.js"><link rel="prefetch" href="/assets/js/99.2abf3996.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98530cad.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lana's home" class="logo"> <span class="site-name can-hide">lana's home</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Backend</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Front</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/" aria-current="page" class="sidebar-link">前端</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Echarts</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Html 5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/js/" aria-current="page" class="active sidebar-link">js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#输出" class="sidebar-link">输出</a></li><li class="sidebar-sub-header"><a href="/front/js/#语句" class="sidebar-link">语句</a></li><li class="sidebar-sub-header"><a href="/front/js/#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/front/js/#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#运算符" class="sidebar-link">运算符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#算数运算符" class="sidebar-link">算数运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#赋值运算符" class="sidebar-link">赋值运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#字符串运算符" class="sidebar-link">字符串运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#比较运算符" class="sidebar-link">比较运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#逻辑运算符" class="sidebar-link">逻辑运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#类型运算符" class="sidebar-link">类型运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#位运算符" class="sidebar-link">位运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#一元运算符" class="sidebar-link">一元运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#扩展运算符" class="sidebar-link">...扩展运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#typeof运算符" class="sidebar-link">typeof运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#instanceof运算符" class="sidebar-link">instanceof运算符</a></li><li class="sidebar-sub-header"><a href="/front/js/#in-运算符" class="sidebar-link">in 运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#布尔值" class="sidebar-link">布尔值</a></li><li class="sidebar-sub-header"><a href="/front/js/#变量" class="sidebar-link">变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#暂时性死区" class="sidebar-link">暂时性死区</a></li><li class="sidebar-sub-header"><a href="/front/js/#函数作用域和块级作用域" class="sidebar-link">函数作用域和块级作用域</a></li><li class="sidebar-sub-header"><a href="/front/js/#变量提升和函数提升" class="sidebar-link">变量提升和函数提升</a></li><li class="sidebar-sub-header"><a href="/front/js/#判断变量" class="sidebar-link">判断变量</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/front/js/#柯里化-currying" class="sidebar-link">柯里化（Currying）</a></li><li class="sidebar-sub-header"><a href="/front/js/#数组" class="sidebar-link">数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#创建" class="sidebar-link">创建</a></li><li class="sidebar-sub-header"><a href="/front/js/#静态方法" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/front/js/#实例方法" class="sidebar-link">实例方法</a></li><li class="sidebar-sub-header"><a href="/front/js/#链式使用" class="sidebar-link">链式使用</a></li><li class="sidebar-sub-header"><a href="/front/js/#过滤唯一值" class="sidebar-link">过滤唯一值</a></li><li class="sidebar-sub-header"><a href="/front/js/#数组循环" class="sidebar-link">数组循环</a></li><li class="sidebar-sub-header"><a href="/front/js/#数组空位" class="sidebar-link">数组空位</a></li><li class="sidebar-sub-header"><a href="/front/js/#数组去重" class="sidebar-link">数组去重</a></li><li class="sidebar-sub-header"><a href="/front/js/#多维数组" class="sidebar-link">多维数组</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#new做了什么" class="sidebar-link">new做了什么</a></li><li class="sidebar-sub-header"><a href="/front/js/#arguments-对象" class="sidebar-link">arguments 对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#对象" class="sidebar-link">对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#创建-2" class="sidebar-link">创建</a></li><li class="sidebar-sub-header"><a href="/front/js/#变量如何做属性名" class="sidebar-link">变量如何做属性名</a></li><li class="sidebar-sub-header"><a href="/front/js/#判断对象的类型" class="sidebar-link">判断对象的类型</a></li><li class="sidebar-sub-header"><a href="/front/js/#静态方法-2" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/front/js/#实例方法-2" class="sidebar-link">实例方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#属性描述对象" class="sidebar-link">属性描述对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#object-getownpropertydescriptor" class="sidebar-link">Object.getOwnPropertyDescriptor()</a></li><li class="sidebar-sub-header"><a href="/front/js/#object-getownpropertynames-2" class="sidebar-link">Object.getOwnPropertyNames()</a></li><li class="sidebar-sub-header"><a href="/front/js/#object-defineproperty-、object-defineproperties" class="sidebar-link">Object.defineProperty()、Object.defineProperties()</a></li><li class="sidebar-sub-header"><a href="/front/js/#object-prototype-propertyisenumerable" class="sidebar-link">Object.prototype.propertyIsEnumerable()</a></li><li class="sidebar-sub-header"><a href="/front/js/#存取器" class="sidebar-link">存取器</a></li><li class="sidebar-sub-header"><a href="/front/js/#对象的拷贝" class="sidebar-link">对象的拷贝</a></li><li class="sidebar-sub-header"><a href="/front/js/#控制对象状态" class="sidebar-link">控制对象状态</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#字符串" class="sidebar-link">字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#静态方法-3" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/front/js/#实例属性" class="sidebar-link">实例属性</a></li><li class="sidebar-sub-header"><a href="/front/js/#实例方法-3" class="sidebar-link">实例方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#symbol" class="sidebar-link">Symbol</a></li><li class="sidebar-sub-header"><a href="/front/js/#json" class="sidebar-link">JSON</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#静态方法-4" class="sidebar-link">静态方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#原型与原型链" class="sidebar-link">原型与原型链</a></li><li class="sidebar-sub-header"><a href="/front/js/#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/front/js/#关键字" class="sidebar-link">关键字</a></li><li class="sidebar-sub-header"><a href="/front/js/#this" class="sidebar-link">this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#this的绑定规则" class="sidebar-link">this的绑定规则</a></li><li class="sidebar-sub-header"><a href="/front/js/#绑定规则的优先级" class="sidebar-link">绑定规则的优先级</a></li><li class="sidebar-sub-header"><a href="/front/js/#call、apply、bind区别" class="sidebar-link">call、apply、bind区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#错误类型" class="sidebar-link">错误类型</a></li><li class="sidebar-sub-header"><a href="/front/js/#类型转换" class="sidebar-link">类型转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#转换boolean型" class="sidebar-link">转换Boolean型</a></li><li class="sidebar-sub-header"><a href="/front/js/#转换string型" class="sidebar-link">转换String型</a></li><li class="sidebar-sub-header"><a href="/front/js/#转换number类型" class="sidebar-link">转换Number类型</a></li><li class="sidebar-sub-header"><a href="/front/js/#快速float转integer" class="sidebar-link">快速Float转Integer</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#event-loop" class="sidebar-link">Event Loop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/#多进程与多线程" class="sidebar-link">多进程与多线程</a></li><li class="sidebar-sub-header"><a href="/front/js/#浏览器内核" class="sidebar-link">浏览器内核</a></li><li class="sidebar-sub-header"><a href="/front/js/#浏览器中的-event-loop" class="sidebar-link">浏览器中的 Event Loop</a></li><li class="sidebar-sub-header"><a href="/front/js/#node-中的-event-loop" class="sidebar-link">Node 中的 Event Loop</a></li><li class="sidebar-sub-header"><a href="/front/js/#node与浏览器的-event-loop-差异" class="sidebar-link">Node与浏览器的 Event Loop 差异</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/#简写技巧" class="sidebar-link">简写技巧</a></li><li class="sidebar-sub-header"><a href="/front/js/#实践" class="sidebar-link">实践</a></li><li class="sidebar-sub-header"><a href="/front/js/#基本规范" class="sidebar-link">基本规范</a></li></ul></li><li><a href="/front/js/currying.html" class="sidebar-link">柯里化</a></li><li><a href="/front/js/es.html" class="sidebar-link">es</a></li><li><a href="/front/js/es5-es6-typescript.html" class="sidebar-link">/front/js/es5-es6-typescript.html</a></li><li><a href="/front/js/generator.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/front/js/httpxie-yi.html" class="sidebar-link">HTTP协议</a></li><li><a href="/front/js/promise.html" class="sidebar-link">Promise</a></li><li><a href="/front/js/symbol.html" class="sidebar-link">Symbol</a></li><li><a href="/front/js/array.html" class="sidebar-link">数组</a></li><li><a href="/front/js/async.html" class="sidebar-link">async 函数</a></li><li><a href="/front/js/class.html" class="sidebar-link">class</a></li><li><a href="/front/js/function.html" class="sidebar-link">函数</a></li><li><a href="/front/js/javascript.html" class="sidebar-link">/front/js/javascript.html</a></li><li><a href="/front/js/js-question.html" class="sidebar-link">JavaScript 进阶问题</a></li><li><a href="/front/js/jsji-chu.html" class="sidebar-link">js基础</a></li><li><a href="/front/js/jsxiao-ji-qiao.html" class="sidebar-link">JS 中的!与!!用法</a></li><li><a href="/front/js/jsnan-dian.html" class="sidebar-link">JavaScript难点</a></li><li><a href="/front/js/let.html" class="sidebar-link">es6</a></li><li><a href="/front/js/module.html" class="sidebar-link">module</a></li><li><a href="/front/js/momentjs.html" class="sidebar-link">momentjs</a></li><li><a href="/front/js/object.html" class="sidebar-link">对象</a></li><li><a href="/front/js/set.html" class="sidebar-link">Set</a></li><li><a href="/front/js/style.html" class="sidebar-link">编程风格</a></li><li><a href="/front/js/shi-jian-mo-xing.html" class="sidebar-link">事件模型</a></li><li><a href="/front/js/ben-di-cun-chu-.html" class="sidebar-link">本地存储</a></li><li><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html" class="sidebar-link">浏览器渲染原理</a></li><li><a href="/front/js/bi-bao.html" class="sidebar-link">闭包</a></li><li><a href="/front/js/fang-dou-yu-jie-liu.html" class="sidebar-link">防抖（debounce）</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Treejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vscode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Guide</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js"><a href="#js" class="header-anchor">#</a> js</h1> <h2 id="输出"><a href="#输出" class="header-anchor">#</a> 输出</h2> <ul><li>使用 window.alert() 写入警告框</li> <li>使用 document.write() 写入 HTML 输出</li> <li>使用 innerHTML 写入 HTML 元素</li> <li>使用 console.log() 写入浏览器控制台</li></ul> <h2 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h2> <p>在JavaScript中，我们不必显式地编写分号(<code>;</code>)，但是JavaScript引擎仍然在语句之后自动添加分号。这称为<strong>自动分号插入</strong>。例如，一个语句可以是变量，或者像<code>throw</code>、<code>return</code>、<code>break</code>这样的关键字。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>return 
  a + b
  
 实际转化
   return;
  a + b
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> <strong>数据类型</strong></h2> <p>JavaScript 中的一切都是基本类型和对象。</p> <p>数据分为基本数据类型和引用数据类型。</p> <ul><li><strong>基本数据类型</strong>：String、Number、Boolean、Null、Undefined、Symbol、<code>bigint</code>。基本数据类型是直接存储在栈中的数据。</li> <li><strong>引用数据类型</strong>：Array、Object。引用数据类型存储的是该对象在栈中引用，真实的数据存储在内存中。</li></ul> <p>基本类型包括 <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, <code>number</code>, <code>string</code>, <code>symbol</code>。</p> <p><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p> <p><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</p> <ul><li>数值（number）：整数和小数（比如<code>1</code>和<code>3.14</code>）</li> <li>字符串（string）：文本（比如<code>Hello World</code>）。</li> <li>布尔值（boolean）：表示真伪的两个特殊值，即<code>true</code>（真）和<code>false</code>（假）</li> <li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li> <li><code>null</code>：表示空值，即此处的值为空。</li> <li>对象（object）：各种值组成的集合。</li></ul> <p>Object 是 JavaScript 中所有对象的父对象</p> <p>数据封装类对象：Object、Array、Boolean、Number 和 String</p> <p>其他对象：Function、Arguments、Math、Date、RegExp、Error</p> <p>新类型：Symbol</p> <p>Undefined 与 null 的值相等，但类型不相等：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>typeof undefined              // undefined
typeof null                   // object
null === undefined            // false
null == undefined             // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>赋值：引用地址的拷贝。修改赋值后的数据，不管是基本数据类型还是引用数据类型，都会影响到原数据。</p> <p>浅拷贝：一层拷贝。在浅拷贝中，修改基本数据类型不会影响原有数据的基本数据类型，修改引用数据类型会影响原有的数据类型。</p> <p>深拷贝：无限层级拷贝。在深拷贝中，修改基本数据类型和引用数据类型都不会影响原有的数据类型。</p> <table><thead><tr><th></th> <th>和原数据是否指向同一对象</th> <th>原数据为基本数据类型</th> <th>原数据包含子对象</th></tr></thead> <tbody><tr><td>赋值</td> <td>是</td> <td>改变【会】使原数据一同改变</td> <td>改变【会】使原数据一同改变</td></tr> <tr><td>浅拷贝</td> <td>否</td> <td>改变【不会】使原数据一同改变</td> <td>改变【会】使原数据一同改变</td></tr> <tr><td>深拷贝</td> <td>否</td> <td>改变【不会】使原数据一同改变</td> <td>改变【不会】使原数据一同改变</td></tr></tbody></table> <h3 id="浅拷贝"><a href="#浅拷贝" class="header-anchor">#</a> 浅拷贝</h3> <p>对基本类型变量，浅拷贝是对值的拷贝，没有深拷贝的概念。对引用类型来说，浅拷贝是对对象地址的拷贝，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，另外一个对象的属性也会改变， 而深拷贝则是开辟新的栈。</p> <p>Object.assign()<code>Object.assign()</code> 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。需要注意的是，<code>Object.assgin()</code> 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p> <p>Array.prototype.concat()是数组的一个内置方法，用户合并两个或者多个数组。这个方法不会改变现有数组，而是返回一个新数组。</p> <p>Array.prototype.slice()也是数组的一个内置方法，该方法会返回一个新的对象。不会改变原数组。</p> <p>...obj 展开运算符</p> <h3 id="深拷贝"><a href="#深拷贝" class="header-anchor">#</a> 深拷贝</h3> <p>转JSON再解析回来原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一来一回之间，新的对象产生了，而且对象会开辟新的栈，实现深拷贝</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JSON.parse(JSON.stringify(obj1))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><table><thead><tr><th>值</th> <th>转换规则</th></tr></thead> <tbody><tr><td>Number</td> <td>直接输出</td></tr> <tr><td>String</td> <td>若字符串为空，则转换成 0 若字符串中包含有效的整数格式，则转换成十进制数 若字符串中包含有效的浮点格式，则转换成浮点数值 若字符串中包含有效的十六进制格式，则转换成十六进制数 其余情况，转换成 NaN</td></tr> <tr><td>Boolean</td> <td>若为 true ，转换成 1 若为 false，转换成 0</td></tr> <tr><td>Null</td> <td>转换成 0</td></tr> <tr><td>Undefined</td> <td>转换成 NaN</td></tr> <tr><td>Object</td> <td>调用 Object 的 <code>valueOf()</code> 方法，按照上述规则转换 若为 NaN，调用 Object 的<code>toString()</code> 方法，按照上述规则转换</td></tr></tbody></table> <p>转换规则如下：</p> <table><thead><tr><th>值</th> <th>转换规则</th></tr></thead> <tbody><tr><td>Number</td> <td>转换成数字值</td></tr> <tr><td>String</td> <td>直接输出</td></tr> <tr><td>Boolean</td> <td>若为 true ，转换成 true 若为 false，转换成 false</td></tr> <tr><td>Null</td> <td>转换成 null</td></tr> <tr><td>Undefined</td> <td>转换成 undefined</td></tr> <tr><td>Object</td> <td>按特定的规则转换</td></tr></tbody></table> <table><thead><tr><th>值</th> <th>转换规则</th></tr></thead> <tbody><tr><td>Number</td> <td>0、NaN 转换成 false 其余情况转换成 true</td></tr> <tr><td>String</td> <td>空字符串转换成 false 其余情况转换成 true</td></tr> <tr><td>Null</td> <td>转换成 false</td></tr> <tr><td>Undefined</td> <td>转换成 false</td></tr> <tr><td>Object</td> <td>转换成 true</td></tr></tbody></table> <table><thead><tr><th>顺序</th> <th>变量 1</th> <th>变量 2</th> <th>操作</th></tr></thead> <tbody><tr><td>1</td> <td>NaN</td> <td>*</td> <td>返回 false</td></tr> <tr><td>2</td> <td>Null</td> <td>Undefined</td> <td>返回 true</td></tr> <tr><td>3</td> <td>Null</td> <td>Null</td> <td>返回 true</td></tr> <tr><td>4</td> <td>Undefined</td> <td>Undefined</td> <td>返回 true</td></tr> <tr><td>5</td> <td>Null</td> <td>除 Null、Undefined 外</td> <td>返回 false</td></tr> <tr><td>6</td> <td>Undefined</td> <td>除 Null、Undefined 外</td> <td>返回 false</td></tr> <tr><td>7</td> <td>Boolean</td> <td>*</td> <td>将 Boolean 转换成 Number 后比较</td></tr> <tr><td>8</td> <td>Object</td> <td>Object</td> <td>当两个对象指向同一内存地址时，才会相等</td></tr> <tr><td>9</td> <td>Object</td> <td>Number、String</td> <td>将 Object 转换成原始值 (Number/String) 后比较 首先使用 <code>valueOf()</code> 方法 若对象能转换成原始值，则返回结果 否则使用 <code>toString()</code> 方法 若对象能转换成原始值，则返回结果 否则抛出 <code>TypeError</code> 异常</td></tr> <tr><td>10</td> <td>Number</td> <td>Number</td> <td>直接比较</td></tr> <tr><td>11</td> <td>String</td> <td>String</td> <td>直接比较</td></tr> <tr><td>12</td> <td>String</td> <td>Number</td> <td>将 String 转换成 Number 后比较</td></tr></tbody></table> <h2 id="运算符"><a href="#运算符" class="header-anchor">#</a> 运算符</h2> <h3 id="算数运算符"><a href="#算数运算符" class="header-anchor">#</a> 算数运算符</h3> <p>算数运算符用于对数字执行算数运算：</p> <table><thead><tr><th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>+</td> <td>加法</td></tr> <tr><td>-</td> <td>减法</td></tr> <tr><td>*</td> <td>乘法</td></tr> <tr><td>**</td> <td>幂（<a href="https://www.w3school.com.cn/js/js_es6.asp" target="_blank" rel="noopener noreferrer">ES2016<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）x ** y 产生的结果与 Math.pow(x,y) 相同:</td></tr> <tr><td>/</td> <td>除法</td></tr> <tr><td>%</td> <td>系数返回除法的余数</td></tr> <tr><td>++</td> <td>递加</td></tr> <tr><td>--</td> <td>递减</td></tr></tbody></table> <p>乘法还有一些特殊行为</p> <ul><li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li> <li>如果某个运算数是 NaN，结果为 NaN。</li> <li>Infinity 乘以 0，结果为 NaN。</li> <li>Infinity 乘以 0 以外的任何数字，结果为 Infinity 或 -Infinity。</li> <li>Infinity 乘以 Infinity，结果为 Infinity。</li></ul> <p>除法运算符也有一些特殊行为：</p> <ul><li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li> <li>如果某个运算数是 NaN，结果为 NaN。</li> <li>Infinity 被 Infinity 除，结果为 NaN。</li> <li>Infinity 被任何数字除，结果为 Infinity。</li> <li>0 除一个任何非无穷大的数字，结果为 NaN。</li> <li>Infinity 被 0 以外的任何数字除，结果为 Infinity 或 -Infinity。</li></ul> <p>取模运算符也有特殊的行为：</p> <ul><li>如果被除数是 Infinity，或除数是 0，结果为 NaN。</li> <li>Infinity 被 Infinity 除，结果为 NaN。</li> <li>如果除数是无穷大的数，结果为被除数。</li> <li>如果被除数为 0，结果为 0。</li></ul> <p>加法也有一些特殊行为：</p> <ul><li>某个运算数是 NaN，那么结果为 NaN。</li> <li>-Infinity 加 -Infinity，结果为 -Infinity。</li> <li>Infinity 加 -Infinity，结果为 NaN。</li> <li>+0 加 +0，结果为 +0。</li> <li>-0 加 +0，结果为 +0。</li> <li>-0 加 -0，结果为 -0。</li></ul> <p>减法运算符也有一些特殊行为：</p> <ul><li>某个运算数是 NaN，那么结果为 NaN。</li> <li>Infinity 减 Infinity，结果为 NaN。</li> <li>-Infinity 减 -Infinity，结果为 NaN。</li> <li>Infinity 减 -Infinity，结果为 Infinity。</li> <li>-Infinity 减 Infinity，结果为 -Infinity。</li> <li>+0 减 +0，结果为 +0。</li> <li>-0 减 -0，结果为 -0。</li> <li>+0 减 -0，结果为 +0。</li> <li>某个运算符不是数字，那么结果为 NaN。</li></ul> <h3 id="赋值运算符"><a href="#赋值运算符" class="header-anchor">#</a> 赋值运算符</h3> <p>赋值运算符向 JavaScript 变量赋值。</p> <table><thead><tr><th>运算符</th> <th>例子</th> <th>等同于</th></tr></thead> <tbody><tr><td>=</td> <td>x = y</td> <td>x = y</td></tr> <tr><td>+=</td> <td>x += y</td> <td>x = x + y</td></tr> <tr><td>-=</td> <td>x -= y</td> <td>x = x - y</td></tr> <tr><td>*=</td> <td>x *= y</td> <td>x = x * y</td></tr> <tr><td>/=</td> <td>x /= y</td> <td>x = x / y</td></tr> <tr><td>%=</td> <td>x %= y</td> <td>x = x % y</td></tr> <tr><td>&lt;&lt;=</td> <td>x &lt;&lt;= y</td> <td>x = x &lt;&lt; y</td></tr> <tr><td>&gt;&gt;=</td> <td>x &gt;&gt;= y</td> <td>x = x &gt;&gt; y</td></tr> <tr><td>&gt;&gt;&gt;=</td> <td>x &gt;&gt;&gt;= y</td> <td>x = x &gt;&gt;&gt; y</td></tr> <tr><td>&amp;=</td> <td>x &amp;= y</td> <td>x = x &amp; y</td></tr> <tr><td>^=</td> <td>x ^= y</td> <td>x = x ^ y</td></tr> <tr><td>|=</td> <td>x |= y</td> <td>x = x | y</td></tr> <tr><td>**=</td> <td>x **= y</td> <td>x = x ** y</td></tr></tbody></table> <p>加法赋值运算符（+=）向变量添加一个值。</p> <h3 id="字符串运算符"><a href="#字符串运算符" class="header-anchor">#</a> 字符串运算符</h3> <ul><li>+在用于字符串时，+ 运算符被称为级联运算符。</li> <li>+=</li></ul> <h3 id="比较运算符"><a href="#比较运算符" class="header-anchor">#</a> 比较运算符</h3> <table><thead><tr><th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>==</td> <td>等于</td></tr> <tr><td>===</td> <td>等值等型</td></tr> <tr><td>!=</td> <td>不相等</td></tr> <tr><td>!==</td> <td>不等值或不等型</td></tr> <tr><td>&gt;</td> <td>大于</td></tr> <tr><td>&lt;</td> <td>小于</td></tr> <tr><td>&gt;=</td> <td>大于或等于</td></tr> <tr><td>&lt;=</td> <td>小于或等于</td></tr> <tr><td>?</td> <td>三元运算符</td></tr></tbody></table> <h4 id="比较数字和字符串"><a href="#比较数字和字符串" class="header-anchor">#</a> 比较数字和字符串</h4> <p>两个运算数都是字符串，所以比较的是它们的字符代码（&quot;2&quot; 的字符代码是 50，&quot;3&quot; 的字符代码是 51）。</p> <p>无论何时比较一个数字和一个字符串，ECMAScript 都会把字符串转换成数字，然后按照数字顺序比较它们。</p> <h4 id="等号和非等号"><a href="#等号和非等号" class="header-anchor">#</a> 等号和非等号</h4> <p>为确定两个运算数是否相等，这两个运算符都会进行类型转换。</p> <p>执行类型转换的规则如下：</p> <ul><li>如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。</li> <li>如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。</li> <li>如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。</li> <li>如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。</li></ul> <p>在比较时，该运算符还遵守下列规则：</p> <ul><li>值 null 和 undefined 相等。</li> <li>在检查相等性时，不能把 null 和 undefined 转换成其他值。</li> <li>如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。</li> <li>如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。</li></ul> <h4 id="全等号和非全等号"><a href="#全等号和非全等号" class="header-anchor">#</a> 全等号和非全等号</h4> <p>在检查相等性前，不执行类型转换。</p> <h3 id="逻辑运算符"><a href="#逻辑运算符" class="header-anchor">#</a> 逻辑运算符</h3> <table><thead><tr><th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>&amp;&amp;</td> <td>逻辑与</td></tr> <tr><td>||</td> <td>逻辑或</td></tr> <tr><td>!</td> <td>逻辑非</td></tr></tbody></table> <p><strong>逻辑 NOT 运算符返回的一定是 Boolean 值</strong>。</p> <p>逻辑 NOT 运算符的行为如下：</p> <ul><li>如果运算数是对象，返回 false</li> <li>如果运算数是数字 0，返回 true</li> <li>如果运算数是 0 以外的任何数字，返回 false</li> <li>如果运算数是 null，返回 true</li> <li>如果运算数是 NaN，返回 true</li> <li>如果运算数是 undefined，发生错误</li></ul> <p><strong>逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值。</strong></p> <p>如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值：</p> <ul><li>如果一个运算数是对象，另一个是 Boolean 值，返回该对象。</li> <li>如果两个运算数都是对象，返回第二个对象。</li> <li>如果某个运算数是 null，返回 null。</li> <li>如果某个运算数是 NaN，返回 NaN。</li> <li>如果某个运算数是 undefined，发生错误。</li></ul> <p>逻辑 OR 运算并不一定返回 Boolean 值：</p> <ul><li>如果一个运算数是对象，并且该对象左边的运算数值均为 false，则返回该对象。</li> <li>如果两个运算数都是对象，返回第一个对象。</li> <li>如果最后一个运算数是 null，并且其他运算数值均为 false，则返回 null。</li> <li>如果最后一个运算数是 NaN，并且其他运算数值均为 false，则返回 NaN。</li> <li>如果某个运算数是 undefined，发生错误。</li></ul> <p>使用<code>||</code>运算符，我们可以返回第一个真值。 如果所有值都是假值，则返回最后一个值。</p> <h3 id="类型运算符"><a href="#类型运算符" class="header-anchor">#</a> 类型运算符</h3> <table><thead><tr><th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>typeof</td> <td>返回变量的类型。</td></tr> <tr><td>instanceof</td> <td>返回 true，如果对象是对象类型的实例。</td></tr></tbody></table> <h3 id="位运算符"><a href="#位运算符" class="header-anchor">#</a> 位运算符</h3> <p>位运算符处理 32 位数。</p> <p>该运算中的任何数值运算数都会被转换为 32 位的数。结果会被转换回 JavaScript 数。</p> <table><thead><tr><th>运算符</th> <th>描述</th> <th>例子</th> <th>等同于</th> <th>结果</th> <th>十进制</th></tr></thead> <tbody><tr><td>&amp;</td> <td>与</td> <td>5 &amp; 1</td> <td>0101 &amp; 0001</td> <td>0001</td> <td>1</td></tr> <tr><td>|</td> <td>或</td> <td>5 | 1</td> <td>0101 | 0001</td> <td>0101</td> <td>5</td></tr> <tr><td>~</td> <td>非</td> <td>~ 5</td> <td>~0101</td> <td>1010</td> <td>10</td></tr> <tr><td>^</td> <td>异或</td> <td>5 ^ 1</td> <td>0101 ^ 0001</td> <td>0100</td> <td>4</td></tr> <tr><td>&lt;&lt;</td> <td>零填充左位移</td> <td>5 &lt;&lt; 1</td> <td>0101 &lt;&lt; 1</td> <td>1010</td> <td>10</td></tr> <tr><td>&gt;&gt;</td> <td>有符号右位移</td> <td>5 &gt;&gt; 1</td> <td>0101 &gt;&gt; 1</td> <td>0010</td> <td>2</td></tr> <tr><td>&gt;&gt;&gt;</td> <td>零填充右位移</td> <td>5 &gt;&gt;&gt; 1</td> <td>0101 &gt;&gt;&gt; 1</td> <td>0010</td> <td>2</td></tr></tbody></table> <h3 id="一元运算符"><a href="#一元运算符" class="header-anchor">#</a> <strong>一元运算符</strong></h3> <table><thead><tr><th>运算符</th> <th>描述</th></tr></thead> <tbody><tr><td>delete</td> <td>返回布尔值，删除对以前定义的对象属性或方法的引用</td></tr> <tr><td>void</td> <td>对任何值返回 undefined</td></tr> <tr><td>前增量运算符++</td> <td>就是数值上加 1</td></tr> <tr><td>前减量运算符--</td> <td>是从数值上减 1</td></tr> <tr><td>后增量运算符++</td> <td></td></tr> <tr><td>后减量运算符--</td> <td></td></tr> <tr><td>一元加法</td> <td>一元加法对数字无作用，但对字符串却有有趣的效果，会把字符串转换成数字</td></tr> <tr><td>一元减法</td> <td>一元减法运算符也会把字符串转换成近似的数字，此外还会对该值求负</td></tr></tbody></table> <h4 id="delete"><a href="#delete" class="header-anchor">#</a> delete</h4> <p>操作符返回一个布尔值： <code>true</code>指删除成功，否则返回<code>false</code>. 但是通过 <code>var</code>, <code>const</code> 或 <code>let</code> 关键字声明的变量无法用 <code>delete</code> 操作符来删除。</p> <h3 id="扩展运算符"><a href="#扩展运算符" class="header-anchor">#</a> ...扩展运算符</h3> <p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p> <ul><li><code>typeof</code>运算符</li> <li><code>instanceof</code>运算符</li> <li><code>Object.prototype.toString</code>方法</li></ul> <h3 id="typeof运算符"><a href="#typeof运算符" class="header-anchor">#</a> <code>typeof</code>运算符</h3> <p>可以返回一个值的数据类型。</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>undefined</li> <li><code>function</code></li> <li><code>object</code></li></ul> <p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。函数返回<code>function</code>。<code>undefined</code>返回<code>undefined</code>。对象返回<code>object</code>。<code>null</code>返回<code>object</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>typeof 123 // &quot;number&quot;
typeof '123' // &quot;string&quot;
typeof false // &quot;boolean&quot;
function f() {}
typeof f
// &quot;function&quot;
typeof undefined
// &quot;undefined&quot;
//typeof可以用来检查一个没有声明的变量，而不报错。
typeof v
// &quot;undefined&quot;
// 错误的写法
if (v) {
  // ...
}
// ReferenceError: v is not defined
// 正确的写法
if (typeof v === &quot;undefined&quot;) {
  // ...
}
typeof window // &quot;object&quot;
typeof {} // &quot;object&quot;
typeof [] // &quot;object&quot;
typeof null // &quot;object&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="instanceof运算符"><a href="#instanceof运算符" class="header-anchor">#</a> <code>instanceof</code>运算符</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>var o = {};
var a = [];
o instanceof Array // false
a instanceof Array // true
o instanceof Object // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="in-运算符"><a href="#in-运算符" class="header-anchor">#</a> in 运算符</h3> <p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = [ 'a', 'b', 'c' ];
2 in arr  // true
'2' in arr // true
4 in arr // false
//数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。
arr[100] = 'a';
100 in arr // true
1 in arr // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p> <h2 id="布尔值"><a href="#布尔值" class="header-anchor">#</a> 布尔值</h2> <p>**<code>Boolean</code>**对象是一个布尔值的对象包装器。</p> <h2 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h2> <p>JavaScript 变量是存储数据值的容器。</p> <p><code>var</code>：</p> <ul><li><code>var</code> 可以重复声明</li> <li>作用域：全局作用域 和 函数作用域</li> <li>会进行预解析</li></ul> <p><code>let</code>：</p> <ul><li>统一作用域下不能重复声明</li> <li>作用域：全局作用域 和 块级作用域 <code>{}</code></li> <li>不进行预解析</li></ul> <p><code>const</code>：</p> <ul><li><code>let</code> 有的它也有</li> <li>初始化必须赋值</li> <li>赋值后不能改动类型</li></ul> <p><code>const</code> 关键字意味着我们不能 <em>重定义</em> 变量中的值，它 <em>仅可读</em>。而然，值本身不可修改。数组 <code>emojis</code> 中的值可被修改，如 push 新的值, 拼接，又或者将数组的长度设置为0。</p> <p><code>let</code> 和 <code>var</code> 比较：</p> <ul><li><code>var</code> 声明的变量只能是全局或者整个函数块的</li> <li><code>let</code> 允许声明一个在作用域限制在块级的变量、语句或者表达式（块级作用域）</li> <li><code>let</code> 不能重复声明</li> <li><code>let</code> 存在临时死区（temporal dead zone）</li> <li><code>let</code> 不会被预解析（hoisting）</li></ul> <h3 id="暂时性死区"><a href="#暂时性死区" class="header-anchor">#</a> 暂时性死区</h3> <p>只要块级作用域内存在 <code>let</code>/<code>const</code> 命令，它所声明的变量就绑定这个区域，不再受外部的影响。</p> <p>在代码块内，使用 <code>let</code>/<code>const</code> 声明变量之前，该变量都是不可用的，所以叫 “暂时性死区”。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Uncaught ReferenceError: Cannot access 'a' before initialization</span>
其原因是在同一个 block 中，<span class="token keyword">let</span> 在后面重新定义的，那么就不能在之前引用该变量。同时，也不能取嵌套外层的值。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="函数作用域和块级作用域"><a href="#函数作用域和块级作用域" class="header-anchor">#</a> 函数作用域和块级作用域</h3> <ul><li><strong>函数作用域</strong>：在 JavaScript 中定义一个函数，函数内部的变量只能通过函数内部访问，同时它可以修改和影响外部变量。</li> <li><strong>块级作用域</strong>：变量在离开定义的块级代码后立即被回收，存在暂时性死区的特性。</li></ul> <p>在 ES5 中只有全局作用域和函数作用域，没有块级作用域，这会带来些许麻烦：</p> <ol><li><p>内层变量覆盖外层变量</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>循环的变量泄露为全局变量</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ol> <p>通过 <code>var</code> 声明的变量或者非严格模式下（non-strict mode）创建的函数声明没有块级作用域。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>为了解决这个问题，ES6 新增了块级作用域：</p> <ul><li>块语句用于组合零个或者多个语句，这个块由一对大括号 <code>{}</code> 界定。</li></ul> <p>ES5 形成块级作用域的方法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>ES6 通过 {} 界定</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 或者 const x = 1;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="header-anchor">#</a> 变量提升和函数提升</h3> <p>函数提升就是为了解决相互递归的问题，大体上可以解决自下而上的顺序问题。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 验证偶数
function isEven(n) {
  if (n === 0) {
    return true;
  }
  return isOdd(n - 1);
}
console.log(isEven(2)); // true
// 验证奇数
function isOdd(n) {
  if (n === 0) {
    return false;
  }
  return isEven(n - 1);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如果没有函数提升，而是按照自下而上的顺序，当 <code>isEven</code> 函数被调用时，<code>isOdd</code> 函数还未声明，所以在 <code>isEven</code> 内部无法调用 <code>isOdd</code> 函数。</p> <p>变量提升</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
输出：<span class="token keyword">undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> 打印的时候，因为 a 声明了但是没有填写值，所以是 <span class="token keyword">undefined</span>。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>换成 <code>let</code> 或者 <code>const</code> 语句呢？就会出现 <strong>暂时性死区</strong>。</p> <p>函数提升：<strong>函数是一等公民</strong></p> <p>题目一：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var foo = 3;
function getFoo() {
  var foo = foo || 5;
  console.log(foo); // 输出 5
}
getFoo();
等价于
function getFoo() {
  var foo;
  foo = foo || 5;
  console.log(foo);
}
var foo;
foo = 3;
getFoo();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>题目二：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getFoo() {
  foo();
  var foo = function() {
    console.log(1);
  }
  foo();
  function foo() {
    console.log(2);
  }
  foo();
}
getFoo();
等价于
function getFoo() {
  var foo;
  function foo() {
    console.log(2);
  }
  foo(); // 2
  foo = function() {
    console.log(1);
  }
  foo(); // 1
  foo(); // 1
}
getFoo();

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>题目三：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'aa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
等价于
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'aa'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//输出</span>
ƒ <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token number">100</span>
Uncaught TypeError<span class="token operator">:</span> a is not a <span class="token keyword">function</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>题目四：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = 1;
function b() {
  a = 10;
  return;
  function a() {}
}
b();
console.log(a);
输出1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>题目五：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function foo() {
  function bar() {
    return 3;
  }
  return bar();
  function bar() {
    return 8;
  }
}
console.log(foo());
//输出
8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>题目六：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var foo = { n: 1 };
(function(foo) {
  console.log(foo.n);
  foo.n = 3;
  foo = { n: 2 };
  console.log(foo.n);
})(foo)
console.log(foo.n);
var foo = { n: 1 };
(function(foo){            // 形参 foo 同实参 foo 一样指向同一片内存空间，这个空间里的 n 的值为 1
    var foo;               // 优先级低于形参，无效。
    console.log(foo.n);    // 输出 1
    foo.n = 3;             // 形参与实参 foo 指向的内存空间里的 n 的值被改为 3
    foo = { n: 2 };        // 形参 foo 指向了新的内存空间，里面 n 的值为 2.
    console.log(foo.n);    // 输出新的内存空间的 n 的值
})(foo);
console.log(foo.n);        // 实参 foo 的指向还是原来的内存空间，里面的 n 的值为 3.
输出：1 2 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="判断变量"><a href="#判断变量" class="header-anchor">#</a> 判断变量</h3> <ul><li><code>typeof(variable)</code></li> <li><code>variable instanceof Array</code></li> <li><code>variable.constructor = Array</code></li> <li><code>Object.prototype.toString.call(variable)</code></li></ul> <p><code>typeof</code> 能区分的有：</p> <ul><li><code>number</code></li> <li><code>string</code></li> <li><code>boolean</code></li> <li><code>undefined</code></li> <li><code>function</code></li> <li><code>object</code></li></ul> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">NaN</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">typeof</span> <span class="token number">10n</span><span class="token punctuation">;</span> <span class="token comment">// bigint</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// symbol</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>instanceof</p> <p><code>instanceof</code> 判断原型链指向</p> <p><code>instanceof</code> 能判断的有：</p> <ul><li><code>Array</code></li> <li><code>Function</code></li> <li><code>Date</code></li> <li><code>RegExp</code></li> <li><code>Error</code></li> <li><code>Object</code></li></ul> <p>constructor</p> <p>除了 <code>undefined</code> 和 <code>null</code>，其他类型基本可以通过 <code>constructor</code> 判断。</p> <ul><li>Tom.constructor === Person</li> <li>num.constructor === Number</li> <li>str.constructor === String</li> <li>bool.constructor === Boolean</li> <li>arr.constructor === Array</li> <li>json.constructor === Object</li> <li>func.constructor === Function</li> <li>date.constructor === Date</li> <li>reg.constructor === RegExp</li> <li>error.constructor === Error</li></ul> <p>Array.prototype.toString.call</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// [object Number]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。</p> <p><strong>在函数 A 中还有函数 B，函数 B 调用了函数 A 中的变量，那么函数 B 就称为函数 A 的闭包。</strong></p> <p>好处：</p> <ol><li>缓存。将变量隐藏起来不被 GC 回收。</li> <li>实现柯里化。利用闭包特性完成柯里化。</li></ol> <p>坏处：</p> <ol><li>内存消耗。闭包产生的变量无法被销毁。</li> <li>性能问题。由于闭包内部变量优先级高于外部变量，所以需要多查找作用域链的一个层次，一定程度影响查找速度。</li></ol> <h2 id="柯里化-currying"><a href="#柯里化-currying" class="header-anchor">#</a> 柯里化（Currying）</h2> <p>柯里化（Currying）是把接受多个参数的函数转变为单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p> <p>柯里化是把一个多参数函数转换成一个嵌套的一元函数的过程；当函数有多个参数时先传递一部分参数调用（这部分参数永远不变），然后返回新的函数接收剩余的参数。</p> <p><strong>简单来说</strong>：</p> <ol><li>通过闭包管理</li> <li>支持链式调用</li> <li>每次运行返回一个 <code>function</code></li></ol> <p>即：通过将多个参数换成一个参数，每次运行返回新函数的技术</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//普通的 add 函数</span>
<span class="token keyword">function</span> <span class="token function">add</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//柯里化函数</span>
<span class="token keyword">function</span> <span class="token function">curryingAdd</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">curryingAdd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>好处：</p> <ol><li>参数复用</li> <li>提前确认</li> <li>延迟运行</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 正则表达式</span>
<span class="token comment">// 校验数字</span>
<span class="token keyword">let</span> numberReg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[0-9]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token comment">// 校验小写字母</span>
<span class="token keyword">let</span> stringReg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z]+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token comment">// currying 后</span>
<span class="token keyword">function</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span><span class="token parameter">reg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 校验数字</span>
<span class="token keyword">let</span> checkNumber <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span>numberReg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> checkString <span class="token operator">=</span> <span class="token function">curryingCheck</span><span class="token punctuation">(</span>stringReg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkNumber</span><span class="token punctuation">(</span><span class="token string">'13888888888'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">checkString</span><span class="token punctuation">(</span><span class="token string">'jsliang'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">var</span> cost <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> money <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        money <span class="token operator">+=</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> money<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">cost</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未真正求值</span>
<span class="token function">cost</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未真正求值</span>
<span class="token function">cost</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未真正求值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 求值并输出：600</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><h2 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h2> <h3 id="创建"><a href="#创建" class="header-anchor">#</a> 创建</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = [];
let b = new Array();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>初始化值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a = [1, 2, 3]; // [1, 2, 3]
let b = new Array(3); // [undefined, undefined, undefined]
let c = new Array([1, 2, 3]); // [1, 2, 3]
let d = new Array(3).fill(1); // [1, 1, 1]
let e = new Array(3).fill([]); // [[], [], []]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h3> <p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p> <h3 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h3> <ul><li><p>valueOf()方法返回数组本身。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>toString()方法返回数组的字符串形式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = [1, 2, 3, [4, 5, 6]];
arr.toString() // &quot;1,2,3,4,5,6&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>push()方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p></li> <li><p>pop()方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</p></li> <li><p><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</p></li> <li><p><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = ['a', 'b', 'c'];
a.unshift('x'); // 4
a // ['x', 'a', 'b', 'c']
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p></li> <li><p><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p></li> <li><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = ['a', 'b', 'c'];
a.reverse() // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
a // [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr.slice(start, end);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr.splice(start, count, addElement1, addElement2, ...);
splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
起始位置如果是负数，就表示从倒数位置开始删除。
插入元素，splice方法的第二个参数可以设为0。
如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>['d', 'c', 'b', 'a'].sort()
// ['a', 'b', 'c', 'd']
//sort()方法不是按照大小排序，而是按照字典顺序。
自定义方式排序
[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]
排序顺序可以是字母或数字，也可以是升序或降序。

以升序对数组中的数字进行排序

​```
var points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return a-b}); // [1,5,10,25,40,100].
​```
以降序对数组中的数字进行排序
points.sort(function(a, b){return b-a});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li> <li><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p> <p><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身。</p> <p><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量</p> <p>Map()返回一个数组，该数组的长度与调用该数组的长度相同。只要它的回调函数没有改变，它也不会改变原始数组。它也可以采用三个类型参数（元素，值和索引）。</p></li> <li><p><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法。forEach()接受另一个函数作为参数。它用于以一种简单的方式循环遍历数组项。它可以接受三个类型的参数（元素，值和索引）。</p></li> <li><p><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。<code>filter</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。<code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p></li> <li><p><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>。</p></li> <li><p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。<code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</p></li> <li><p><code>reduce</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员）。该函数reduce有两个位置参数，第一个是累加器，另一个是迭代值，它返回累加值。</p> <p>函数4个参数:</p> <ol><li>Accumulator (acc) (累计器)</li> <li>Current Value (cur) (当前值)</li> <li>Current Index (idx) (当前索引)</li> <li>Source Array (src) (源数组)</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>const users = [  { name: 'John', age: 34 },  { name: 'Amy', age: 20 },  { name: 'camperCat', age: 10 }];
const sumOfAges = users.reduce((sum, user) =&gt; sum + user.age, 0);console.log(sumOfAges); //Returns: 64.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>还有一个可选参数<code>initialValue</code>, 该参数将作为第一次调用回调函数时的第一个参数的值。如果没有提供<code>initialValue</code>，则将使用数组中的第一个元素。</p></li> <li><p><code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员）</p></li> <li><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>。</p></li> <li><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。</p></li></ul> <h3 id="链式使用"><a href="#链式使用" class="header-anchor">#</a> 链式使用</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>var users = [
  {name: 'tom', email: 'tom@example.com'},
  {name: 'peter', email: 'peter@example.com'}
];

users
.map(function (user) {
  return user.email;
})
.filter(function (email) {
  return /^t/.test(email);
})
.forEach(function (email) {
  console.log(email);
});
// &quot;tom@example.com&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="过滤唯一值"><a href="#过滤唯一值" class="header-anchor">#</a> 过滤唯一值</h3> <p><code>Set</code>类型是在 <code>ES6</code>中新增的，它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> <p>结合扩展运算符（...）我们可以创建一个新的数组，达到过滤原数组重复值的功能。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const array = [1, 2, 3, 3, 5, 5, 1];
const uniqueArray = [...new Set(array)];
console.log(uniqueArray); // [1, 2, 3, 5]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>这个技巧的适用范围是数组中的数值的类型为： <code>undefined</code>， <code>null</code>， <code>boolean</code>， <code>string</code>， <code>number</code>。</p> <p>当包涵 <code>object</code>， <code>function</code>， <code>array</code>时，则不适用。</p></blockquote> <h3 id="数组循环"><a href="#数组循环" class="header-anchor">#</a> 数组循环</h3> <h3 id="数组空位"><a href="#数组空位" class="header-anchor">#</a> 数组空位</h3> <p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p> <p>如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = [1, 2, 3,];
a.length // 3
a // [1, 2, 3]
数组的空位是可以读取的，返回undefined。
var a = [, , ,];
a[1] // undefined

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = [1, 2, 3];
delete a[1];
a[1] // undefined
a.length // 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p> <p>空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p> <h3 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>const arr = [1, 1, 2, 3, 3];
// 期望得到：[1, 2, 3]

// 方法一：for 配合新数组截取
const newArr1 = [];
for (let i = 0; i &lt; arr.length; i++) {
  if (!newArr1.includes(arr[i])) {
    newArr1.push(arr[i]); 
  }
}
console.log('newArr1：', newArr1);

// 方法二：使用 Set
const newArr2 = [...new Set(arr)];
console.log('newArr2：', newArr2);

// 方法三：使用 filter
const newArr3 = arr.filter((item, index) =&gt; arr.lastIndexOf(item) === index);
console.log('newArr3：', newArr3);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="多维数组"><a href="#多维数组" class="header-anchor">#</a> 多维数组</h3> <p><code>reduce()</code> 二维降一维</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const newArr = oldArr.reduce((prev, curr) =&gt; (prev.concat(curr)), []);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>concat()</code> 二维降一维</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const oldArr = [1, 2, [3, 4]];
const newArr = [].concat(...oldArr);
const newnewArr = Array.prototype.concat.apply([], oldArr);
console.log(newArr);
// [1, 2, 3, 4]
console.log(newnewArr);
// [1, 2, 3, 4]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>flat()</code> 二维降一维</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const oldArr = [1, 2, [3, 4]];
const newArr = oldArr.flat();
console.log(newArr);
// [1, 2, 3, 4]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>多维降一维数组递归降维，这里有两个方法：</p> <ul><li><code>forEach</code> 递归</li> <li><code>reduce</code> 递归</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>const oldArr = [
  1,
  [
    2, [3],
    [4, 5, 6],
    [7, 8, 9],
    10,
    11,
  ],
  12,
  13,
  14,
  [15, 16, 17],
];
const newArr = [];
const ergodic = (arr) =&gt; {
  arr.forEach((item) =&gt; {
    if (Array.isArray(item)) {
      ergodic(item);
    } else {
      newArr.push(item);
    }
  })
}
ergodic(oldArr, newArr);
console.log(newArr);
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
//或
const ergodic = (arr) =&gt; arr.reduce((prev, curr, index, list) =&gt; {
  if (Array.isArray(curr)) {
    return prev.concat(...ergodic(curr));
  }
  return prev.concat(curr);
}, []);

const newArr = ergodic(oldArr);
console.log(newArr);
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>flat 降维</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>arr.flat(depth)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>depth</code> 即拉平几层默认拉平一层</p> <p>使用 <code>flat()</code> 拉平数组过程中，会移除数组的空项：</p> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>什么是构造函数？</p> <p>当任意一个普通函数用于创建一个类对象时，它就被称作构造函数，或构造器。</p> <p>它有几点特性：</p> <ol><li>默认函数首字母大写</li> <li>通过 <code>new</code> 调用一个函数</li> <li>构造函数返回的是一个对象</li></ol> <h3 id="new做了什么"><a href="#new做了什么" class="header-anchor">#</a> new做了什么</h3> <p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4
个步骤：
(1) 创建一个新对象；
(2) 链接新创建的对象和构造函数的原型对象（就是将新对象的隐式原型<code>__proto__</code>指向构造函数的原型对象<code>prototype</code>）；
(3) 执行构造函数中的代码，并将构造函数中的this指向新的对象（为这个新对象添加属性） ；
(4) 返回新对象。</p> <h4 id="new-操作符"><a href="#new-操作符" class="header-anchor">#</a> <strong>new 操作符</strong></h4> <p>能完成传统面向对象的class + new的方式创建对象。</p> <p><strong>var obj = new  Base();</strong></p> <p>new操作符具体干了什么呢?</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//创建了一个空对象obj</span>
obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Base</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//将这个空对象的__proto__成员指向了Base函数对象prototype成员对象</span>
<span class="token function">Base</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将Base函数对象的this指针替换成obj，然后再调用Base函数</span>
<span class="token comment">//</span>
<span class="token keyword">var</span> f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> f<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//创建一个带引用的变量</span>
f<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Fun</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//给f增加一个属性_proto_指向构建函数的原型，即f._proto_ = Fun.prototype</span>
<span class="token function">Fun</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行Fun.call(f,a,b)，即创建Fun函数的执行上下文，其中this指向f</span>
<span class="token comment">//返回f</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>实现一个new函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//方法一</span>
<span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//1.拿到传入的参数中的第一个参数，即构造函数名Func</span>
  <span class="token keyword">var</span> Func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">//2.创建一个空对象obj,并让其继承Func.prototype</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Func</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">//3.执行构造函数，并将this指向创建的空对象obj</span>
  <span class="token function">Func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment">//4.返回创建的对象obj</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法二</span>
<span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//创建一个空的简单 JavaScript 对象（即{}）；</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//链接该对象（即设置该对象的构造函数）到另一个对象 ；（ 通俗理解就是新对象隐式原型__proto__链接到构造函数显式原型prototype上。）</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//新创建的对象作为 this 的上下文 ；（ 实际是执行了构造函数 并将构造函数作用域指向新对象 ）</span>
  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&quot;[object Object]&quot;</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj<span class="token punctuation">;</span><span class="token comment">//如果该函数没有返回对象，则返回 this。（ 实际是返回一个空对象， new Object()就是返回一个空对象{} ）</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法三</span>
<span class="token keyword">function</span> <span class="token function">newOperator</span><span class="token punctuation">(</span><span class="token parameter">constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> constructor <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">&quot;newOperator function the first param must be a function&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ES6 new.target 是指向构造函数</span>
  newOperator<span class="token punctuation">.</span>target <span class="token operator">=</span> constructor<span class="token punctuation">;</span>
  <span class="token comment">// 1.创建一个全新的对象，</span>
  <span class="token comment">// 2.并且执行[[Prototype]]链接</span>
  <span class="token comment">// 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span>
  <span class="token keyword">var</span> newObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span>
  <span class="token comment">// 除去constructor构造函数的其余参数</span>
  <span class="token keyword">var</span> argsArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 3.生成的新对象会绑定到函数调用的`this`。</span>
  <span class="token comment">// 获取到constructor函数返回结果</span>
  <span class="token keyword">var</span> ctorReturnResult <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObj<span class="token punctuation">,</span> argsArr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null</span>
  <span class="token keyword">var</span> isObject <span class="token operator">=</span>
    <span class="token keyword">typeof</span> ctorReturnResult <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> ctorReturnResult <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> isFunction <span class="token operator">=</span> <span class="token keyword">typeof</span> ctorReturnResult <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject <span class="token operator">||</span> isFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ctorReturnResult<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span>
  <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法四</span>
<span class="token keyword">function</span> <span class="token function">createNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//创建新的空对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//解构获得构造函数和参数</span>
  <span class="token keyword">let</span> <span class="token punctuation">[</span>constructor<span class="token punctuation">,</span> <span class="token operator">...</span>params<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//链接对象到函数原型</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
  <span class="token comment">//执行构造函数，将构造函数中的this指向obj对象</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//如果函数没有返回对象，就返回新创建的对象</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">?</span> result <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//创建Person构造函数，参数为name,age</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
　　<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> xm <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span><span class="token string">'xiaoming'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xm<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br></div></div><h3 id="arguments-对象"><a href="#arguments-对象" class="header-anchor">#</a> arguments 对象</h3> <p>在函数代码中，使用特殊对象 arguments，开发者<em>无需明确指出参数名</em>，就能访问它们。无论定义了几个参数，ECMAScript 可以接受任意多个参数（最多 25 个）</p> <p><strong>闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。</strong></p> <p>常规函数，有一个<code>prototype</code>属性，它是一个带有<code>constructor</code>属性的对象（原型对象）。 然而，箭头函数，没有这个<code>prototype</code>属性。 访问<code>prototype</code>属性时会返回<code>undefined</code>。</p> <p><code>... args</code>是剩余参数，剩余参数的值是一个包含所有剩余参数的数组，<strong>并且只能作为最后一个参数</strong>。剩余参数是第二个参数，这是不可能的，并会抛出语法错误。</p> <h2 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h2> <h3 id="创建-2"><a href="#创建-2" class="header-anchor">#</a> 创建</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {};//对象字面量
let obj=new Object({'name':'ross','age':18})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="变量如何做属性名"><a href="#变量如何做属性名" class="header-anchor">#</a> <strong>变量如何做属性名</strong></h3> <p>之前都是用<code>常量</code>做属性名</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let p1='name'
let obj={p1:'ross'}//属性名为'p1'
let obj={[p1]:'ross'}//属性名为'name'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意区别:</p> <ol><li>不加[]的属性名会自动变成字符串</li> <li>加了[]则会当作变量求值</li> <li>值不是字符串，则会自动变成字符串</li></ol> <h3 id="判断对象的类型"><a href="#判断对象的类型" class="header-anchor">#</a> 判断对象的类型</h3> <p>Object.prototype.toString.call()</p> <p>判断基本类型：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Null]”</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Undefined]”</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>“abc”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object String]”</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Number]”</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Boolean]”</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>判断原生引用类型：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//函数类型</span>
Function <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>“test”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Function]”</span>
<span class="token comment">//日期类型</span>
<span class="token keyword">var</span> date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Date]”</span>
<span class="token comment">//数组类型</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object Array]”</span>
<span class="token comment">//正则表达式</span>
<span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[hbc]at</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//”[object RegExp]”</span>
<span class="token comment">//自定义类型</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Rose&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//”[object Object]”</span>
很明显这种方法不能准确判断person是Person类的实例，而只能用<span class="token keyword">instanceof</span> 操作符来进行判断，如下所示：
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//输出结果为true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>JavaScript 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例。</p> <p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p> <p><strong><code>Object</code>对象本身的方法</strong></p> <p>所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.print = function (o) { console.log(o) };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong><code>Object</code>的实例方法</strong></p> <p>所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。</p> <p>它可以被<code>Object</code>实例直接使用。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.prototype.print = function () {
  console.log(this);
};
var obj = new Object();
obj.print() // Object
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="静态方法-2"><a href="#静态方法-2" class="header-anchor">#</a> 静态方法</h3> <p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法。</p> <p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性。</p> <h4 id="object-keys"><a href="#object-keys" class="header-anchor">#</a> <code>Object.keys</code></h4> <p>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</p> <h4 id="object-getownpropertynames"><a href="#object-getownpropertynames" class="header-anchor">#</a> <code>Object.getOwnPropertyNames</code></h4> <p>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</p> <p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性。<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var a = ['Hello', 'World'];
Object.keys(a) // [&quot;0&quot;, &quot;1&quot;]
Object.getOwnPropertyNames(a) // [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>计算对象属性的个数
Object.keys(obj).length // 2
Object.getOwnPropertyNames(obj).length // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>（1）对象属性模型的相关方法</strong></p> <ul><li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象。</li> <li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性。</li> <li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性。</li></ul> <p><strong>（2）控制对象状态的方法</strong></p> <ul><li><code>Object.preventExtensions()</code>：防止对象扩展。</li> <li><code>Object.isExtensible()</code>：判断对象是否可扩展。</li> <li><code>Object.seal()</code>：禁止对象配置。</li> <li><code>Object.isSealed()</code>：判断一个对象是否可配置。</li> <li><code>Object.freeze()</code>：冻结一个对象。</li> <li><code>Object.isFrozen()</code>：判断一个对象是否被冻结。</li></ul> <p><strong>（3）原型链相关方法</strong></p> <ul><li><p><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象。创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。它接收两个参数，不过第二个可选参数是属性描述符（不常用，默认是<code>undefined</code>）。</p></li> <li><p><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象。</p></li></ul> <h3 id="实例方法-2"><a href="#实例方法-2" class="header-anchor">#</a> 实例方法</h3> <p>方法定义在<code>Object.prototype</code>对象。它们称为实例方法。所有<code>Object</code>的实例对象都继承了这些方法。</p> <p><code>Object</code>实例对象的方法，主要有以下六个。</p> <ul><li><p><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</p></li> <li><p><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。</p> <p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</p></li> <li><p><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</p> <p>数组、函数、Date 对象都分别部署了自定义的toLocaleString方法，覆盖了Object.prototype.toLocaleString方法。</p></li> <li><p><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
  p: 123
};
obj.hasOwnProperty('p') // true
obj.hasOwnProperty('toString') // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</p></li> <li><p><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</p></li></ul> <h2 id="属性描述对象"><a href="#属性描述对象" class="header-anchor">#</a> 属性描述对象</h2> <p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>属性描述对象提供6个元属性。</p> <p>（1）<code>value</code></p> <p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p> <p>（2）<code>writable</code></p> <p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p> <p>（3）<code>enumerable</code></p> <p><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p> <p>（4）<code>configurable</code></p> <p><code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p> <p>（5）<code>get</code></p> <p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p> <p>（6）<code>set</code></p> <p><code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>。etters 并不保存一个实际值，它们的使命在于 <em>修改</em> 属性。当调用方法 <code>setter</code>， 返回 <code>undefined</code>。</p> <h3 id="object-getownpropertydescriptor"><a href="#object-getownpropertydescriptor" class="header-anchor">#</a> Object.getOwnPropertyDescriptor()</h3> <p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = { p: 'a' };
Object.getOwnPropertyDescriptor(obj, 'p')
// Object { value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
注意，Object.getOwnPropertyDescriptor()方法只能用于对象自身的属性，不能用于继承的属性。
var obj = { p: 'a' };
Object.getOwnPropertyDescriptor(obj, 'toString')
// undefined


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="object-getownpropertynames-2"><a href="#object-getownpropertynames-2" class="header-anchor">#</a> Object.getOwnPropertyNames()</h3> <p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = Object.defineProperties({}, {
  p1: { value: 1, enumerable: true },
  p2: { value: 2, enumerable: false }
});
Object.getOwnPropertyNames(obj)
// [&quot;p1&quot;, &quot;p2&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="object-defineproperty-、object-defineproperties"><a href="#object-defineproperty-、object-defineproperties" class="header-anchor">#</a> Object.defineProperty()、Object.defineProperties()</h3> <p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Object.defineProperty(object, propertyName, attributesObject)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>Object.defineProperty</code>方法接受三个参数，依次如下。</p> <ul><li>object：属性所在的对象</li> <li>propertyName：字符串，表示属性名</li> <li>attributesObject：属性描述对象</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = Object.defineProperty({}, 'p', {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});
obj.p // 123
obj.p = 246;
obj.p // 123
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: 'abc', enumerable: true },
  p3: { get: function () { return this.p1 + this.p2 },
    enumerable:true,
    configurable:true
  }
});
obj.p1 // 123
obj.p2 // &quot;abc&quot;
obj.p3 // &quot;123abc&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p> <p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p> <h3 id="object-prototype-propertyisenumerable"><a href="#object-prototype-propertyisenumerable" class="header-anchor">#</a> Object.prototype.propertyIsEnumerable()</h3> <p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {};
obj.p = 123;
obj.propertyIsEnumerable('p') // true
obj.propertyIsEnumerable('toString') // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="存取器"><a href="#存取器" class="header-anchor">#</a> 存取器</h3> <p>除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p> <p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = Object.defineProperty({}, 'p', {
  get: function () {
    return 'getter';
  },
  set: function (value) {
    console.log('setter: ' + value);
  }
});
obj.p // &quot;getter&quot;
obj.p = 123 // &quot;setter: 123&quot;
// 写法二
var obj = {
  get p() {
    return 'getter';
  },
  set p(value) {
    console.log('setter: ' + value);
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）。</p> <h3 id="对象的拷贝"><a href="#对象的拷贝" class="header-anchor">#</a> 对象的拷贝</h3> <p>通过<code>Object.defineProperty</code>方法来拷贝属性。</p> <h3 id="控制对象状态"><a href="#控制对象状态" class="header-anchor">#</a> 控制对象状态</h3> <p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，</p> <ul><li>最弱的一种是<code>Object.preventExtensions</code></li> <li>其次是<code>Object.seal</code></li> <li>最强的是<code>Object.freeze</code></li></ul> <p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性。</p> <p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p> <p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性。</p> <p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。</p> <p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。然而，它仅 对对象进行 <em>浅</em> 冻结，意味着只有 对象中的 <em>直接</em> 属性被冻结。如果属性是另一个 object，像案例中的 <code>address</code>，<code>address</code> 中的属性没有被冻结，仍然可以被修改。</p> <p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法。</p> <h2 id="字符串"><a href="#字符串" class="header-anchor">#</a> 字符串</h2> <p>字符串是有零个或者多个字符组成的有序数列。如果字符串的个数为零，则表明这个字符串为 <strong>空串（Null String）</strong>，长度为 0。空串表示为：<code>''</code>。</p> <p>如果字符串由空格组成，那么它就不是空串，而是有 n 个空格长度的字符串，例如：<code>' '</code>（它包含了一个空格，所以长度为 1）。</p> <h3 id="静态方法-3"><a href="#静态方法-3" class="header-anchor">#</a> 静态方法</h3> <h3 id="实例属性"><a href="#实例属性" class="header-anchor">#</a> 实例属性</h3> <p>String.prototype.length</p> <h3 id="实例方法-3"><a href="#实例方法-3" class="header-anchor">#</a> 实例方法</h3> <ul><li><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置。</li> <li><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。</li> <li><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</li> <li><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配。</li> <li><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配。</li> <li><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</li> <li><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。</li> <li><code>matchAll()</code>返回一个包含所有匹配正则表达式及分组捕获结果的迭代器</li> <li>padEnd在当前字符串尾部填充指定的字符串，直到达到指定的长度。返回一个新的字符串。</li> <li>padStart在当前字符串头部填充指定的字符串，直到达到指定的长度。返回一个新的字符串。</li> <li><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</li> <li>repeat返回指定重复次数的由元素组成的字符串对象。</li> <li><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</li> <li><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</li> <li><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</li> <li><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同。</li> <li><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</li> <li><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</li> <li>toLocaleLowerCase根据当前区域设置，将符串中的字符转换成小写。对于大多数语言来说，toLowerCase 的返回值是一致的。</li> <li>toLocaleUpperCase根据当前区域设置，将字符串中的字符转换成大写，对于大多数语言来说，toUpperCase的返回值是一致的。</li> <li>toUpperCase将字符串转换成大写并返回。</li> <li>toString返回用字符串表示的特定对象。</li> <li><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</li> <li>trimEnd()/trimRight从字符串的右侧去除空格。</li> <li>trimStart/trimLeft从字符串的左侧去除空格。</li></ul> <h2 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h2> <p><code>Symbol</code>类型是不可枚举的。<code>Object.keys</code>方法返回对象上的所有可枚举的键属性。<code>Symbol</code>类型是不可见的，并返回一个空数组。 记录整个对象时，所有属性都是可见的，甚至是不可枚举的属性。</p> <p>这是<code>Symbol</code>的众多特性之一：除了表示完全唯一的值（防止对象意外名称冲突，例如当使用2个想要向同一对象添加属性的库时），您还可以<code>隐藏</code>这种方式对象的属性（尽管不完全。你仍然可以使用<code>Object.getOwnPropertySymbols()</code>方法访问 <code>Symbol</code>。</p> <h2 id="json"><a href="#json" class="header-anchor">#</a> JSON</h2> <p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式</p> <blockquote><ol><li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li> <li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</li> <li>字符串必须使用双引号表示，不能使用单引号。</li> <li>对象的键名必须放在双引号里面。</li> <li>数组或对象最后一个成员的后面，不能加逗号。</li></ol></blockquote> <h3 id="静态方法-4"><a href="#静态方法-4" class="header-anchor">#</a> 静态方法</h3> <h4 id="json-stringify"><a href="#json-stringify" class="header-anchor">#</a> <code>JSON.stringify()</code></h4> <p>转成 JSON 字符串。注意，对于原始类型的字符串，转换结果会带双引号。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JSON.stringify('foo') === &quot;foo&quot; // false
JSON.stringify('foo') === &quot;\&quot;foo\&quot;&quot; // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
  a: undefined,
  b: function () {}
};
JSON.stringify(obj) // &quot;{}&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = [undefined, function () {}];
JSON.stringify(arr) // &quot;[null,null]&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>正则对象会被转成空对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>JSON.stringify(/foo/) // &quot;{}&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性。</p> <p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。这个类似白名单的数组，只对对象的属性有效，对数组无效。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var obj = {
  'prop1': 'value1',
  'prop2': 'value2',
  'prop3': 'value3'
};
var selectedProperties = ['prop1', 'prop2'];
JSON.stringify(obj, selectedProperties)
// &quot;{&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;}&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function f(key, value) {
  if (typeof value === &quot;number&quot;) {
    value = 2 * value;
  }
  return value;
}
JSON.stringify({ a: 1, b: 2 }, f)
// '{&quot;a&quot;: 2,&quot;b&quot;: 4}'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p> <p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 分行输出
JSON.stringify({ p1: 1, p2: 2 }, null, '\t')
// {
// 	&quot;p1&quot;: 1,
// 	&quot;p2&quot;: 2
// }
第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。
JSON.stringify({ p1: 1, p2: 2 }, null, 2);
/*
&quot;{
  &quot;p1&quot;: 1,
  &quot;p2&quot;: 2
}&quot;
*/

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</p> <h4 id="json-parse"><a href="#json-parse" class="header-anchor">#</a> <code>JSON.parse()</code></h4> <p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。</p> <p><code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，</p> <h2 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h2> <p>原型：</p> <p>原型对象：</p> <p>每个构造函数都有一个prototype属性，指向构造函数的原型对象，这个原型对象指向有一个construtor属性指回这个构造函数。通过这个属性可以共享属性和方法。构造函数内的属性和方法不可以共享。</p> <p>原型链：</p> <p>可看做是一个搜索链，实例属性和方法的查找轨迹。</p> <p>每个实例都有一个proto属性，当我们使用构造函数去创建实例时，实例的<code>__proto__</code>属性就会指向构造函数的原型对象。</p> <p>每个对象都有一个proto属性，通过这个属性可以查找原型对象中的属性和方法，如果找不到，继续查找原型对象的原型对象的属性和方法，直到Object.prototype.<strong>proto</strong> = null,这个过程就是原型链。</p> <p>prototype 被定义为：给其它对象提供共享属性的对象。</p> <p><strong>所有 object 对象都有一个隐式引用</strong></p> <p>通过原型，解决了构造函数共享实例方法的问题。原型对象默认有个constructor属性，如果指定实例的原型对象，则constructor也会改变。</p> <ul><li><p>构造函数 <code>funciton Person() {}</code></p></li> <li><p>实例 <code>const person = new Person()</code></p></li> <li><p>原型 <code>Person.prototype</code></p></li> <li><p>隐藏属性 <code>constructor</code></p> <p>等式 1：<code>person.constructor === Person</code></p> <p>等式 2：<code>Person.prototype.constructor === Person</code></p></li> <li><p>new</p></li> <li><p>查找实例对应的对象的原型 <code>person.__proto__ === Person.prototype</code></p></li> <li><p>函数对象指向</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>person.__proto__ === Person.prototype
Person.__proto__ === Function.prototype
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>普通对象指向</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>obj.__proto__ === Object.prototype
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>原型链</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>foo.__proto__ === Object.prototype
F.__proto__ === Function.prototype
F.__proto__.__proto__ === Object.prototype
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <p>其中每个 <strong>函数对象</strong> 都有一个 <code>prototype</code> 属性，这个属性的指向被称为这个函数对象的 <strong>原型对象</strong>（简称原型）。</p> <p>在 JavaScript 中，每个实例都会有个隐藏属性 <code>constructor</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>person<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>实例的属性 <code>constructor</code> 指向构造函数</strong></p> <p>同时，这个函数的原型的 <code>constructor</code> 会指向这个函数：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>在 JavaScript 中，每个 JavaScript 对象（普通对象和函数对象）都具有一个属性 <code>__proto__</code>，这个属性会指向该对象的原型。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'哈哈'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype
Person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Person.prototype.<code>__proto__</code></p> <p><strong>通过 <code>__proto__</code> 最终查找到的是 <code>null</code></strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>person.__proto__.__proto__ === Object.prototype
Object.prototype.__proto__ === null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>var F = function() {};
Object.prototype.a = function() {
  console.log('a');
};
Function.prototype.b = function() {
  console.log('b');
}
var f = new F();
f.a(); // 输出啥？
f.b(); // 输出啥？
F.a(); // 输出啥？
F.b(); // 输出啥？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>f.a() -&gt; a
f.b() -&gt; f.b is not a function
F.a() -&gt; a
F.b() -&gt; b
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>解析</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var F = function() {};
var f = new F();

    f.__proto__ === F.prototype
    F.__proto__ === Function.prototype
    f.__proto__.__proto__ === Object.prototype
f.a() 会先查找 f 自身存在 a 属性否；如果不存在，往 F 原型 F.prototype 上，看看有没有 a 否；如果不存在，往 Object.prototype 上找，发现 a。
而 f.b 就没有了，它可以通过 F.__proto__ 去查找到，因为定义到 Function.prototype 上了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h2> <ul><li><code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例。</li> <li><code>new Promise()</code> 传入一个函数，这个函数可以带 2 个参数：<code>resolve</code> 和 <code>reject</code>。</li> <li><code>resolve</code> 的作用是将 <code>Promise</code> 对象的状态从 “未完成” 变为 “成功”（<code>pending -&gt; resolved</code>）</li> <li><code>reject</code> 的作用是将 <code>Promise</code> 对象的状态从 “未完成” 变为 “失败”（<code>pending -&gt; rejected</code>）</li> <li>在没有执行 <code>resolve</code> 和 <code>reject</code> 之前，它们还是 <code>pending</code> 的。</li></ul> <p><strong><code>Promise</code> 有 3 种状态：<code>pending</code>、<code>fulfilled</code>、<code>rejected</code></strong></p> <p>Promise 的 <code>all</code> 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。</p> <p><code>Promise.race()</code> 方法是谁先走完谁先输出。</p> <p><code>Promise.all()</code> 和 <code>Promise.race()</code> 用法：</p> <ol><li><code>.all()</code> 作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。</li> <li><code>.race()</code> 作用也是接收一组异步任务，然后并行执行异步任务，只保留取第一个执行完成的异步操作的结果，其他的方法仍在执行，不过执行结果会被抛弃。</li></ol> <p>小总结：</p> <ol><li><code>Promise.all().then()</code> 结果中的数组的顺序和 <code>Promise.all()</code> 接收到的数组的顺序一致，并不会因为 <code>setTimeout</code> 的输出而改变。</li> <li><code>Promise.all()</code> 和 <code>Promise.then()</code> 碰到会抛出异常的情况，都只会抛出最先出现问题的那个，被 <code>.then()</code> 的第二个参数或者 <code>.catch()</code> 捕获，但是不会影响数组中其他的异步任务的执行。</li></ol> <h2 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h2> <h2 id="this"><a href="#this" class="header-anchor">#</a> this</h2> <ol><li><code>this</code>是一个<strong>关键字</strong>，<strong><code>this</code>无法被重写</strong></li> <li><code>this</code>被<strong>自动定义</strong>在所有函数的作用域中</li></ol> <p><code>this</code>关键字是一个非常重要的语法点。不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象。<code>this</code>可以用在构造函数之中，表示实例对象。</p> <p>简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var person = {
  name: '张三',
  describe: function () {
    return '姓名：'+ this.name;
  }
};
person.describe()

function f() {
  return '姓名：'+ this.name;
}

var A = {
  name: '张三',
  describe: f
};

var B = {
  name: '李四',
  describe: f
};

A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var A = {
  name: '张三',
  describe: function () {
    return '姓名：'+ this.name;
  }
};

var name = '李四';
var f = A.describe;
f() // &quot;姓名：李四&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）。</p> <p>使用场合</p> <p><strong>（1）全局环境</strong></p> <p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</p> <p>不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>。</p> <p><strong>（2）构造函数</strong></p> <p>构造函数中的<code>this</code>，指的是实例对象。</p> <p><strong>（3）对象的方法</strong></p> <p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</p> <p><strong>注意点</strong></p> <ul><li>避免多层 this</li> <li>避免数组处理方法中的 this</li> <li>避免回调函数中的 this</li></ul> <p><strong>绑定 this 的方法</strong></p> <p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p> <h3 id="this的绑定规则"><a href="#this的绑定规则" class="header-anchor">#</a> this的绑定规则</h3> <h4 id="默认绑定"><a href="#默认绑定" class="header-anchor">#</a> 默认绑定</h4> <p>默认绑定比较典型的一种判断就是：<strong>当使用不带任何修饰的函数引用进行调用时，只能使用默认绑定，而不能使用其他绑定规则</strong></p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
    <span class="token comment">//Window非严格模式下，如果应用了默认规则，那么this的值会指向Window对象</span>
   <span class="token comment">// 在严格模式下，使用默认规则得到的this值会指向undefined，</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="隐式绑定"><a href="#隐式绑定" class="header-anchor">#</a> 隐式绑定</h4> <p>当函数作为某个对象的方法调用时，此时这个对象就是函数的上下文对象，这时候<code>this</code>会指向这个对象</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//{foo: ƒ}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="隐式丢失"><a href="#隐式丢失" class="header-anchor">#</a> <strong>隐式丢失</strong></h5> <p>隐式绑定的函数，在有些情况下会丢失绑定的上下文对象，这时候就会应用我们的<strong>默认绑定</strong>规则，把<code>this</code>指向<code>Window对象</code>（非严格模式）或者<code>undefined</code>（严格模式）。</p> <div class="language- extra-class"><pre><code>var name = &quot;我是全局的name&quot;;
var obj = {
  name: &quot;我是obj的name&quot;,
  foo: function () {
    console.log(this.name); //我是全局的name
  },
};
let fn = obj.foo; //这里用变量fn保存foo函数
fn();
</code></pre></div><p>当我们执行<code>let fn = obj.foo</code>时，实际上是将<code>fn</code>指向了函数<code>foo</code>的地址，因此当我们执行<code>fn()</code>的时候实际上就是在执行<code>foo()</code></p> <p>隐式丢失还有一种情况，就是对象的方法作为参数传递到另外的函数中去</p> <div class="language- extra-class"><pre><code>var name = &quot;我是全局的name&quot;;
var obj = {
  name: &quot;我是obj的name&quot;,
  foo: function () {
    console.log(this.name); //我是全局的name
  },
};

function otherFn(fn) {
  fn();
}
otherFn(obj.foo);
</code></pre></div><p>参数在传递给函数的时候，会发生一个赋值操作，也就是将<strong>实参赋值给形参</strong></p> <h5 id="对象属性引用链"><a href="#对象属性引用链" class="header-anchor">#</a> <strong>对象属性引用链</strong></h5> <div class="language- extra-class"><pre><code>var obj1 = {
  name: &quot;obj1&quot;,
  obj2: {
    name: &quot;obj2&quot;,
    obj3: {
      name: &quot;obj3&quot;,
      foo: function () {
        console.log(this.name); //obj3
      },
    },
  },
};
obj1.obj2.obj3.foo();
</code></pre></div><h4 id="显式绑定"><a href="#显式绑定" class="header-anchor">#</a> 显式绑定</h4> <ul><li><p>call的用法</p> <div class="language- extra-class"><pre><code>var obj = {
  name: &quot;obj&quot;,
};
function foo() {
  console.log(this.name);	//obj
}
foo.call(obj);
</code></pre></div></li> <li><p>apply的用法</p> <div class="language- extra-class"><pre><code>var obj = {
  name: &quot;obj&quot;,
};
function foo() {
  console.log(this.name);	//obj
}
foo.apply(obj);
</code></pre></div></li> <li><p>bind的用法</p> <p><code>bind</code>函数可以传入指定对象作为<code>this</code>的指向对象，除此之外，<code>bind</code>函数还可以接受参数并存储起来，下次调用的时候可以只传入剩余的参数，</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">//还是刚刚隐式丢失的例子，我们使用bind函数绑定上obj对象看看</span>
<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">&quot;我是全局的name&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;我是obj的name&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">otherFn</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//会发现函数被传入进来以后，this依然指向obj而没有发生隐式丢失</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我是obj的name</span>
<span class="token punctuation">}</span>
<span class="token function">otherFn</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//我们这里不直接传入，而是把obj.foo包装一下再传入</span>
<span class="token comment">//绑定this的同时存储参数</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//第一个参数为null时，非严格模式下会以Window对象作为this指向值，后面会介绍</span>
    <span class="token comment">//给foo函数套了层壳子，并存储了两个参数1,2</span>
    <span class="token keyword">var</span> bindFoo <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//当调用这个包装函数的时候，传入的参数会连同之前存储的参数一起传给foo函数</span>
    <span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1 2 3</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div></li></ul> <p>call与apply区别参数不同，<code>call</code>函数接收多个参数并传入<code>foo</code>函数中，而<code>apply</code>函数接收的参数放在了一个数组里，然后拆分开来传入了<code>foo</code>函数中，</p> <div class="language- extra-class"><pre><code>var obj = {
  name: &quot;obj&quot;,
};
function foo(a,b,c) {
  console.log(this.name,a,b,c);	//obj 1 2 3
}
foo.call(obj,1,2,3);
foo.apply(obj,[1,2,3]);
</code></pre></div><h4 id="new绑定"><a href="#new绑定" class="header-anchor">#</a> new绑定</h4> <p><code>new</code>操作符也可以实现改变<code>this</code>指向，</p> <ul><li>创建一个新对象，将this绑定到新创建的对象</li> <li>使用传入的参数调用构造函数</li> <li>将创建的对象的_proto__指向构造函数的prototype</li> <li>如果构造函数没有显式返回一个对象，则返回创建的新对象，否则返回显式返回的对象（即手动返回的对象）</li></ul> <h4 id="箭头函数绑定"><a href="#箭头函数绑定" class="header-anchor">#</a> 箭头函数绑定</h4> <p>箭头函数中的<code>this</code>比较特殊，它的指向值不是动态决定的，而是由函数定义时作用域中包含的<code>this</code>值确定的，</p> <div class="language- extra-class"><pre><code>//定义一个箭头函数
var foo = () =&gt; {
  console.log(this.name);
};
var name = &quot;我是全局的name&quot;;
var obj1 = {
  name: &quot;我是obj1的name&quot;,
};

foo.call(obj1); // &quot;我是全局的name&quot;
</code></pre></div><h3 id="绑定规则的优先级"><a href="#绑定规则的优先级" class="header-anchor">#</a> 绑定规则的优先级</h3> <p>由低到高进行排序的话就是：</p> <ol><li><strong>默认绑定</strong></li> <li><strong>隐式绑定</strong></li> <li><strong>显示绑定</strong></li> <li><strong>new操作符绑定、箭头函数</strong></li></ol> <h3 id="call、apply、bind区别"><a href="#call、apply、bind区别" class="header-anchor">#</a> call、apply、bind区别</h3> <p>相同之处：<strong>改变函数体内 this 的指向。</strong></p> <p>不同之处：</p> <ul><li>call、apply的区别：接受参数的方式不一样。</li> <li>bind：不立即执行。而apply、call 立即执行。</li></ul> <p>在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p> <div class="language-jsx line-numbers-mode"><pre class="language-jsx"><code>此处若传入<span class="token keyword">null</span>或<span class="token keyword">undefined</span>，这里的<span class="token keyword">this</span>就会指向全局对象，在浏览器中就是window
<span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">/</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
<span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token operator">/</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>call、apply区别：</p> <p>参数不一样call多个参数，apply是数组。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">//数组追加</span>
<span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">12</span> <span class="token punctuation">,</span> <span class="token string">&quot;foo&quot;</span> <span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">&quot;Joe&quot;</span><span class="token punctuation">}</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2458</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> array2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Doe&quot;</span> <span class="token punctuation">,</span> <span class="token number">555</span> <span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>array1<span class="token punctuation">,</span> array2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//array1 值为  [12 , &quot;foo&quot; , {name:&quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] </span>
<span class="token comment">//最大值最小值</span>
<span class="token keyword">var</span>  numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">458</span> <span class="token punctuation">,</span> <span class="token number">120</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">215</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> maxInNumbers <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span> numbers<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">//458</span>
    maxInNumbers <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Math<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">458</span> <span class="token punctuation">,</span> <span class="token number">120</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">215</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//458</span>


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>利用bind实现柯里化</p> <div class="language-swift line-numbers-mode"><pre class="language-swift"><code>function <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token operator">+</span>c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/*
不改变this指向，传入undefined或者null均可
100会赋值给第一个参数a，相当于a=100
因此func(1,2)=a+b+c=100+1+2=103
*/</span>
<span class="token keyword">var</span> <span class="token keyword">func</span><span class="token operator">=</span>add<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 103</span>

<span class="token comment">/*
对func再次bind，a已经被绑定，200会赋值给b，相当于b=100
因此func(10)=a+b+c=100+200+10=310
*/</span>
<span class="token keyword">var</span> func2<span class="token operator">=</span><span class="token keyword">func</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 310</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="错误类型"><a href="#错误类型" class="header-anchor">#</a> 错误类型</h2> <p>当值不是预期类型时，会抛出<code>TypeErrors</code>。 JavaScript期望<code>name</code>是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出<code>TypeError</code>：<code>name is not a function</code></p> <p>当你编写了一些非有效的JavaScript时，会抛出语法错误，例如当你把<code>return</code>这个词写成<code>retrun</code>时。 当JavaScript无法找到您尝试访问的值的引用时，抛出<code>ReferenceErrors</code>。</p> <h2 id="类型转换"><a href="#类型转换" class="header-anchor">#</a> 类型转换</h2> <h3 id="转换boolean型"><a href="#转换boolean型" class="header-anchor">#</a> 转换Boolean型</h3> <p>常规的boolean型值只有 <code>true</code> 和 <code>false</code>，但是在JavaScript中我们可以将其他的值认为是 <code>‘truthy’</code> 或者 <code>‘falsy’</code>的。</p> <p>除了 <code>0</code>， <code>“”</code>， <code>null</code>， <code>undefined</code>， <code>NaN</code> 和 <code>false</code>,其他的我们都可以认为是 <code>‘truthy’</code>的。</p> <p>我们可以通过负运算符 <code>！</code>将一系列的变量转换成“boolean”型。</p> <h3 id="转换string型"><a href="#转换string型" class="header-anchor">#</a> 转换String型</h3> <p>通过 <code>+</code>连接运算符将一个number类型的变量转换成string类型。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const val = 1 + &quot;&quot;;console.log(val); // Result: &quot;1&quot;console.log(typeof val); // Result: &quot;string&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="转换number类型"><a href="#转换number类型" class="header-anchor">#</a> 转换Number类型</h3> <p>通过加法运算符 <code>+</code>将一个string类型的变量转回为number 类型的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let int = &quot;15&quot;;int = +int;console.log(int); // Result: 15console.log(typeof int); Result: &quot;number&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="快速float转integer"><a href="#快速float转integer" class="header-anchor">#</a> 快速Float转Integer</h3> <p>平时可以使用 <code>Math.floor(),Math.ceil()和Math.round()</code>将 <code>float</code>类型转换成 <code>integer</code>类型。</p> <p>但是还有一种更快的方法可以使用 <code>|(位或运算符)</code>将浮点数截断为整数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(23.9 | 0);  // Result: 23console.log(-23.9 | 0); // Result: -23
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>|</code> 的行为取决于处理的是正数还是负数，所以最好只在确定的情况下使用这个快捷方式。</p> <p>如果n是正数的，则 <code>n|0</code> 有效地向下舍入。</p> <p>如果n是负数的，它则有效地向上取整。</p> <h2 id="event-loop"><a href="#event-loop" class="header-anchor">#</a> Event Loop</h2> <p>JS 是单线程执行的，指的是一个进程里只有一个主线程</p> <p><strong>进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位</strong>。</p> <h3 id="多进程与多线程"><a href="#多进程与多线程" class="header-anchor">#</a> 多进程与多线程</h3> <ul><li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li> <li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul> <h3 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h3> <p>浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p> <p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p> <ul><li>GUI 渲染线程</li> <li>JavaScript引擎线程</li> <li>定时触发器线程</li> <li>事件触发线程</li> <li>异步http请求线程</li></ul> <h4 id="gui渲染线程"><a href="#gui渲染线程" class="header-anchor">#</a> GUI渲染线程</h4> <ul><li>主要负责页面的渲染，解析HTML、CSS，构建DOM树，布局和绘制等。</li> <li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li> <li>该线程与JS引擎线程互斥，当执行JS引擎线程时，GUI渲染会被挂起，当任务队列空闲时，主线程才会去执行GUI渲染。</li></ul> <h4 id="js引擎线程"><a href="#js引擎线程" class="header-anchor">#</a> JS引擎线程</h4> <ul><li>该线程当然是主要负责处理 JavaScript脚本，执行代码。</li> <li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS引擎线程的执行。</li> <li>当然，该线程与 GUI渲染线程互斥，当 JS引擎线程执行 JavaScript脚本时间过长，将导致页面渲染的阻塞。</li></ul> <h4 id="定时器触发线程"><a href="#定时器触发线程" class="header-anchor">#</a> 定时器触发线程</h4> <ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li> <li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待JS引擎线程执行。</li></ul> <h4 id="事件触发线程"><a href="#事件触发线程" class="header-anchor">#</a> 事件触发线程</h4> <ul><li>主要负责将准备好的事件交给 JS引擎线程执行。</li></ul> <p>比如 setTimeout定时器计数结束， ajax等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS引擎线程的执行。</p> <h4 id="异步http请求线程"><a href="#异步http请求线程" class="header-anchor">#</a> 异步http请求线程</h4> <ul><li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax等。</li> <li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执行。</li></ul> <h3 id="浏览器中的-event-loop"><a href="#浏览器中的-event-loop" class="header-anchor">#</a> 浏览器中的 Event Loop</h3> <p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<strong>宏任务队列可以有多个，微任务队列只有一个</strong>。</p> <ul><li>常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li> <li>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li></ul> <p><img src="https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p> <p>一开始执行栈空,我们可以把<strong>执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</strong>。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p> <p>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p> <p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是<strong>一个一个</strong>执行的；而 micro-task 出队时，任务是<strong>一队一队</strong>执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</p> <p><strong>执行渲染操作，更新界面</strong></p> <p>检查是否存在 Web worker 任务，如果有，则对其进行处理</p> <p>上述过程循环往复，直到两个队列都清空</p> <p><strong>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</strong></p> <h3 id="node-中的-event-loop"><a href="#node-中的-event-loop" class="header-anchor">#</a> Node 中的 Event Loop</h3> <p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。</p> <p>Node.js的运行机制如下:</p> <ul><li>V8引擎解析JavaScript脚本。</li> <li>解析后的代码，调用Node API。</li> <li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li> <li>V8引擎再将结果返回给用户。</li></ul> <p><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841bd9860c1ee9?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p> <p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p> <ul><li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li> <li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li></ul> <h3 id="node与浏览器的-event-loop-差异"><a href="#node与浏览器的-event-loop-差异" class="header-anchor">#</a> Node与浏览器的 Event Loop 差异</h3> <p><strong>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务</strong>。</p> <p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p> <ul><li>Node端，microtask 在事件循环的各个阶段之间执行</li> <li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul> <h2 id="简写技巧"><a href="#简写技巧" class="header-anchor">#</a> 简写技巧</h2> <ol><li><p>声明变量</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
let x;
let y = 20;
//Shorthand
let x, y = 20;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>给多个变量赋值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//使用数组解构来在一行中给多个变量赋值
//Longhand
let a, b, c;
a = 5;
b = 8;
c = 12;
//Shorthand
let [a, b, c] = [5, 8, 12];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>三元运算符</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
let marks = 26;
let result;
if(marks &gt;= 30){
 result = 'Pass';
}else{
 result = 'Fail';
}
//Shorthand
let result = marks &gt;= 30 ? 'Pass' : 'Fail';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>赋默认值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>使用 OR(||) 短路运算来给一个变量赋默认值，如果预期值不正确的情况下。
//Longhand
let imagePath;
let path = getImagePath();
if(path !== null &amp;&amp; path !== undefined &amp;&amp; path !== '') {
  imagePath = path;
} else {
  imagePath = 'default.jpg';
}
//Shorthand
let imagePath = getImagePath() || 'default.jpg';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p>与 (&amp;&amp;) 短路运算</p> <p>只有当某个变量为 true 时调用一个函数，那么你可以使用<code>与 (&amp;&amp;)</code>短路形式书写。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
if (isLoggedin) {
 goToHomepage();
}
//Shorthand
isLoggedin &amp;&amp; goToHomepage();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>交换两个变量</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>为了交换两个变量，我们通常使用第三个变量。我们可以使用数组解构赋值来交换两个变量。
let x = 'Hello', y = 55;
//Longhand
const temp = x;
x = y;
y = temp;
//Shorthand
[x, y] = [y, x];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>箭头函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
function add(num1, num2) {
   return num1 + num2;
}
//Shorthand
const add = (num1, num2) =&gt; num1 + num2;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>模板字符串</p> <p>一般使用 + 运算符来连接字符串变量。使用 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;mid=2650082586&amp;idx=2&amp;sn=b9e6b18e835e4734e7f10073004235fe&amp;chksm=83db907fb4ac1969c61de3c093cd9cc4c74d9bd721d30974348017ad46a96f2d3f66c832821c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">ES6<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的模板字符串，我们可以用一种更简单的方法实现这一点。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
console.log('You got a missed call from ' + number + ' at ' + time);
//Shorthand
console.log(`You got a missed call from ${number} at ${time}`);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>多行字符串</p> <p>对于多行字符串，我们一般使用 + 运算符以及一个新行转义字符（\n）。我们可以使用 (`) 以一种更简单的方式实现。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
console.log('JavaScript, often abbreviated as JS, is a\n' + 'programming language that conforms to the \n' +
'ECMAScript specification. JavaScript is high-level,\n' +
'often just-in-time compiled, and multi-paradigm.' );
//Shorthand
console.log(`JavaScript, often abbreviated as JS, is a programming language that conforms to the ECMAScript specification. JavaScript is high-level, often just-in-time compiled, and multi-paradigm.`);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>多条件检查</p> <p>对于多个值匹配，我们可以将所有的值放到数组中，然后使用<code>indexOf()</code>或<code>includes()</code>方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
if (value === 1 || value === 'one' || value === 2 || value === 'two') {
     // Execute some code
}
// Shorthand 1
if ([1, 'one', 2, 'two'].indexOf(value) &gt;= 0) {
    // Execute some code
}
// Shorthand 2
if ([1, 'one', 2, 'two'].includes(value)) {
    // Execute some code
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p>对象属性复制</p> <p>如果变量名和对象的属性名相同，那么我们只需要在对象语句中声明变量名，而不是同时声明键和值。<a href="http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;mid=2650080728&amp;idx=1&amp;sn=878299088f22dbd4ca2c35c801a84822&amp;chksm=83db98bdb4ac11ab74df0ce0f705055d391c7c5d2ba8a56b2fb839d0bc883d0ede678679b5ab&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">JavaScript<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 会自动将键作为变量的名，将值作为变量的值。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let firstname = 'Amitav';
let lastname = 'Mishra';
//Longhand
let obj = {firstname: firstname, lastname: lastname};
//Shorthand
let obj = {firstname, lastname};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>字符串转成数字</p> <p>有一些内置的方法，例如<code>parseInt</code>和<code>parseFloat</code>可以用来将字符串转为数字。我们还可以简单地在字符串前提供一个一元运算符 (+) 来实现这一点。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
let total = parseInt('453');
let average = parseFloat('42.6');
//Shorthand
let total = +'453';
let average = +'42.6';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>重复一个字符串多次</p> <p>为了重复一个字符串 N 次，你可以使用<code>for</code>循环。但是使用<code>repeat()</code>方法，我们可以一行代码就搞定。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
let str = '';
for(let i = 0; i &lt; 5; i ++) {
  str += 'Hello ';
}
console.log(str); // Hello Hello Hello Hello Hello
// Shorthand
'Hello '.repeat(5);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>指数幂</p> <p>可以使用<code>Math.pow()</code>方法来得到一个数字的幂。有一种更短的语法来实现，即双星号 (**)。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
const power = Math.pow(4, 3); // 64
// Shorthand
const power = 4**3; // 64
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>双非位运算符 (~~)</p> <p>双非位运算符是<code>Math.floor()</code>方法的缩写。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//Longhand
const floor = Math.floor(6.8); // 6
// Shorthand
const floor = ~~6.8; // 6
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>找出数组中的最大和最小数字</p> <p>使用 for 循环来遍历数组中的每一个值，然后找出最大或最小值。我们还可以使用 Array.reduce() 方法来找出数组中的最大和最小数字。但是使用扩展符号，我们一行就可以实现。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/ Shorthand
const arr = [2, 8, 15, 4];
Math.max(...arr); // 15
Math.min(...arr); // 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>For 循环</p> <p>为了遍历一个数组，我们一般使用传统的<code>for</code>循环。我们可以使用<code>for...of</code>来遍历数组。为了获取每个值的索引，我们可以使用<code>for...in</code>循环。</p> <p>使用<code>for...in</code>循环来遍历对象属性。</p></li> <li><p>合并数组</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let arr1 = [20, 30];
//Longhand
let arr2 = arr1.concat([60, 80]);
// [20, 30, 60, 80]
//Shorthand
let arr2 = [...arr1, 60, 80];
// [20, 30, 60, 80]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>深拷贝多级对象</p> <p>为了深拷贝一个多级对象，我们要遍历每一个属性并检查当前属性是否包含一个对象。如果当前属性包含一个对象，然后要将当前属性值作为参数递归调用相同的方法（例如，嵌套的对象）。</p> <p>我们可以使用<code>JSON.stringify()</code>和<code>JSON.parse()</code>，如果我们的对象不包含函数、undefined、NaN 或日期值的话。</p> <p>如果有一个单级对象，例如没有嵌套的对象，那么我们也可以使用扩展符来实现深拷贝。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {x: 20, y: {z: 30}};
//Longhand
const makeDeepClone = (obj) =&gt; {
  let newObject = {};
  Object.keys(obj).map(key =&gt; {
    if(typeof obj[key] === 'object'){
      newObject[key] = makeDeepClone(obj[key]);
    } else {
      newObject[key] = obj[key];
    }
  });
 return newObject;
}
const cloneObj = makeDeepClone(obj);
//Shorthand
const cloneObj = JSON.parse(JSON.stringify(obj));
//Shorthand for single level object
let obj = {x: 20, y: 'hello'};
const cloneObj = {...obj};
如果你的对象包含 function, undefined or NaN 值的话，JSON.parse(JSON.stringify(obj)) 就不会有效。因为当你 JSON.stringify 对象的时候，包含 function, undefined or NaN 值的属性会从对象中移除。因此，当你的对象只包含字符串和数字值时，可以使用JSON.parse(JSON.stringify(obj))。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li> <li><p>获取字符串中的字符</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let str = 'jscurious.com';
//Longhand
str.charAt(2); // c
//Shorthand
str[2]; // c
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li></ol> <h2 id="实践"><a href="#实践" class="header-anchor">#</a> 实践</h2> <p><strong>优先使用===，而不是==</strong></p> <p>JavaScript使用两种相等性操作符：===|!==和==|!=。通常认为做比较的最佳实践是使用前一组操作符。</p> <p><strong>Eval就是糟糕的代名词</strong></p> <p>对于那些不熟悉JavaScript的人来说，函数”evel”让我们能够访问JavaScript编译器。我们可以通过给”eval”传递一个字符串参数来得到该字符串执行的结果。</p> <p>这不仅会极大地降低你的脚本的性能，也会造成一个巨大的安全隐患，因为这赋予传递进来的纯文本太多的能力。要尽可能地避免eval函数的使用。</p> <p><strong>在For语句之外声明变量</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var container = document.getElementById('container');
for(var i = 0, len = someArray.length; i &lt; len; i++) {    
container.innerHtml += 'my number: ' + i;    
console.log(i);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>构建字符串的最快方式</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var arr = ['item 1', 'item 2', 'item 3', ...];
var list = '&lt;ul&gt;&lt;li&gt;' + arr.join('&lt;/li&gt;&lt;li&gt;') + '&lt;/li&gt;&lt;/ul&gt;';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>减少全局变量</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var DudeNameSpace = {    name: 'Jeffrey',    lastname: 'Way',    doSometing: function() {...}}
console.log(DudeNameSpace.name);   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>通过将全局的东西封装进单个命名空间，能够大大降低与其他应用、部件、代码库交互混乱的概率。”— Douglas Crockford</p> <p><strong>注释你的代码</strong></p> <p><strong>拥抱渐进增强</strong></p> <p><strong>不要传递字符串给”SetInterval”或”SetTimeOut”</strong></p> <p><strong>不要使用”With”语句</strong></p> <p><strong>使用{}而不是New Object()</strong></p> <p><strong>使用[]而不是New Array()</strong></p> <p><strong>一长串变量？省略”var”关键字，使用逗号替代</strong></p> <p><strong>始终，始终使用分号</strong></p> <p><strong>自执行函数(Self-Executing Functions)</strong></p> <p>相比调用函数，当页面加载或调用父函数时，让函数自动执行会简单些。简单地将你的函数包装在圆括号内，并添加额外的一对圆括号，其本质上就调用了这个函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(functiondoSomething() {    return {        name: 'jeff',        lastName: 'way'    }; })();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>原始(raw)JavaScript代码的执行速度始终快于使用代码库</strong></p> <h2 id="基本规范"><a href="#基本规范" class="header-anchor">#</a> 基本规范</h2> <ol><li>不要在同一行声明多个变量</li> <li>使用 ===或!==来比较true/false或者数值</li> <li>switch必须带有default分支</li> <li>函数应该有返回值</li> <li>for if else 必须使用大括号</li> <li>语句结束加分号</li> <li>命名要有意义，使用驼峰命名法</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/cats1/vuepresshome/edit/main/docs/front/js/README.md" target="_blank" rel="noopener noreferrer">有问题需改善此页面!</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front/html5/html5.html" class="prev">
        html5新特性
      </a></span> <span class="next"><a href="/front/js/currying.html">
        柯里化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4743452.js" defer></script><script src="/assets/js/2.b72805e3.js" defer></script><script src="/assets/js/82.f4018c72.js" defer></script>
  </body>
</html>
