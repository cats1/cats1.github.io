<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器渲染原理 | lana&#39;s home</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="vuepress 前端个人学习网站">
    
    <link rel="preload" href="/assets/css/0.styles.98530cad.css" as="style"><link rel="preload" href="/assets/js/app.a4743452.js" as="script"><link rel="preload" href="/assets/js/2.b72805e3.js" as="script"><link rel="preload" href="/assets/js/103.9abec0c7.js" as="script"><link rel="prefetch" href="/assets/js/10.97c6631e.js"><link rel="prefetch" href="/assets/js/100.ddd238ad.js"><link rel="prefetch" href="/assets/js/101.acf46de3.js"><link rel="prefetch" href="/assets/js/102.7ecc34c5.js"><link rel="prefetch" href="/assets/js/104.99a0bd64.js"><link rel="prefetch" href="/assets/js/105.5bd4279e.js"><link rel="prefetch" href="/assets/js/106.4a1a1e6d.js"><link rel="prefetch" href="/assets/js/107.53190e25.js"><link rel="prefetch" href="/assets/js/108.afb416d9.js"><link rel="prefetch" href="/assets/js/109.9c89f8cf.js"><link rel="prefetch" href="/assets/js/11.efe147a8.js"><link rel="prefetch" href="/assets/js/110.77f01a7c.js"><link rel="prefetch" href="/assets/js/111.f8ccec3a.js"><link rel="prefetch" href="/assets/js/112.a1b70a36.js"><link rel="prefetch" href="/assets/js/113.f74d3176.js"><link rel="prefetch" href="/assets/js/114.9f4f70ac.js"><link rel="prefetch" href="/assets/js/115.3e915f82.js"><link rel="prefetch" href="/assets/js/116.21d4d9f8.js"><link rel="prefetch" href="/assets/js/117.ed1ac975.js"><link rel="prefetch" href="/assets/js/118.b60ec45f.js"><link rel="prefetch" href="/assets/js/119.a28f9722.js"><link rel="prefetch" href="/assets/js/12.f8166b62.js"><link rel="prefetch" href="/assets/js/120.5f45ba33.js"><link rel="prefetch" href="/assets/js/121.e2c73c6e.js"><link rel="prefetch" href="/assets/js/122.bea0d35f.js"><link rel="prefetch" href="/assets/js/123.4918a056.js"><link rel="prefetch" href="/assets/js/124.e9d5fd6b.js"><link rel="prefetch" href="/assets/js/125.378cd9ad.js"><link rel="prefetch" href="/assets/js/126.785be7e4.js"><link rel="prefetch" href="/assets/js/127.2dfe1120.js"><link rel="prefetch" href="/assets/js/128.0eeadbcb.js"><link rel="prefetch" href="/assets/js/129.ffd3ffd2.js"><link rel="prefetch" href="/assets/js/13.669aa6cb.js"><link rel="prefetch" href="/assets/js/130.e3caaa90.js"><link rel="prefetch" href="/assets/js/131.8914dd22.js"><link rel="prefetch" href="/assets/js/132.0ae37932.js"><link rel="prefetch" href="/assets/js/133.e989899b.js"><link rel="prefetch" href="/assets/js/134.ea062f20.js"><link rel="prefetch" href="/assets/js/135.6c137b49.js"><link rel="prefetch" href="/assets/js/14.c9aa70a1.js"><link rel="prefetch" href="/assets/js/15.3d05e5f2.js"><link rel="prefetch" href="/assets/js/16.360281d8.js"><link rel="prefetch" href="/assets/js/17.ff7cabb3.js"><link rel="prefetch" href="/assets/js/18.be16eeed.js"><link rel="prefetch" href="/assets/js/19.81b3a31e.js"><link rel="prefetch" href="/assets/js/20.472bc449.js"><link rel="prefetch" href="/assets/js/21.86395f2b.js"><link rel="prefetch" href="/assets/js/22.6c69ed50.js"><link rel="prefetch" href="/assets/js/23.2f198631.js"><link rel="prefetch" href="/assets/js/24.748c9bc2.js"><link rel="prefetch" href="/assets/js/25.c5065323.js"><link rel="prefetch" href="/assets/js/26.61d441a1.js"><link rel="prefetch" href="/assets/js/27.bfd0a986.js"><link rel="prefetch" href="/assets/js/28.bafeb054.js"><link rel="prefetch" href="/assets/js/29.0d2a1bfd.js"><link rel="prefetch" href="/assets/js/3.7f8809fd.js"><link rel="prefetch" href="/assets/js/30.8bb40757.js"><link rel="prefetch" href="/assets/js/31.eac619f5.js"><link rel="prefetch" href="/assets/js/32.04c63c5c.js"><link rel="prefetch" href="/assets/js/33.ae09c55e.js"><link rel="prefetch" href="/assets/js/34.1145a6f4.js"><link rel="prefetch" href="/assets/js/35.feb9083f.js"><link rel="prefetch" href="/assets/js/36.a586ce8a.js"><link rel="prefetch" href="/assets/js/37.c61e20e9.js"><link rel="prefetch" href="/assets/js/38.991c3427.js"><link rel="prefetch" href="/assets/js/39.23356a49.js"><link rel="prefetch" href="/assets/js/4.6819ae80.js"><link rel="prefetch" href="/assets/js/40.a3ca9111.js"><link rel="prefetch" href="/assets/js/41.649b9d9b.js"><link rel="prefetch" href="/assets/js/42.fde8ad7b.js"><link rel="prefetch" href="/assets/js/43.2d876a7c.js"><link rel="prefetch" href="/assets/js/44.64c20de7.js"><link rel="prefetch" href="/assets/js/45.a901a632.js"><link rel="prefetch" href="/assets/js/46.4ac83b64.js"><link rel="prefetch" href="/assets/js/47.2b45c49a.js"><link rel="prefetch" href="/assets/js/48.2bc12623.js"><link rel="prefetch" href="/assets/js/49.52a95dcd.js"><link rel="prefetch" href="/assets/js/5.20de2bc4.js"><link rel="prefetch" href="/assets/js/50.f445c922.js"><link rel="prefetch" href="/assets/js/51.07570e18.js"><link rel="prefetch" href="/assets/js/52.cf21a2b8.js"><link rel="prefetch" href="/assets/js/53.77792ddd.js"><link rel="prefetch" href="/assets/js/54.f19c487a.js"><link rel="prefetch" href="/assets/js/55.7fb0d05b.js"><link rel="prefetch" href="/assets/js/56.62fd0b66.js"><link rel="prefetch" href="/assets/js/57.1d6b0809.js"><link rel="prefetch" href="/assets/js/58.1aed920b.js"><link rel="prefetch" href="/assets/js/59.c2ab9dbe.js"><link rel="prefetch" href="/assets/js/6.e9784f3e.js"><link rel="prefetch" href="/assets/js/60.f4e387a9.js"><link rel="prefetch" href="/assets/js/61.735cc066.js"><link rel="prefetch" href="/assets/js/62.312489f2.js"><link rel="prefetch" href="/assets/js/63.dd2a2d4e.js"><link rel="prefetch" href="/assets/js/64.67dfd073.js"><link rel="prefetch" href="/assets/js/65.c2c22de8.js"><link rel="prefetch" href="/assets/js/66.7ea30a4b.js"><link rel="prefetch" href="/assets/js/67.6913be8c.js"><link rel="prefetch" href="/assets/js/68.b743701c.js"><link rel="prefetch" href="/assets/js/69.088259eb.js"><link rel="prefetch" href="/assets/js/7.80ddef84.js"><link rel="prefetch" href="/assets/js/70.10e2101b.js"><link rel="prefetch" href="/assets/js/71.11121db3.js"><link rel="prefetch" href="/assets/js/72.38811b9b.js"><link rel="prefetch" href="/assets/js/73.b5030976.js"><link rel="prefetch" href="/assets/js/74.d218c8d5.js"><link rel="prefetch" href="/assets/js/75.89c8d415.js"><link rel="prefetch" href="/assets/js/76.998def7e.js"><link rel="prefetch" href="/assets/js/77.6cff4b72.js"><link rel="prefetch" href="/assets/js/78.45b13ba4.js"><link rel="prefetch" href="/assets/js/79.50d5b3d0.js"><link rel="prefetch" href="/assets/js/8.4ebeab97.js"><link rel="prefetch" href="/assets/js/80.e38925eb.js"><link rel="prefetch" href="/assets/js/81.c712e794.js"><link rel="prefetch" href="/assets/js/82.f4018c72.js"><link rel="prefetch" href="/assets/js/83.878fb392.js"><link rel="prefetch" href="/assets/js/84.7ddaa3ca.js"><link rel="prefetch" href="/assets/js/85.06c8fa8b.js"><link rel="prefetch" href="/assets/js/86.b889a2e3.js"><link rel="prefetch" href="/assets/js/87.2f3171f1.js"><link rel="prefetch" href="/assets/js/88.1b0c6839.js"><link rel="prefetch" href="/assets/js/89.293034a1.js"><link rel="prefetch" href="/assets/js/9.07e73bd0.js"><link rel="prefetch" href="/assets/js/90.cdd9df6a.js"><link rel="prefetch" href="/assets/js/91.e53063a5.js"><link rel="prefetch" href="/assets/js/92.0a41da3b.js"><link rel="prefetch" href="/assets/js/93.83c37c7e.js"><link rel="prefetch" href="/assets/js/94.14eea0cb.js"><link rel="prefetch" href="/assets/js/95.18279896.js"><link rel="prefetch" href="/assets/js/96.e06d8e4e.js"><link rel="prefetch" href="/assets/js/97.2b60994e.js"><link rel="prefetch" href="/assets/js/98.28ad17a5.js"><link rel="prefetch" href="/assets/js/99.2abf3996.js">
    <link rel="stylesheet" href="/assets/css/0.styles.98530cad.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lana's home" class="logo"> <span class="site-name can-hide">lana's home</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" class="nav-link router-link-active">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="随笔" class="dropdown-title"><span class="title">随笔</span> <span class="arrow down"></span></button> <button type="button" aria-label="随笔" class="mobile-dropdown-title"><span class="title">随笔</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/front/html5/" class="nav-link">
  Html5
</a></li><li class="dropdown-subitem"><a href="/front/css/" class="nav-link">
  Css
</a></li><li class="dropdown-subitem"><a href="/front/js/" class="nav-link router-link-active">
  js
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nodejs/" class="nav-link">
  Nodejs
</a></li><li class="dropdown-subitem"><a href="/backend/koa/" class="nav-link">
  Koa
</a></li><li class="dropdown-subitem"><a href="/backend/mongodb/" class="nav-link">
  Mongodb
</a></li></ul></li><li class="dropdown-item"><h4>
          服务器
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/backend/nginx/" class="nav-link">
  Nginx
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/guide/guide.html" class="nav-link">
  指引
</a></div><div class="nav-item"><a href="https://gitee.com/lanasine" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/cats1/vuepresshome" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Backend</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Front</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/" aria-current="page" class="sidebar-link">前端</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Echarts</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Html 5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/js/" aria-current="page" class="sidebar-link">js</a></li><li><a href="/front/js/currying.html" class="sidebar-link">柯里化</a></li><li><a href="/front/js/es.html" class="sidebar-link">es</a></li><li><a href="/front/js/es5-es6-typescript.html" class="sidebar-link">/front/js/es5-es6-typescript.html</a></li><li><a href="/front/js/generator.html" class="sidebar-link">Generator 函数的语法</a></li><li><a href="/front/js/httpxie-yi.html" class="sidebar-link">HTTP协议</a></li><li><a href="/front/js/promise.html" class="sidebar-link">Promise</a></li><li><a href="/front/js/symbol.html" class="sidebar-link">Symbol</a></li><li><a href="/front/js/array.html" class="sidebar-link">数组</a></li><li><a href="/front/js/async.html" class="sidebar-link">async 函数</a></li><li><a href="/front/js/class.html" class="sidebar-link">class</a></li><li><a href="/front/js/function.html" class="sidebar-link">函数</a></li><li><a href="/front/js/javascript.html" class="sidebar-link">/front/js/javascript.html</a></li><li><a href="/front/js/js-question.html" class="sidebar-link">JavaScript 进阶问题</a></li><li><a href="/front/js/jsji-chu.html" class="sidebar-link">js基础</a></li><li><a href="/front/js/jsxiao-ji-qiao.html" class="sidebar-link">JS 中的!与!!用法</a></li><li><a href="/front/js/jsnan-dian.html" class="sidebar-link">JavaScript难点</a></li><li><a href="/front/js/let.html" class="sidebar-link">es6</a></li><li><a href="/front/js/module.html" class="sidebar-link">module</a></li><li><a href="/front/js/momentjs.html" class="sidebar-link">momentjs</a></li><li><a href="/front/js/object.html" class="sidebar-link">对象</a></li><li><a href="/front/js/set.html" class="sidebar-link">Set</a></li><li><a href="/front/js/style.html" class="sidebar-link">编程风格</a></li><li><a href="/front/js/shi-jian-mo-xing.html" class="sidebar-link">事件模型</a></li><li><a href="/front/js/ben-di-cun-chu-.html" class="sidebar-link">本地存储</a></li><li><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html" aria-current="page" class="active sidebar-link">浏览器渲染原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#流程" class="sidebar-link">流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#文档对象模型-dom" class="sidebar-link">文档对象模型 (DOM)</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#css-对象模型-cssom" class="sidebar-link">CSS 对象模型 (CSSOM)</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#渲染树-render-tree" class="sidebar-link">渲染树（render-tree）</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#布局-layout-计算渲染树节点大小" class="sidebar-link">布局（layout）–计算渲染树节点大小</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#绘制-paint" class="sidebar-link">绘制（paint）</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#html-解析过程与-domcontentloaded-触发时机" class="sidebar-link">HTML 解析过程与 DOMContentLoaded 触发时机</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#关键渲染路径优化" class="sidebar-link">关键渲染路径优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#css阻塞渲染" class="sidebar-link">CSS阻塞渲染</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#javascript阻塞渲染" class="sidebar-link">JavaScript阻塞渲染</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#font阻塞渲染" class="sidebar-link">font阻塞渲染</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#关键资源路径" class="sidebar-link">关键资源路径</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#html文档的加载与页面的首次渲染" class="sidebar-link">HTML文档的加载与页面的首次渲染</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#domcontentloaded-事件的触发" class="sidebar-link">DomContentLoaded 事件的触发</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#load-事件的触发" class="sidebar-link">load 事件的触发</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#性能优化" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#代码层面的优化" class="sidebar-link">代码层面的优化</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#什么是etag" class="sidebar-link">什么是Etag？</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#浏览器兼容性" class="sidebar-link">浏览器兼容性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#css兼容性问题" class="sidebar-link">CSS兼容性问题</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#js部分的兼容性" class="sidebar-link">JS部分的兼容性</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#三颗树-图示" class="sidebar-link">三颗树（图示）</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#渲染主流程" class="sidebar-link">渲染主流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#构建dom树-生成了dom树" class="sidebar-link">构建DOM树（生成了DOM树）</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#样式计算-生成css-rule-tree-computedstyle" class="sidebar-link">样式计算（生成CSS Rule Tree(ComputedStyle)）</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#把css转换为浏览器能够理解的结构" class="sidebar-link">把CSS转换为浏览器能够理解的结构</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#转换样式表中的属性值-使其标准化" class="sidebar-link">转换样式表中的属性值，使其标准化</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#计算dom树中每个节点的具体样式" class="sidebar-link">计算DOM树中每个节点的具体样式</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#布局阶段" class="sidebar-link">布局阶段</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#分层" class="sidebar-link">分层</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#图层绘制-重绘发生在此处" class="sidebar-link">图层绘制（重绘发生在此处）</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#栅格化操作" class="sidebar-link">栅格化操作</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#合成和显示" class="sidebar-link">合成和显示</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#性能优化-2" class="sidebar-link">性能优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#异步加载js的三种方法" class="sidebar-link">异步加载JS的三种方法</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#如何更新样式" class="sidebar-link">如何更新样式</a></li><li class="sidebar-sub-header"><a href="/front/js/liu-lan-qi-xuan-ran-yuan-li.html#js-css更新样式经过的步骤有哪些" class="sidebar-link">JS/CSS更新样式经过的步骤有哪些</a></li></ul></li></ul></li><li><a href="/front/js/bi-bao.html" class="sidebar-link">闭包</a></li><li><a href="/front/js/fang-dou-yu-jie-liu.html" class="sidebar-link">防抖（debounce）</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><p class="sidebar-heading"><span>Typescript</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Treejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vscode</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Guide</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="header-anchor">#</a> 浏览器渲染原理</h1> <p>浏览器从服务器那收到的HTML,CSS,JavaScript等相关资源，然后经过一系列处理后渲染出来的web页面的过程</p> <h2 id="流程"><a href="#流程" class="header-anchor">#</a> 流程</h2> <ol><li><p>浏览器将获取的HTML文档解析成DOM树</p></li> <li><p>处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)</p></li> <li><p>将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象</p></li> <li><p>渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素(文档流、盒模型、计算大小和位置)</p></li> <li><p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting（把边框颜色、文字颜色、阴影等画出来）</p></li></ol> <p><img src="https://img-blog.csdnimg.cn/20200525171403420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgxMzcxOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p><img src="https://img-blog.csdnimg.cn/20190808191842342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p><img src="https://img-blog.csdnimg.cn/20190808172810845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <h3 id="文档对象模型-dom"><a href="#文档对象模型-dom" class="header-anchor">#</a> 文档对象模型 (DOM)</h3> <p><img src="https://img-blog.csdnimg.cn/20190808173138660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>上图展示了从html的字节码被浏览器处理为DOM的过程</p> <ol><li>转换：根据字节的编码规则将字节转化为特定字符，也就是characters（字符）</li> <li>生成tokens：将character转化为w3c定义的各种特定标签 ，生成tokens（令牌）</li> <li>词法解析：匹配字符串，将tokens按照规则转换为包含特定属性和规则的节点对象（nodes）</li> <li>DOM构建：根据每个节点的层次关系和规则转换为直观的树形结构，具有明确的父子关系。</li></ol> <p>值得一提的是，HTML都是增量构建的，在HTML文件还在传输时html parse就可以开始了。并且是 基于深度优先原则，深度优先就是一条道走到黑，就是一条枝干走到头之后再返回来走另一条枝干。最终我们的得到了页面完整的文档对象模型（DOM），在以后的页面渲染包括布局、绘制等都会用到它。<strong>它代表了页面的结构，决定了整个页面的初始格局，而下面的CSS对象模型（CSSOM）决定了页面的五彩斑斓。</strong></p> <h3 id="css-对象模型-cssom"><a href="#css-对象模型-cssom" class="header-anchor">#</a> CSS 对象模型 (CSSOM)</h3> <p><img src="https://img-blog.csdnimg.cn/20190808175928523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>老规矩先放图，上图是CSSOM构建流程图，跟DOM构建差不多的套路，将CSS文件的字节码转换为符合浏览器特定规则的字符，然后浏览器对其进行解析和构成树。</p> <p>与DOM有所不同的是，其整个的计算过程略有复杂，包括一套复杂的特异度计算规则（CSS属性来源 -&gt; 特异度大小 -&gt; 书写顺序前后覆盖），最终确定每个节点的样式值形成下图的不完整CSSOM。</p> <p>CSS一直被认为是一种渲染阻塞资源（所谓CSS白屏），因为渲染树是依赖CSSOM才能生成，进而走浏览器的布局渲染流程，所以我们才有了CSS放在head的最佳实践。</p> <h3 id="渲染树-render-tree"><a href="#渲染树-render-tree" class="header-anchor">#</a> 渲染树（render-tree）</h3> <p><img src="https://img-blog.csdnimg.cn/20190808181004984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>渲染树生成大概经过以下过程：</p> <p>从DOM根节点根节点开始遍历每个在HTML和CSS意义上的可见节点。
对于每个可见节点，为其找到适配的CSSOM并且组合他们
将每个节点（包括内容和样式）组建成render-tree
可见节点：渲染树包含了渲染网页所需的所有节点，不需要渲染的节点是不会合并到渲染树中的，比如元数据元素meta，base等，还有设置了display:none的节点。</p> <h3 id="布局-layout-计算渲染树节点大小"><a href="#布局-layout-计算渲染树节点大小" class="header-anchor">#</a> 布局（layout）–计算渲染树节点大小</h3> <p>布局的最终结果是一个“盒模型”，它需要精确的计算出每个元素所占据的位置坐标，将如rem、vw、em等相对测量值（计算值）转换为屏幕上的绝对像素。</p> <p>将相对转换为绝对，这就需要首先明确或定义好相对的一个标准，是相对谁的相对值，如rem是相对根元素的font-size值，vw是相对视口的width等。</p> <p>简单介绍涉及到的viewport和html的font-size值</p> <p>device-width为浏览器的理想视口
在移动端，如果不设置viewport宽度为理想视口，viewport宽度通常为980px，这会导致文字很小，我们需要手动放大阅读。</p> <p>rem是 font size of the root element，简单一点可以设置html的字体大小为固定值（一般默认为16px），则width直接使用5rem(换算为80px)，也可以使用js根据viewport大小动态设置rem大小。</p> <p>同时也要注意，我们经常会在js或者是一些media query的设置不同断电，总之如果CSS元素的位置或大小等影响布局的因素发生变化，这是可能会触发回流，进行重新布局和渲染，这是我们在开发过程中要尽量避免和减小性能损耗的。</p> <h3 id="绘制-paint"><a href="#绘制-paint" class="header-anchor">#</a> 绘制（paint）</h3> <p>根据background, border, box-shadow等样式和HTML内容，将Layout生成的区域填充为最终将显示在屏幕上的像素。</p> <h2 id="html-解析过程与-domcontentloaded-触发时机"><a href="#html-解析过程与-domcontentloaded-触发时机" class="header-anchor">#</a> HTML 解析过程与 DOMContentLoaded 触发时机</h2> <p>DOMContentLoaded 意思就是：当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。</p> <p>load 意思就是：当一个资源及其依赖资源已完成加载时，将触发 load 事件。</p> <ol><li><p>在既没有 CSS 也没有 JS 的情况下，HTML 文档的解析过程为：</p> <p><img src="https://upload-images.jianshu.io/upload_images/12909466-75f6429c83e88201.jpg" alt="img"></p> <p>DOMContentLoaded 事件的触发时机为：HTML 解析为 DOM 之后。</p></li> <li><p>有 CSS 无 JS 的情况下，HTML 文档解析过程为：</p> <p><img src="https://upload-images.jianshu.io/upload_images/12909466-c0f8194be9374ecd.jpg" alt="img"></p> <p>这里与 1. 不同的地方在于，渲染树的生成是基于 DOM 和 CSSOM 的。但是触发 DOMContentLoaded 的时间依然是在 HTML 解析为 DOM 后，无论此时 CSS 解析为 CSSOM 的过程是否完成。</p></li> <li><p>当有 JS 时，HTML 文档解析过程为</p> <p><img src="https://upload-images.jianshu.io/upload_images/12909466-e58d21e1e3527cb0.jpg" alt="img"></p></li></ol> <h2 id="关键渲染路径优化"><a href="#关键渲染路径优化" class="header-anchor">#</a> 关键渲染路径优化</h2> <p>优化关键渲染路径是指优先显示与当前用户操作有关的内容。</p> <p>当前快速的网络体验，无数先贤在无数次尝试中不断改进才有了现代浏览器比较流畅的体验，这其中硬件软件支持不计其数，对web开发者来说，可以将浏览器看做一个黑盒，根据浏览器开发人员的API文档即可创建完整的应用程序，但追求极致的用户体验需要充分了解浏览器的运行机制和加速利器。</p> <h3 id="css阻塞渲染"><a href="#css阻塞渲染" class="header-anchor">#</a> CSS阻塞渲染</h3> <p>CSSOM形成前，<strong>浏览器不会渲染任何已处理内容</strong>，所以CSS被视为阻塞渲染的资源。</p> <p>解决CSS阻塞的问题有几个维度：</p> <ol><li>网速；</li> <li>大小；</li> <li>尽早并行下载；</li> <li>尽早开始构建CSSOM；</li> <li>构建CSSOM的速度</li></ol> <p>所以有如下几点优化：</p> <p>1、媒体查询
进入移动互联网时代有一段时间了，前端的使用场景可谓是处处开花，CSS的使用场景也越来越多样化，所以适配多端的代码必不可少，虽然媒体查询也下载全部CSS代码，但是只会解析符合媒体查询条件的代码，这就做到了尽量少的阻塞渲染。</p> <p>2、preload</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;link rel=&quot;preload&quot; href=&quot;index_print.css&quot; as=&quot;style&quot; οnlοad=&quot;this.rel='stylesheet'&quot;&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>preload是resoure  hint规范中定义的一个功能，顾名思义预加载，将rel改为preload后，相当于加了一个标志位，浏览器解析的时候会提前建立连接或加载资源，做到尽早并行下载，然后在onload事件响应后将link的rel属性改为stylesheet即可进行解析。</p> <p>3、动态添加link：js动态添加DOM元素link，不会阻塞渲染。</p> <p>4、代码简练，不使用CSS计算，避免使用通配、高级选择器。</p> <blockquote><p>四点注意事项：</p> <ol><li>将CSS放在head</li> <li>避免使用CSS import</li> <li>适度内联CSS，衡量其他因素，若外联网络来回影响多大，HTML大小，CSS大小</li> <li>全面考虑渲染情况，网速差、问价下载失败等，防止白屏时间太长。</li></ol> <p>讨论一下IE chrome firefox三者的差异：</p> <ol><li>IE 只要看到HTML 标签就会进行绘制</li> <li>chrome 不管css放在前面还是后面，都要等到CSSOM构建形成后才会绘制到页面上</li> <li>firefox 放在head则会阻塞绘制，放在body末尾会先绘制前面的标签</li></ol></blockquote> <h3 id="javascript阻塞渲染"><a href="#javascript阻塞渲染" class="header-anchor">#</a> JavaScript阻塞渲染</h3> <p>长久以来script标签的最佳实践是放在<code>&lt;/body&gt;</code>的前面，全是JavaScript功能太强大的锅。</p> <p>JavaScript赋予我们操作页面交互、界面呈现、请求资源等一系列权限，几乎能让我们对网页的每一个行为进行操作，而且随着硬件设备的强大、网络的进一步提升和用户的需求不断提高，未来web的权限、功能、可操作性、交互、体验会越来越强。</p> <p>扯远了，由于js可能会操作DOM和CSSOM，为了减少不必要的冲突和低效，浏览器都会做最坏的打算（js会操作DOM和CSSOM），所以正常情况下脚本执行会阻塞DOM构建，等待CSSOM的构建完毕再执行。</p> <ol><li>在HTML解析器解析到script标签后，会停止DOM构建，将控制权移交给javascript引擎，当js执行完毕后，浏览器会继续DOM构建。</li> <li>javascript可能会操作CSSOM，所以如果浏览器未先将CSSOM构建完毕，那么js将会暂停执行，同时DOM构建也会暂停。</li></ol> <blockquote><p>小结一下：</p> <ul><li>脚本在文档中的位置很重要，因为其跟另外两者有很强的依赖关系</li> <li>在HTML解析器解析到script标签后，会停止DOM构建</li> <li>javascript可以操作DOM和CSSOM，但进行这些行为时要确保相应DOM和CSSOM已经存在</li> <li>JavaScript 执行将暂停，直至 CSSOM 就绪</li></ul></blockquote> <p>所以总体来说，javascript在DOM、CSSOM和javascript之间加入了大量依赖关系，根本目的是为了有序高效渲染页面。若我们想要达到此根本目的，则需要明确依赖关系，其实可以类比模块化的思想处理这些关系。</p> <p>优化方法也就是处理依赖关系的方法：</p> <ol><li>脚本放在body底部</li> <li>defer</li> <li>async</li> <li>避免运行长时间的JavaScript，若初始化必须则考虑适当分割或ssr等措施</li></ol> <blockquote><p>“优化关键渲染路径”在很大程度上是指了解和优化 HTML、CSS 和 JavaScript 之间的依赖关系谱。</p></blockquote> <h3 id="font阻塞渲染"><a href="#font阻塞渲染" class="header-anchor">#</a> font阻塞渲染</h3> <p>浏览器为了避免FOUT(Flash Of Unstyled Text)，会尽量等待字体加载完成后，再显示应用了该字体的内容。</p> <p>只有当字体超过一段时间仍未加载成功时，浏览器才会降级使用系统字体。每个浏览器都规定了自己的超时时间。</p> <p>但这也带来了FOIT(Flash Of Invisible Text)问题。内容无法尽快地被展示，导致空白。</p> <p>资源的相互依赖是比较复杂的，首先要明确资源加载、解析的依赖关系，然后利用异步等方式将非关键资源阻塞，优化关键路径资源。</p> <h3 id="关键资源路径"><a href="#关键资源路径" class="header-anchor">#</a> 关键资源路径</h3> <p>三大指标目标：</p> <ol><li>关键资源大小 — 优化请求时间 解析渲染时间</li> <li>网络请求来回数目 — 优化请求时间</li> <li>关键资源数目 — 优化解析渲染时间</li></ol> <p>prefetch 利用缓存</p> <p>减少资源大小：</p> <ol><li>避免返回无用内容</li> <li>针对特定语言的源码压缩</li> <li>通用文本压缩</li> <li>图片压缩</li></ol> <p>减少请求来回时间：</p> <ol><li>服务器优化：
<ol><li>chunked encoding</li> <li>尽早返回数据</li> <li>服务端渲染</li></ol></li> <li>合理利用缓存
<ol><li>CacheControl</li> <li>ETag</li> <li>localstorage</li> <li>service worker</li></ol></li> <li>优化网络
<ol><li>HTTP 2</li> <li>CDN</li> <li>域名分割</li> <li>减少重定向</li> <li>resource-hint</li></ol></li></ol> <p>总结一下关键渲染路径优化的一般步骤：</p> <ol><li>分析关键渲染路径中的资源大小、来回、渲染顺序</li> <li>最大限度删减关键资源数目，也就是尽量只渲染首屏必须资源，其他的异步或延迟（async defer ssr ajax）</li> <li>合并请求数目，减少请求往返次数，减少资源字节数（内联js、 css）</li> <li>优化加载渲染顺序，最大化利用浏览器渲染引擎和js引擎。（调整资源DOM顺序）</li></ol> <h2 id="html文档的加载与页面的首次渲染"><a href="#html文档的加载与页面的首次渲染" class="header-anchor">#</a> HTML文档的加载与页面的首次渲染</h2> <p>1、浏览器首先下载该地址所对应的 html 页面。</p> <p>2、浏览器解析 html 页面的 DOM 结构。</p> <p>3、开启下载线程对文档中的所有资源按优先级排序下载。</p> <p>4、主线程继续解析文档，到达 head 节点 ，head 里的外部资源是外链样式表和外链 js。</p> <p>​	 发现有外链 css 或者外链 js，如果是外链 js ，则停止解析后续内容，等待该资源下载，下载完后立刻执行。如果是外链 css，继续解析后续内容。</p> <p>5、解析到 body</p> <p>body 里的情况比较多，body 里可能只有 DOM 元素，可能既有 DOM、也有 css、js 等资源，js 资源又有可能异步加载图片、css、js 等。DOM 结构不同，浏览器的解析机制也不同，所以需要分开来讨论。</p> <ul><li><p>只有 DOM 元素：</p> <p>这种情况比较简单了，DOM 树构建完，页面首次渲染。</p></li> <li><p>有 DOM 元素、外链 js：</p> <p>当解析到外链 js 的时候，该 js 尚未下载到本地，则 js 之前的 DOM 会被渲染到页面上，同时 js 会阻止后面 DOM  的构建，即后面的 DOM 节点并不会添加到文档的 DOM 树中。所以，js 执行完之前，我们在页面上看不到该 js 后面的 DOM 元素。</p></li> <li><p>有 DOM 元素、外链 css</p> <p>外链 css 不会影响 css 后面的 DOM 构建，但是会阻碍渲染。简单点说，外链 css 加载完之前，页面还是白屏。</p></li> <li><p>有 DOM 元素、外链 js、外链 css</p> <ul><li>外链 js 和外链 css 的顺序会影响页面渲染，这点尤为重要。当 body 中 js 之前的外链 css 未加载完之前，页面是不会被渲染的。</li> <li>当body中 js 之前的 外链 css 加载完之后，js 之前的 DOM 树和 css 合并渲染树，页面渲染出该 js 之前的 DOM 结构。</li></ul></li></ul> <p>6、文档解析完毕，页面重新渲染。当页面引用的所有 js 同步代码执行完毕，触发 DOMContentLoaded 事件。</p> <p>7、html 文档中的图片资源，js 代码中有异步加载的 css、js 、图片资源都加载完毕之后，load 事件触发。</p> <h3 id="domcontentloaded-事件的触发"><a href="#domcontentloaded-事件的触发" class="header-anchor">#</a> DomContentLoaded 事件的触发</h3> <p>DOMContentLoaded 事件在 html文档加载完毕，并且 html 所引用的内联 js、以及外链 js 的同步代码都执行完毕后触发。</p> <h3 id="load-事件的触发"><a href="#load-事件的触发" class="header-anchor">#</a> load 事件的触发</h3> <p>当页面 DOM 结构中的 js、css、图片，以及 js 异步加载的 js、css 、图片都加载完成之后，才会触发 load 事件。</p> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <ol><li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器等。</li> <li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等。</li> <li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</li> <li>请求带宽：压缩文件，开启GZIP，</li></ol> <h3 id="代码层面的优化"><a href="#代码层面的优化" class="header-anchor">#</a> 代码层面的优化</h3> <ul><li>用hash-table来优化查找</li> <li>少用全局变量</li> <li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li> <li>用setTimeout来避免页面失去响应</li> <li>缓存DOM节点查找的结果</li> <li>避免使用CSS Expression</li> <li>避免全局查询</li> <li>避免使用with(with会创建自己的作用域，会增加作用域链长度)</li> <li>多个变量声明合并</li> <li>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</li> <li>尽量避免写在HTML标签中写Style属性</li></ul> <p>移动端性能优化</p> <ul><li>尽量使用css3动画，开启硬件加速。</li> <li>适当使用touch事件代替click事件。</li> <li>避免使用css3渐变阴影效果。</li> <li>可以用transform: translateZ(0)来开启硬件加速。</li> <li>不滥用Float。Float在渲染时计算量比较大，尽量减少使用</li> <li>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</li> <li>合理使用requestAnimationFrame动画代替setTimeout</li> <li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</li> <li>PC端的在移动端同样适用</li></ul> <h3 id="什么是etag"><a href="#什么是etag" class="header-anchor">#</a> 什么是Etag？</h3> <p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</p> <ul><li>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</li> <li>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag
然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化</li> <li>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not  Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</li> <li>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①
① 只有get请求会被缓存，post请求不会</li></ul> <h6 id="etag应用"><a href="#etag应用" class="header-anchor">#</a> ETag应用:</h6> <p>Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下：
第一次请求</p> <ol><li>客户端发起 HTTP GET 请求一个文件；</li> <li>服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200</li></ol> <p>==第二次请求=
客户端发起 HTTP GET  请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办</p> <p>答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.(不要陷入到底使用谁的问题怪圈)
为什么使用Etag请求头?
Etag 主要为了解决 Last-Modified 无法解决的一些问题。</p> <h6 id="expires和cache-control"><a href="#expires和cache-control" class="header-anchor">#</a> Expires和Cache-Control</h6> <p>Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Cache-Control: no-cache, private, max-age=0
ETag: abcde
Expires: Thu, 15 Apr 2014 20:00:00 GMT
Pragma: private
Last-Modified: $now // RFC1123 format
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>总结：</p> <p>总体遵循着从下往上的大原则，细节上尽量并行下载，不阻塞主线程。具体来说，其实整个DOM是主线，所以遵循尽量快、并行解析DOM，尽快触发load事件，只要并行的两者不会相互影响就好，如DOM和CSSOM。</p> <p>在尽量不进行重复操作的前提下，尽量优先渲染关键路径，同时尽量加载非关键路径资源，尽量保证不被网速或者说未下载资源阻塞渲染。</p> <p>浏览器或者说厂商的最终目跟开发者一样，都是为了用户体验，总体来说浏览器实现甚至包括规范都是遵循用户&gt;开发者的原则。</p></blockquote> <h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="header-anchor">#</a> 浏览器兼容性</h2> <p>浏览器兼容性问题，往往是个别浏览器对一些标准定义不一致导致的。</p> <p>常用的浏览器及对应内核如下：</p> <table><thead><tr><th>浏览器</th> <th>内核</th></tr></thead> <tbody><tr><td>IE</td> <td>Trident</td></tr> <tr><td>Firefox</td> <td>Gecko</td></tr> <tr><td>chrome</td> <td>先为webkit，后为blink（与opear共同开发）</td></tr> <tr><td>Safari</td> <td>webkit</td></tr> <tr><td>Opera</td> <td>blink</td></tr> <tr><td>360</td> <td>IE+Chrome双内核</td></tr> <tr><td></td> <td></td></tr></tbody></table> <h3 id="css兼容性问题"><a href="#css兼容性问题" class="header-anchor">#</a> CSS兼容性问题</h3> <p>浏览器兼容性导致的问题：</p> <p>1.不同浏览器对解析标签默认的内边距和外边距不同
解决方式：<code>*{ margin: 0; padding: 0;}</code></p> <p>2.IE6双边距问题；在 IE6中设置了float , 同时又设置margin , 就会出现边距问题
解决方式：<code>display:inline;</code></p> <p>3.当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度
解决方案：超出高度的标签设置<code>overflow:hidden</code>,或者设置<code>line-height的</code>值小于你的设置高度</p> <p>4.图片默认有间距
解决方案：使用float 为img 布局</p> <p>5.IE9以下浏览器不能使用opacity
解决方法：<code>opacity: 0.5; filter: alpha(opacity = 50); -ms-filter: “progid:DXImageTransform.Microsoft.Alpha(opacity = 80)”;</code></p> <p>6.透明度兼容CSS设置</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>.transparent_class {  
      filter:alpha(opacity=50);  
      -moz-opacity:0.5;  
      -khtml-opacity: 0.5;  
      opacity: 0.5;  
}   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>7.标签最低高度设置min-height不兼容
解决方法：<code>{min-height:200px; height:auto !important; height:200px; overflow:visible;}</code></p> <p>8.cursor：hand显示手型在safari上不支持
解决方案：统一使用 <code>cursor:pointer</code>
9.解决 ie9 以下浏览器对 html5 新增标签不识别的问题。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!--[if lt IE 9]&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>10.解决 ie9 以下浏览器不支持 CSS3 Media Query 的问题。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;script src=&quot;https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>11.边距重叠问题；当相邻两个元素都设置了margin边距时，margin将取最大值，舍弃最小值；</p> <p>12.两个块级元素，父元素设置了overflow：auto；子元素设置了position：relative；且高度大于父元素，在IE6、IE7会被隐藏而不是溢出；</p> <p>解决方案：父级元素设置position：relative</p> <p>13.const问题</p> <p>说明：Firefox下，可以使用const关键字来定义常量；IE下，只能使用var关键字来定义常量。
解决方法：统一使用var关键字来定义常量。</p> <p>14.event.srcElement问题</p> <p>问题说明：IE下，event对象有srcElement属性，但是没有target属性；Firefox下，event对象有target属性，但是没有srcElement属性。
解决方法：使用srcObj = event.srcElement?event.srcElement:event.target;</p> <p>15.事件绑定</p> <p>IE:dom.attachEvent();
其他浏览器：dom.addEventListener();
标准浏览器采用事件捕获的方式对应IE的事件冒泡机制（即标准由最外元素至最内元素或者IE由最内元素到最外元素）最后标准方亦觉得IE这方面的比较合理，所以便将事件冒泡纳入了标准，这也是addEventListener第三个参数的由来，而且事件冒泡作为了默认值。</p> <p>16.操作tr的html</p> <p>在ie9以下，不能操作tr的innerHTML</p> <p>17.ajax略有不同</p> <p>IE：ActiveXObject
其他：xmlHttpReuest</p> <p>18.对象宽高赋值问题</p> <p>问题说明：FireFox中类似obj.style.height = imgObj.height的语句无效。</p> <p><strong>IE 条件注释</strong>
IE 的条件注释仅仅针对IE浏览器，对其他浏览器无效</p> <table><thead><tr><th>操作符</th> <th>含义</th></tr></thead> <tbody><tr><td>lt</td> <td>小于</td></tr> <tr><td>gt</td> <td>大于</td></tr> <tr><td>lte</td> <td>小于等于</td></tr> <tr><td>gte</td> <td>不小于</td></tr> <tr><td>!</td> <td>不等于</td></tr></tbody></table> <p><strong>IE 属性过滤器（较为常用的hack方法）</strong>
针对不同的 IE 浏览器，可以使用不同的字符来对特定的版本的 IE 浏览器进行样式控制</p> <table><thead><tr><th>字符</th> <th>例子</th> <th>说明</th></tr></thead> <tbody><tr><td>_</td> <td>_height：100px；</td> <td>IE6可以识别</td></tr> <tr><td>* 、+ 、!</td> <td>*height：100px;</td> <td>IE6 / IE7可以识别</td></tr> <tr><td>\0/</td> <td>height：100px\0/;</td> <td>IE8可以识别</td></tr> <tr><td>\9</td> <td>height：100px\9;</td> <td>IE6、7、8、9、10可以识别</td></tr></tbody></table> <p><strong>浏览器CSS兼容前缀</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>-o-transform: rotate(7deg);        // Opera
-ms-transform: rotate(7deg);       // IE
-moz-transform: rotate(7deg);      // Firefox
-webkit-transform: rotate(7deg);   // Chrome
transform: rotate(7deg);           // 统一标识语句
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="js部分的兼容性"><a href="#js部分的兼容性" class="header-anchor">#</a> JS部分的兼容性</h3> <p>浏览器宽高问题</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//以下均可console.log()实验
  var winW=document.body.clientWidth||document.docuemntElement.clientWidth;//网页可见区域宽
  var winH=document.body.clientHeight||document.docuemntElement.clientHeight;//网页可见区域宽
  //以上为不包括边框的宽高，如果是offsetWidth或者offsetHeight的话包括边框
   
  var winWW=document.body.scrollWidth||document.docuemntElement.scrollWidth;//整个网页的宽
  var winHH=document.body.scrollHeight||document.docuemntElement.scrollHeight;//整个网页的高
 
  var scrollHeight=document.body.scrollTop||document.docuemntElement.scrollTop;//网页被卷去的高
  var scrollLeft=document.body.scrollLeft||document.docuemntElement.scrollLeft;//网页左卷的距离
 
  var screenH=window.screen.height;//屏幕分辨率的高
  var screenW=window.screen.width;//屏幕分辨率的宽
  var screenX=window.screenLeft;//浏览器窗口相对于屏幕的x坐标（除了FireFox）
  var screenXX=window.screenX;//FireFox相对于屏幕的X坐标
  var screenY=window.screenTop;//浏览器窗口相对于屏幕的y坐标（除了FireFox）
  var screenYY=window.screenY;//FireFox相对于屏幕的y坐标

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>事件event获取源</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//event事件问题
  document.onclick=function(ev){//谷歌火狐的写法，IE9以上支持，往下不支持；
    var e=ev;
    console.log(e);
  }
  document.onclick=function(){//谷歌和IE支持，火狐不支持；
    var e=event;
    console.log(e);
  }
  document.onclick=function(ev){//兼容写法；
    var e=ev||window.event;
    var mouseX=e.clientX;//鼠标X轴的坐标
    var mouseY=e.clientY;//鼠标Y轴的坐标
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>DOM节点获取</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//DOM节点相关，主要兼容IE 6 7 8
  function nextnode(obj){//获取下一个兄弟节点
    if (obj.nextElementSibling) {
      return obj.nextElementSibling;
    } else{
      return obj.nextSibling;
    };
  }
  function prenode(obj){//获取上一个兄弟节点
    if (obj.previousElementSibling) {
      return obj.previousElementSibling;
    } else{
      return obj.previousSibling;
    };
  }
  function firstnode(obj){//获取第一个子节点
    if (obj.firstElementChild) {
      return obj.firstElementChild;//非IE678支持
    } else{
      return obj.firstChild;//IE678支持
    };
  }
  function lastnode(obj){//获取最后一个子节点
    if (obj.lastElementChild) {
      return obj.lastElementChild;//非IE678支持
    } else{
      return obj.lastChild;//IE678支持
    };
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>获取ClassName问题</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//通过类名获取元素
  document.getElementsByClassName('');//IE 6 7 8不支持；
 
  //这里可以定义一个函数来解决兼容问题，当然别在这给我提jQuery...
  //第一个为全局获取类名，第二个为局部获取类名
  function byClass1(oClass){//全局获取，oClass为你想要查找的类名，没有“.”
    var tags=document.all?document.all:document.getElementsByTagName('*');
    var arr=[];
    for (var i = 0; i &lt; tags.length; i++) {
      var reg=new RegExp('\\b'+oClass+'\\b','g');
      if (reg.test(tags[i].className)) {
        arr.push(tags[i]);
      };
    };
    return arr;//注意返回的也是数组，包含你传入的class所有元素；
  }
 
  function byClass2(parentID,oClass){//局部获取类名，parentID为你传入的父级ID
    var parent=document.getElementById(parentID);
    var tags=parent.all?parent.all:parent.getElementsByTagName('*');
    var arr=[];
    for (var i = 0; i &lt; tags.length; i++) {
    var reg=new RegExp('\\b'+oClass+'\\b','g');
      if (reg.test(tags[i].className)) {
        arr.push(tags[i]);
      };
    };
    return arr;//注意返回的也是数组，包含你传入的class所有元素；
   }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>获取元素的非行间样式值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//获取元素的非行间样式值
   function getStyle(object,oCss) {
       if (object.currentStyle) {
         return object.currentStyle[oCss];//IE
       }else{
         return getComputedStyle(object,null)[oCss];//除了IE
       }
   }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>设置监听事件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//设置监听事件
   function addEvent(obj,type,fn){//添加事件监听，三个参数分别为 对象、事件类型、事件处理函数，默认为false
    if (obj.addEventListener) {
      obj.addEventListener(type,fn,false);//非IE
    } else{
      obj.attachEvent('on'+type,fn);//ie,这里已经加上on，传参的时候注意不要重复加了
    };
  }
  function removeEvent(obj,type,fn){//删除事件监听
    if (obj.removeEventListener) {
      obj.removeEventListener(type,fn,false);//非IE
    } else{
      obj.detachEvent('on'+type,fn);//ie，这里已经加上on，传参的时候注意不要重复加了
    };
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>元素到浏览器边缘的距离</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//在这里加个元素到浏览器边缘的距离，很实用
  function offsetTL(obj){//获取元素内容距离浏览器边框的距离（含边框）
    var ofL=0,ofT=0;
    while(obj){
      ofL+=obj.offsetLeft+obj.clientLeft;
      ofT+=obj.offsetTop+obj.clientTop;
      obj=obj.offsetParent;
    }
    return{left:ofL,top:ofT};
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>阻止事件传播</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//js阻止事件传播，这里使用click事件为例
  document.onclick=function(e){
    var e=e||window.event;
    if (e.stopPropagation) {
      e.stopPropagation();//W3C标准
    }else{
      e.cancelBubble=true;//IE....
    }
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>阻止默认事件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//js阻止默认事件
  document.onclick=function(e){
    var e=e||window.event;
    if (e.preventDefault) {
      e.preventDefault();//W3C标准
    }else{
      e.returnValue='false';//IE..
    }
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>event事件的target</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//关于event事件中的target
  document.onmouseover=function(e){
    var e=e||window.event;
    var Target=e.target||e.srcElement;//获取target的兼容写法，后面的为IE
    var from=e.relatedTarget||e.formElement;//鼠标来的地方，同样后面的为IE...
    var to=e.relatedTarget||e.toElement;//鼠标去的地方
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>鼠标滚轮滚动事件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//鼠标滚轮事件
  //火狐中的滚轮事件
document.addEventListener(&quot;DOMMouseScroll&quot;,function(event){
    alert(event.detail);//若前滚的话为 -3，后滚的话为 3
  },false)
  //非火狐中的滚轮事件
  document.onmousewheel=function(event){
    alert(event.detail);//前滚：120，后滚：-120
  }

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>节点加载</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//火狐下特有的节点加载事件，就是节点加载完才执行，和onload不同
//感觉用到的不多，直接把js代码放在页面结构后面一样能实现。。
document.addEventListener('DOMContentLoaded',function ( ){},false);//DOM加载完成。好像除IE6-8都可以.

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="三颗树-图示"><a href="#三颗树-图示" class="header-anchor">#</a> 三颗树（图示）</h2> <p>如何理解HTML树（DOM）/ CSS树（CSSOM）/ Reader Tree（渲染树）三者的关系</p> <p><img src="https://pic4.zhimg.com/80/v2-65f3325c76fabc6a5b1e54a75af0adaf_720w.jpg" alt="img"></p> <p>默认我们会把<strong>标签</strong>当作<strong>节点</strong>，<strong>节点与节点</strong>之间相互连接，组成树枝、树干进而发展成树</p> <p>HTML树（DOM）+CSS树（CSSOM）=  Reader Tree（渲染树）</p> <p>通过Reader Tree（渲染树）我们可以确定浏览器的基本样式</p> <h2 id="渲染主流程"><a href="#渲染主流程" class="header-anchor">#</a> <strong>渲染主流程</strong></h2> <h3 id="构建dom树-生成了dom树"><a href="#构建dom树-生成了dom树" class="header-anchor">#</a> <strong>构建DOM树（生成了DOM树）</strong></h3> <p>为什么要构建DOM树呢？这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树。</p> <p><strong>它代表了页面的结构，决定了整个页面的初始格局，而下面的CSS对象模型（CSSOM）决定了页面的五彩斑斓。</strong></p> <h3 id="样式计算-生成css-rule-tree-computedstyle"><a href="#样式计算-生成css-rule-tree-computedstyle" class="header-anchor">#</a> <strong>样式计算</strong>**（生成CSS Rule Tree(ComputedStyle)）**</h3> <p>样式计算的目的是为了计算出DOM节点中每个元素的具体样式。</p> <p>这个阶段可以分为3个步骤：（同样的读取CSS内容也是和DOM树过程类似，先将CSS字节转为字符，再转为token和节点，最后形成树结构）</p> <ol><li><h3 id="把css转换为浏览器能够理解的结构"><a href="#把css转换为浏览器能够理解的结构" class="header-anchor">#</a> <strong>把CSS转换为浏览器能够理解的结构</strong></h3></li> <li><h3 id="转换样式表中的属性值-使其标准化"><a href="#转换样式表中的属性值-使其标准化" class="header-anchor">#</a> <strong>转换样式表中的属性值，使其标准化</strong></h3></li> <li><h3 id="计算dom树中每个节点的具体样式"><a href="#计算dom树中每个节点的具体样式" class="header-anchor">#</a> <strong>计算DOM树中每个节点的具体样式</strong></h3></li></ol> <h3 id="布局阶段"><a href="#布局阶段" class="header-anchor">#</a> <strong>布局阶段</strong></h3> <p>现在，我们有DOM树和DOM树中元素的样式，但这还不足以显示页面，因为我们还不知道DOM元素的几何位置信息。那么接下来就需要计算出DOM树中可见元素的几何位置，我们把这个计算过程叫做布局。</p> <p><strong>1）创建布局树（在这一步生成了渲染树）</strong></p> <p><strong>2）布局计算（回流/重排发生在此处）</strong></p> <h3 id="分层"><a href="#分层" class="header-anchor">#</a> <strong>分层</strong></h3> <h3 id="图层绘制-重绘发生在此处"><a href="#图层绘制-重绘发生在此处" class="header-anchor">#</a> <strong>图层绘制（重绘发生在此处）</strong></h3> <h3 id="栅格化操作"><a href="#栅格化操作" class="header-anchor">#</a> <strong>栅格化操作</strong></h3> <h3 id="合成和显示"><a href="#合成和显示" class="header-anchor">#</a> <strong>合成和显示</strong></h3> <h2 id="性能优化-2"><a href="#性能优化-2" class="header-anchor">#</a> 性能优化</h2> <p>CssTree的绘制是异步的，并发的，非阻塞的，而js是阻塞的，在dom树的构建过程中，如果碰到js文件，会先停止dom树的构建，转而执行js文件，因为js文件可能会涉及到dom元素的增删改查，会改变dom树与css树的结构，这也是为什么JS是单线程的原因，如果是多线程，一个线程要增加节点，而另一个线程要删除节点，会导致程序不知道如何执行，注意：这里的异步指的是下载异步，而不是执行异步，既然把js会修改Dom树的结构，阻塞Dom树的构建，那把js放到结束标签前面不就好了吗，等到dom树构建完了再加载js文件不就好了么，为什么还要异步加载JS呢？，因为如果要加载一些不处理页面的，比如一些工具包需要引入，加载这些工具方法没必要阻塞文档，过渡JS加载会影响页面效率，一旦网速不好，那么整个网站将等待JS加载而不进行后续渲染等工具，因此我们可以让一些工具方法按需加载，用到再加载，不用不加载。而这就需要用到异步加载js方法</p> <h3 id="异步加载js的三种方法"><a href="#异步加载js的三种方法" class="header-anchor">#</a> 异步加载JS的三种方法</h3> <ul><li><p><strong>defer异步加载</strong>：需要等到dom文档全部解析完后才会被执行，并且只有IE能用，也可以将代码写到内部</p> <p>只能在IE9 以下使用。不会阻断页面其他部分的加载，而是并行（同时）加载，但加载完后不会立马执行该代码。等到整个页面解析完成之后才执行。允许在Script标签里使用，也允许在引入的Script标签中使用，但不允许又引入文件又在Script标签里写代码</p></li> <li><p><strong>async异步加载</strong>：加载完就执行，async只能加载外部脚本，不能把js写在script标签里。</p> <p>W3C标准方法，支持IE9以及其他浏览器（chrome,firefox,safari,opera…）不会阻断页面其他部分的加载，而是并行（同时）加载，一旦加载完成后便立马执行，只允许在引入的script标签中使用。</p> <blockquote><p>但是，以上的两种方法都存在兼容性问题，不能完美支持所有浏览器，我们可能想到在一个script脚本中同时使用这两种方法，但这样会导致在IE9以上的浏览器会同时存在这两种方法，浏览器无法识别到底应该使用哪种方法，因此，我们需要一种更好的方法！</p></blockquote></li> <li><p><strong>按需加载</strong>：创建script，插入到dom中，加载完后执行回调callback.（最常用，最完美）</p> <p><img src="https://img-blog.csdnimg.cn/20190808125952670.png" alt="按需加载"></p> <p>在这里首先先新建一个标签，然后设置标签的类型，再给这个标签添加一个src属性，并给src赋值，在这句话执行完后，系统就会自动开启一个线程异步下载src里面的东西，但是 下载完成后并不会立马执行demo.js这个文件<img src="https://img-blog.csdnimg.cn/20190808130550288.png" alt="代码执行"></p> <p>而是等到对这个script标签被执行插入操作后才会执行里面的代码。</p> <p><img src="https://img-blog.csdnimg.cn/201908081445079.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="封装按需加载函数"></p> <p>但是，这个还不够完善，还有问题，当我们的网速太快的时候，script.readystate瞬间变成了最终状态  complete状态，而onreadystatechange事件的触发依靠script.readystate状态的改变，onreadystatechange检测不到script.readystate状态的改变便永远不会执行，因此我们需要让script.readystate有一个状态的转化，怎么实现呢，把script.src放到下面即可</p> <p><img src="https://img-blog.csdnimg.cn/20190808151307995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p> <p>原因是调用该函数的时候该函数体才开始执行，刚开始执行还没有test的存在。
有几种方法可以解决这个问题，一种是函数引用 function (){ test() };
一种是eval()，不推荐使用
最后一种可以与函数相配合实现</p> <p><img src="https://img-blog.csdnimg.cn/20190808165651603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODQwNzYx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul> <blockquote><p>defer 与async,两者有一些共通点</p> <ol><li>二者下载都不会阻塞DOM解析，这点还是很重要的，首屏时间就是一切</li> <li>都是给外链脚本使用，不考虑请求数量而使用内联情况下等因素的首选方式</li> <li>都可以使用onload事件进行一系列处理</li></ol> <p>二者最主要的不同点就是async其实只注重异步下载时不阻塞html解析，下载完毕后会立刻执行，而defer会完全保证异步下载和执行都不会阻塞html解析，这点在不同场景使用还是比较重要的。</p> <p>比如async就适合基本没DOM操作，不在乎依赖的模块，而且要尽可能小或者说执行时间短，否则对首屏可能还是影响很大的；defer相对而言就规矩的多了，按序加载，不会影响html解析。</p></blockquote> <h3 id="如何更新样式"><a href="#如何更新样式" class="header-anchor">#</a> 如何更新样式</h3> <p>可以通过JS/CSS更新样式，但我们一般用JS来更新浏览器样式</p> <ul><li>比如div.style.background=&quot; &quot;（不会用到，推荐第三种）</li> <li>比如div.style.display=&quot; &quot;（不会用到，推荐第三种）</li> <li><strong>比如div.classList.add(' ') —— 为DIV添加class，class中包含执行的属性</strong></li> <li><strong>比如div.remove( ) —— 移除所有节点</strong></li></ul> <h3 id="js-css更新样式经过的步骤有哪些"><a href="#js-css更新样式经过的步骤有哪些" class="header-anchor">#</a> JS/CSS更新样式经过的步骤有哪些</h3> <blockquote><p><strong>第一种，全走</strong></p></blockquote> <p>比如 div.remove( ) —— 触发移除当前所有的节点，其他元素relayout（重新布局）</p> <blockquote><p><strong>第二种，跳过Layout</strong></p></blockquote> <p>比如改变背景颜色，直接repaint（重新绘制）+composite（合成）</p> <blockquote><p><strong>第三种，跳过Layout和Paint</strong></p></blockquote> <p>比如改变transform(变换)，只需composite（合成）</p> <p>CSS渲染过程依次包含布局、绘制和合成，其中布局和绘制可以被省略掉</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/cats1/vuepresshome/edit/main/docs/front/js/浏览器渲染原理.md" target="_blank" rel="noopener noreferrer">有问题需改善此页面!</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front/js/ben-di-cun-chu-.html" class="prev">
        本地存储
      </a></span> <span class="next"><a href="/front/js/bi-bao.html">
        闭包
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a4743452.js" defer></script><script src="/assets/js/2.b72805e3.js" defer></script><script src="/assets/js/103.9abec0c7.js" defer></script>
  </body>
</html>
